{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/platform/markers/common/markerService.ts","vs/platform/markers/common/markerService.ts"],"names":[],"mappings":"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","file":"markerService.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isFalsyOrEmpty, isNonEmptyArray } from '../../../base/common/arrays';\nimport { DebounceEmitter } from '../../../base/common/event';\nimport { Iterable } from '../../../base/common/iterator';\nimport { IDisposable } from '../../../base/common/lifecycle';\nimport { ResourceMap } from '../../../base/common/map';\nimport { Schemas } from '../../../base/common/network';\nimport { URI } from '../../../base/common/uri';\nimport { IMarker, IMarkerData, IMarkerService, IResourceMarker, MarkerSeverity, MarkerStatistics } from './markers';\n\nexport const unsupportedSchemas = new Set([Schemas.inMemory, Schemas.vscodeSourceControl, Schemas.walkThrough, Schemas.walkThroughSnippet]);\n\nclass DoubleResourceMap<V> {\n\n\tprivate _byResource = new ResourceMap<Map<string, V>>();\n\tprivate _byOwner = new Map<string, ResourceMap<V>>();\n\n\tset(resource: URI, owner: string, value: V) {\n\t\tlet ownerMap = this._byResource.get(resource);\n\t\tif (!ownerMap) {\n\t\t\townerMap = new Map();\n\t\t\tthis._byResource.set(resource, ownerMap);\n\t\t}\n\t\townerMap.set(owner, value);\n\n\t\tlet resourceMap = this._byOwner.get(owner);\n\t\tif (!resourceMap) {\n\t\t\tresourceMap = new ResourceMap();\n\t\t\tthis._byOwner.set(owner, resourceMap);\n\t\t}\n\t\tresourceMap.set(resource, value);\n\t}\n\n\tget(resource: URI, owner: string): V | undefined {\n\t\tconst ownerMap = this._byResource.get(resource);\n\t\treturn ownerMap?.get(owner);\n\t}\n\n\tdelete(resource: URI, owner: string): boolean {\n\t\tlet removedA = false;\n\t\tlet removedB = false;\n\t\tconst ownerMap = this._byResource.get(resource);\n\t\tif (ownerMap) {\n\t\t\tremovedA = ownerMap.delete(owner);\n\t\t}\n\t\tconst resourceMap = this._byOwner.get(owner);\n\t\tif (resourceMap) {\n\t\t\tremovedB = resourceMap.delete(resource);\n\t\t}\n\t\tif (removedA !== removedB) {\n\t\t\tthrow new Error('illegal state');\n\t\t}\n\t\treturn removedA && removedB;\n\t}\n\n\tvalues(key?: URI | string): Iterable<V> {\n\t\tif (typeof key === 'string') {\n\t\t\treturn this._byOwner.get(key)?.values() ?? Iterable.empty();\n\t\t}\n\t\tif (URI.isUri(key)) {\n\t\t\treturn this._byResource.get(key)?.values() ?? Iterable.empty();\n\t\t}\n\n\t\treturn Iterable.map(Iterable.concat(...this._byOwner.values()), map => map[1]);\n\t}\n}\n\nclass MarkerStats implements MarkerStatistics {\n\n\terrors: number = 0;\n\tinfos: number = 0;\n\twarnings: number = 0;\n\tunknowns: number = 0;\n\n\tprivate readonly _data = new ResourceMap<MarkerStatistics>();\n\tprivate readonly _service: IMarkerService;\n\tprivate readonly _subscription: IDisposable;\n\n\tconstructor(service: IMarkerService) {\n\t\tthis._service = service;\n\t\tthis._subscription = service.onMarkerChanged(this._update, this);\n\t}\n\n\tdispose(): void {\n\t\tthis._subscription.dispose();\n\t}\n\n\tprivate _update(resources: readonly URI[]): void {\n\t\tfor (const resource of resources) {\n\t\t\tconst oldStats = this._data.get(resource);\n\t\t\tif (oldStats) {\n\t\t\t\tthis._substract(oldStats);\n\t\t\t}\n\t\t\tconst newStats = this._resourceStats(resource);\n\t\t\tthis._add(newStats);\n\t\t\tthis._data.set(resource, newStats);\n\t\t}\n\t}\n\n\tprivate _resourceStats(resource: URI): MarkerStatistics {\n\t\tconst result: MarkerStatistics = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };\n\n\t\t// TODO this is a hack\n\t\tif (unsupportedSchemas.has(resource.scheme)) {\n\t\t\treturn result;\n\t\t}\n\n\t\tfor (const { severity } of this._service.read({ resource })) {\n\t\t\tif (severity === MarkerSeverity.Error) {\n\t\t\t\tresult.errors += 1;\n\t\t\t} else if (severity === MarkerSeverity.Warning) {\n\t\t\t\tresult.warnings += 1;\n\t\t\t} else if (severity === MarkerSeverity.Info) {\n\t\t\t\tresult.infos += 1;\n\t\t\t} else {\n\t\t\t\tresult.unknowns += 1;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate _substract(op: MarkerStatistics) {\n\t\tthis.errors -= op.errors;\n\t\tthis.warnings -= op.warnings;\n\t\tthis.infos -= op.infos;\n\t\tthis.unknowns -= op.unknowns;\n\t}\n\n\tprivate _add(op: MarkerStatistics) {\n\t\tthis.errors += op.errors;\n\t\tthis.warnings += op.warnings;\n\t\tthis.infos += op.infos;\n\t\tthis.unknowns += op.unknowns;\n\t}\n}\n\nexport class MarkerService implements IMarkerService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _onMarkerChanged = new DebounceEmitter<readonly URI[]>({\n\t\tdelay: 0,\n\t\tmerge: MarkerService._merge\n\t});\n\n\treadonly onMarkerChanged = this._onMarkerChanged.event;\n\n\tprivate readonly _data = new DoubleResourceMap<IMarker[]>();\n\tprivate readonly _stats = new MarkerStats(this);\n\n\tdispose(): void {\n\t\tthis._stats.dispose();\n\t\tthis._onMarkerChanged.dispose();\n\t}\n\n\tgetStatistics(): MarkerStatistics {\n\t\treturn this._stats;\n\t}\n\n\tremove(owner: string, resources: URI[]): void {\n\t\tfor (const resource of resources || []) {\n\t\t\tthis.changeOne(owner, resource, []);\n\t\t}\n\t}\n\n\tchangeOne(owner: string, resource: URI, markerData: IMarkerData[]): void {\n\n\t\tif (isFalsyOrEmpty(markerData)) {\n\t\t\t// remove marker for this (owner,resource)-tuple\n\t\t\tconst removed = this._data.delete(resource, owner);\n\t\t\tif (removed) {\n\t\t\t\tthis._onMarkerChanged.fire([resource]);\n\t\t\t}\n\n\t\t} else {\n\t\t\t// insert marker for this (owner,resource)-tuple\n\t\t\tconst markers: IMarker[] = [];\n\t\t\tfor (const data of markerData) {\n\t\t\t\tconst marker = MarkerService._toMarker(owner, resource, data);\n\t\t\t\tif (marker) {\n\t\t\t\t\tmarkers.push(marker);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._data.set(resource, owner, markers);\n\t\t\tthis._onMarkerChanged.fire([resource]);\n\t\t}\n\t}\n\n\tprivate static _toMarker(owner: string, resource: URI, data: IMarkerData): IMarker | undefined {\n\t\tlet {\n\t\t\tcode, severity,\n\t\t\tmessage, source,\n\t\t\tstartLineNumber, startColumn, endLineNumber, endColumn,\n\t\t\trelatedInformation,\n\t\t\ttags,\n\t\t} = data;\n\n\t\tif (!message) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// santize data\n\t\tstartLineNumber = startLineNumber > 0 ? startLineNumber : 1;\n\t\tstartColumn = startColumn > 0 ? startColumn : 1;\n\t\tendLineNumber = endLineNumber >= startLineNumber ? endLineNumber : startLineNumber;\n\t\tendColumn = endColumn > 0 ? endColumn : startColumn;\n\n\t\treturn {\n\t\t\tresource,\n\t\t\towner,\n\t\t\tcode,\n\t\t\tseverity,\n\t\t\tmessage,\n\t\t\tsource,\n\t\t\tstartLineNumber,\n\t\t\tstartColumn,\n\t\t\tendLineNumber,\n\t\t\tendColumn,\n\t\t\trelatedInformation,\n\t\t\ttags,\n\t\t};\n\t}\n\n\tchangeAll(owner: string, data: IResourceMarker[]): void {\n\t\tconst changes: URI[] = [];\n\n\t\t// remove old marker\n\t\tconst existing = this._data.values(owner);\n\t\tif (existing) {\n\t\t\tfor (const data of existing) {\n\t\t\t\tconst first = Iterable.first(data);\n\t\t\t\tif (first) {\n\t\t\t\t\tchanges.push(first.resource);\n\t\t\t\t\tthis._data.delete(first.resource, owner);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// add new markers\n\t\tif (isNonEmptyArray(data)) {\n\n\t\t\t// group by resource\n\t\t\tconst groups = new ResourceMap<IMarker[]>();\n\t\t\tfor (const { resource, marker: markerData } of data) {\n\t\t\t\tconst marker = MarkerService._toMarker(owner, resource, markerData);\n\t\t\t\tif (!marker) {\n\t\t\t\t\t// filter bad markers\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst array = groups.get(resource);\n\t\t\t\tif (!array) {\n\t\t\t\t\tgroups.set(resource, [marker]);\n\t\t\t\t\tchanges.push(resource);\n\t\t\t\t} else {\n\t\t\t\t\tarray.push(marker);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// insert all\n\t\t\tfor (const [resource, value] of groups) {\n\t\t\t\tthis._data.set(resource, owner, value);\n\t\t\t}\n\t\t}\n\n\t\tif (changes.length > 0) {\n\t\t\tthis._onMarkerChanged.fire(changes);\n\t\t}\n\t}\n\n\tread(filter: { owner?: string; resource?: URI; severities?: number; take?: number } = Object.create(null)): IMarker[] {\n\n\t\tlet { owner, resource, severities, take } = filter;\n\n\t\tif (!take || take < 0) {\n\t\t\ttake = -1;\n\t\t}\n\n\t\tif (owner && resource) {\n\t\t\t// exactly one owner AND resource\n\t\t\tconst data = this._data.get(resource, owner);\n\t\t\tif (!data) {\n\t\t\t\treturn [];\n\t\t\t} else {\n\t\t\t\tconst result: IMarker[] = [];\n\t\t\t\tfor (const marker of data) {\n\t\t\t\t\tif (MarkerService._accept(marker, severities)) {\n\t\t\t\t\t\tconst newLen = result.push(marker);\n\t\t\t\t\t\tif (take > 0 && newLen === take) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t} else if (!owner && !resource) {\n\t\t\t// all\n\t\t\tconst result: IMarker[] = [];\n\t\t\tfor (const markers of this._data.values()) {\n\t\t\t\tfor (const data of markers) {\n\t\t\t\t\tif (MarkerService._accept(data, severities)) {\n\t\t\t\t\t\tconst newLen = result.push(data);\n\t\t\t\t\t\tif (take > 0 && newLen === take) {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\n\t\t} else {\n\t\t\t// of one resource OR owner\n\t\t\tconst iterable = this._data.values(resource ?? owner!);\n\t\t\tconst result: IMarker[] = [];\n\t\t\tfor (const markers of iterable) {\n\t\t\t\tfor (const data of markers) {\n\t\t\t\t\tif (MarkerService._accept(data, severities)) {\n\t\t\t\t\t\tconst newLen = result.push(data);\n\t\t\t\t\t\tif (take > 0 && newLen === take) {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tprivate static _accept(marker: IMarker, severities?: number): boolean {\n\t\treturn severities === undefined || (severities & marker.severity) === marker.severity;\n\t}\n\n\t// --- event debounce logic\n\n\tprivate static _merge(all: (readonly URI[])[]): URI[] {\n\t\tconst set = new ResourceMap<boolean>();\n\t\tfor (const array of all) {\n\t\t\tfor (const item of array) {\n\t\t\t\tset.set(item, true);\n\t\t\t}\n\t\t}\n\t\treturn Array.from(set.keys());\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isFalsyOrEmpty, isNonEmptyArray } from '../../../base/common/arrays';\nimport { DebounceEmitter } from '../../../base/common/event';\nimport { Iterable } from '../../../base/common/iterator';\nimport { IDisposable } from '../../../base/common/lifecycle';\nimport { ResourceMap } from '../../../base/common/map';\nimport { Schemas } from '../../../base/common/network';\nimport { URI } from '../../../base/common/uri';\nimport { IMarker, IMarkerData, IMarkerService, IResourceMarker, MarkerSeverity, MarkerStatistics } from './markers';\n\nexport const unsupportedSchemas = new Set([Schemas.inMemory, Schemas.vscodeSourceControl, Schemas.walkThrough, Schemas.walkThroughSnippet]);\n\nclass DoubleResourceMap<V> {\n\n\tprivate _byResource = new ResourceMap<Map<string, V>>();\n\tprivate _byOwner = new Map<string, ResourceMap<V>>();\n\n\tset(resource: URI, owner: string, value: V) {\n\t\tlet ownerMap = this._byResource.get(resource);\n\t\tif (!ownerMap) {\n\t\t\townerMap = new Map();\n\t\t\tthis._byResource.set(resource, ownerMap);\n\t\t}\n\t\townerMap.set(owner, value);\n\n\t\tlet resourceMap = this._byOwner.get(owner);\n\t\tif (!resourceMap) {\n\t\t\tresourceMap = new ResourceMap();\n\t\t\tthis._byOwner.set(owner, resourceMap);\n\t\t}\n\t\tresourceMap.set(resource, value);\n\t}\n\n\tget(resource: URI, owner: string): V | undefined {\n\t\tconst ownerMap = this._byResource.get(resource);\n\t\treturn ownerMap?.get(owner);\n\t}\n\n\tdelete(resource: URI, owner: string): boolean {\n\t\tlet removedA = false;\n\t\tlet removedB = false;\n\t\tconst ownerMap = this._byResource.get(resource);\n\t\tif (ownerMap) {\n\t\t\tremovedA = ownerMap.delete(owner);\n\t\t}\n\t\tconst resourceMap = this._byOwner.get(owner);\n\t\tif (resourceMap) {\n\t\t\tremovedB = resourceMap.delete(resource);\n\t\t}\n\t\tif (removedA !== removedB) {\n\t\t\tthrow new Error('illegal state');\n\t\t}\n\t\treturn removedA && removedB;\n\t}\n\n\tvalues(key?: URI | string): Iterable<V> {\n\t\tif (typeof key === 'string') {\n\t\t\treturn this._byOwner.get(key)?.values() ?? Iterable.empty();\n\t\t}\n\t\tif (URI.isUri(key)) {\n\t\t\treturn this._byResource.get(key)?.values() ?? Iterable.empty();\n\t\t}\n\n\t\treturn Iterable.map(Iterable.concat(...this._byOwner.values()), map => map[1]);\n\t}\n}\n\nclass MarkerStats implements MarkerStatistics {\n\n\terrors: number = 0;\n\tinfos: number = 0;\n\twarnings: number = 0;\n\tunknowns: number = 0;\n\n\tprivate readonly _data = new ResourceMap<MarkerStatistics>();\n\tprivate readonly _service: IMarkerService;\n\tprivate readonly _subscription: IDisposable;\n\n\tconstructor(service: IMarkerService) {\n\t\tthis._service = service;\n\t\tthis._subscription = service.onMarkerChanged(this._update, this);\n\t}\n\n\tdispose(): void {\n\t\tthis._subscription.dispose();\n\t}\n\n\tprivate _update(resources: readonly URI[]): void {\n\t\tfor (const resource of resources) {\n\t\t\tconst oldStats = this._data.get(resource);\n\t\t\tif (oldStats) {\n\t\t\t\tthis._substract(oldStats);\n\t\t\t}\n\t\t\tconst newStats = this._resourceStats(resource);\n\t\t\tthis._add(newStats);\n\t\t\tthis._data.set(resource, newStats);\n\t\t}\n\t}\n\n\tprivate _resourceStats(resource: URI): MarkerStatistics {\n\t\tconst result: MarkerStatistics = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };\n\n\t\t// TODO this is a hack\n\t\tif (unsupportedSchemas.has(resource.scheme)) {\n\t\t\treturn result;\n\t\t}\n\n\t\tfor (const { severity } of this._service.read({ resource })) {\n\t\t\tif (severity === MarkerSeverity.Error) {\n\t\t\t\tresult.errors += 1;\n\t\t\t} else if (severity === MarkerSeverity.Warning) {\n\t\t\t\tresult.warnings += 1;\n\t\t\t} else if (severity === MarkerSeverity.Info) {\n\t\t\t\tresult.infos += 1;\n\t\t\t} else {\n\t\t\t\tresult.unknowns += 1;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate _substract(op: MarkerStatistics) {\n\t\tthis.errors -= op.errors;\n\t\tthis.warnings -= op.warnings;\n\t\tthis.infos -= op.infos;\n\t\tthis.unknowns -= op.unknowns;\n\t}\n\n\tprivate _add(op: MarkerStatistics) {\n\t\tthis.errors += op.errors;\n\t\tthis.warnings += op.warnings;\n\t\tthis.infos += op.infos;\n\t\tthis.unknowns += op.unknowns;\n\t}\n}\n\nexport class MarkerService implements IMarkerService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _onMarkerChanged = new DebounceEmitter<readonly URI[]>({\n\t\tdelay: 0,\n\t\tmerge: MarkerService._merge\n\t});\n\n\treadonly onMarkerChanged = this._onMarkerChanged.event;\n\n\tprivate readonly _data = new DoubleResourceMap<IMarker[]>();\n\tprivate readonly _stats = new MarkerStats(this);\n\n\tdispose(): void {\n\t\tthis._stats.dispose();\n\t\tthis._onMarkerChanged.dispose();\n\t}\n\n\tgetStatistics(): MarkerStatistics {\n\t\treturn this._stats;\n\t}\n\n\tremove(owner: string, resources: URI[]): void {\n\t\tfor (const resource of resources || []) {\n\t\t\tthis.changeOne(owner, resource, []);\n\t\t}\n\t}\n\n\tchangeOne(owner: string, resource: URI, markerData: IMarkerData[]): void {\n\n\t\tif (isFalsyOrEmpty(markerData)) {\n\t\t\t// remove marker for this (owner,resource)-tuple\n\t\t\tconst removed = this._data.delete(resource, owner);\n\t\t\tif (removed) {\n\t\t\t\tthis._onMarkerChanged.fire([resource]);\n\t\t\t}\n\n\t\t} else {\n\t\t\t// insert marker for this (owner,resource)-tuple\n\t\t\tconst markers: IMarker[] = [];\n\t\t\tfor (const data of markerData) {\n\t\t\t\tconst marker = MarkerService._toMarker(owner, resource, data);\n\t\t\t\tif (marker) {\n\t\t\t\t\tmarkers.push(marker);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._data.set(resource, owner, markers);\n\t\t\tthis._onMarkerChanged.fire([resource]);\n\t\t}\n\t}\n\n\tprivate static _toMarker(owner: string, resource: URI, data: IMarkerData): IMarker | undefined {\n\t\tlet {\n\t\t\tcode, severity,\n\t\t\tmessage, source,\n\t\t\tstartLineNumber, startColumn, endLineNumber, endColumn,\n\t\t\trelatedInformation,\n\t\t\ttags,\n\t\t} = data;\n\n\t\tif (!message) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// santize data\n\t\tstartLineNumber = startLineNumber > 0 ? startLineNumber : 1;\n\t\tstartColumn = startColumn > 0 ? startColumn : 1;\n\t\tendLineNumber = endLineNumber >= startLineNumber ? endLineNumber : startLineNumber;\n\t\tendColumn = endColumn > 0 ? endColumn : startColumn;\n\n\t\treturn {\n\t\t\tresource,\n\t\t\towner,\n\t\t\tcode,\n\t\t\tseverity,\n\t\t\tmessage,\n\t\t\tsource,\n\t\t\tstartLineNumber,\n\t\t\tstartColumn,\n\t\t\tendLineNumber,\n\t\t\tendColumn,\n\t\t\trelatedInformation,\n\t\t\ttags,\n\t\t};\n\t}\n\n\tchangeAll(owner: string, data: IResourceMarker[]): void {\n\t\tconst changes: URI[] = [];\n\n\t\t// remove old marker\n\t\tconst existing = this._data.values(owner);\n\t\tif (existing) {\n\t\t\tfor (const data of existing) {\n\t\t\t\tconst first = Iterable.first(data);\n\t\t\t\tif (first) {\n\t\t\t\t\tchanges.push(first.resource);\n\t\t\t\t\tthis._data.delete(first.resource, owner);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// add new markers\n\t\tif (isNonEmptyArray(data)) {\n\n\t\t\t// group by resource\n\t\t\tconst groups = new ResourceMap<IMarker[]>();\n\t\t\tfor (const { resource, marker: markerData } of data) {\n\t\t\t\tconst marker = MarkerService._toMarker(owner, resource, markerData);\n\t\t\t\tif (!marker) {\n\t\t\t\t\t// filter bad markers\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst array = groups.get(resource);\n\t\t\t\tif (!array) {\n\t\t\t\t\tgroups.set(resource, [marker]);\n\t\t\t\t\tchanges.push(resource);\n\t\t\t\t} else {\n\t\t\t\t\tarray.push(marker);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// insert all\n\t\t\tfor (const [resource, value] of groups) {\n\t\t\t\tthis._data.set(resource, owner, value);\n\t\t\t}\n\t\t}\n\n\t\tif (changes.length > 0) {\n\t\t\tthis._onMarkerChanged.fire(changes);\n\t\t}\n\t}\n\n\tread(filter: { owner?: string; resource?: URI; severities?: number; take?: number } = Object.create(null)): IMarker[] {\n\n\t\tlet { owner, resource, severities, take } = filter;\n\n\t\tif (!take || take < 0) {\n\t\t\ttake = -1;\n\t\t}\n\n\t\tif (owner && resource) {\n\t\t\t// exactly one owner AND resource\n\t\t\tconst data = this._data.get(resource, owner);\n\t\t\tif (!data) {\n\t\t\t\treturn [];\n\t\t\t} else {\n\t\t\t\tconst result: IMarker[] = [];\n\t\t\t\tfor (const marker of data) {\n\t\t\t\t\tif (MarkerService._accept(marker, severities)) {\n\t\t\t\t\t\tconst newLen = result.push(marker);\n\t\t\t\t\t\tif (take > 0 && newLen === take) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t} else if (!owner && !resource) {\n\t\t\t// all\n\t\t\tconst result: IMarker[] = [];\n\t\t\tfor (const markers of this._data.values()) {\n\t\t\t\tfor (const data of markers) {\n\t\t\t\t\tif (MarkerService._accept(data, severities)) {\n\t\t\t\t\t\tconst newLen = result.push(data);\n\t\t\t\t\t\tif (take > 0 && newLen === take) {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\n\t\t} else {\n\t\t\t// of one resource OR owner\n\t\t\tconst iterable = this._data.values(resource ?? owner!);\n\t\t\tconst result: IMarker[] = [];\n\t\t\tfor (const markers of iterable) {\n\t\t\t\tfor (const data of markers) {\n\t\t\t\t\tif (MarkerService._accept(data, severities)) {\n\t\t\t\t\t\tconst newLen = result.push(data);\n\t\t\t\t\t\tif (take > 0 && newLen === take) {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tprivate static _accept(marker: IMarker, severities?: number): boolean {\n\t\treturn severities === undefined || (severities & marker.severity) === marker.severity;\n\t}\n\n\t// --- event debounce logic\n\n\tprivate static _merge(all: (readonly URI[])[]): URI[] {\n\t\tconst set = new ResourceMap<boolean>();\n\t\tfor (const array of all) {\n\t\t\tfor (const item of array) {\n\t\t\t\tset.set(item, true);\n\t\t\t}\n\t\t}\n\t\treturn Array.from(set.keys());\n\t}\n}\n"]}