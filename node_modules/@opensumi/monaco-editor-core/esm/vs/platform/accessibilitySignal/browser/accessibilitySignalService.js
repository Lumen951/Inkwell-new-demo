"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccessibilitySignal = exports.AccessibilityAlertSettingId = exports.SoundSource = exports.Sound = exports.AccessibilitySignalService = exports.IAccessibilitySignalService = void 0;
const lifecycle_1 = require("../../../base/common/lifecycle");
const network_1 = require("../../../base/common/network");
const accessibility_1 = require("../../accessibility/common/accessibility");
const configuration_1 = require("../../configuration/common/configuration");
const instantiation_1 = require("../../instantiation/common/instantiation");
const event_1 = require("../../../base/common/event");
const nls_1 = require("../../../nls");
const observable_1 = require("../../../base/common/observable");
const telemetry_1 = require("../../telemetry/common/telemetry");
exports.IAccessibilitySignalService = (0, instantiation_1.createDecorator)('accessibilitySignalService');
let AccessibilitySignalService = class AccessibilitySignalService extends lifecycle_1.Disposable {
    constructor(configurationService, accessibilityService, telemetryService) {
        super();
        this.configurationService = configurationService;
        this.accessibilityService = accessibilityService;
        this.telemetryService = telemetryService;
        this.sounds = new Map();
        this.screenReaderAttached = (0, observable_1.observableFromEvent)(this.accessibilityService.onDidChangeScreenReaderOptimized, () => /** @description accessibilityService.onDidChangeScreenReaderOptimized */ this.accessibilityService.isScreenReaderOptimized());
        this.sentTelemetry = new Set();
        this.playingSounds = new Set();
        this.obsoleteAccessibilitySignalsEnabled = (0, observable_1.observableFromEvent)(event_1.Event.filter(this.configurationService.onDidChangeConfiguration, (e) => e.affectsConfiguration('accessibilitySignals.enabled')), () => /** @description config: accessibilitySignals.enabled */ this.configurationService.getValue('accessibilitySignals.enabled'));
        this.isSoundEnabledCache = new Cache((event) => {
            const settingObservable = (0, observable_1.observableFromEvent)(event_1.Event.filter(this.configurationService.onDidChangeConfiguration, (e) => e.affectsConfiguration(event.signal.legacySoundSettingsKey) || e.affectsConfiguration(event.signal.settingsKey)), () => this.configurationService.getValue(event.signal.settingsKey + '.sound'));
            return (0, observable_1.derived)(reader => {
                /** @description sound enabled */
                const setting = settingObservable.read(reader);
                if (setting === 'on' ||
                    (setting === 'auto' && this.screenReaderAttached.read(reader))) {
                    return true;
                }
                else if (setting === 'always' || setting === 'userGesture' && event.userGesture) {
                    return true;
                }
                const obsoleteSetting = this.obsoleteAccessibilitySignalsEnabled.read(reader);
                if (obsoleteSetting === 'on' ||
                    (obsoleteSetting === 'auto' && this.screenReaderAttached.read(reader))) {
                    return true;
                }
                return false;
            });
        }, JSON.stringify);
        this.isAnnouncementEnabledCache = new Cache((event) => {
            const settingObservable = (0, observable_1.observableFromEvent)(event_1.Event.filter(this.configurationService.onDidChangeConfiguration, (e) => e.affectsConfiguration(event.signal.legacyAnnouncementSettingsKey) || e.affectsConfiguration(event.signal.settingsKey)), () => event.signal.announcementMessage ? this.configurationService.getValue(event.signal.settingsKey + '.announcement') : false);
            return (0, observable_1.derived)(reader => {
                /** @description alert enabled */
                const setting = settingObservable.read(reader);
                if (!this.screenReaderAttached.read(reader)) {
                    return false;
                }
                return setting === 'auto' || setting === 'always' || setting === 'userGesture' && event.userGesture;
            });
        }, JSON.stringify);
    }
    async playSignal(signal, options = {}) {
        const alertMessage = signal.announcementMessage;
        if (this.isAnnouncementEnabled(signal, options.userGesture) && alertMessage) {
            this.accessibilityService.status(alertMessage);
        }
        if (this.isSoundEnabled(signal, options.userGesture)) {
            this.sendSignalTelemetry(signal, options.source);
            await this.playSound(signal.sound.getSound(), options.allowManyInParallel);
        }
    }
    async playAccessibilitySignals(cues) {
        for (const cue of cues) {
            this.sendSignalTelemetry('cue' in cue ? cue.cue : cue, 'source' in cue ? cue.source : undefined);
        }
        const cueArray = cues.map(c => 'cue' in c ? c.cue : c);
        const alerts = cueArray.filter(cue => this.isAnnouncementEnabled(cue)).map(c => c.announcementMessage);
        if (alerts.length) {
            this.accessibilityService.status(alerts.join(', '));
        }
        // Some sounds are reused. Don't play the same sound twice.
        const sounds = new Set(cueArray.filter(cue => this.isSoundEnabled(cue)).map(cue => cue.sound.getSound()));
        await Promise.all(Array.from(sounds).map(sound => this.playSound(sound, true)));
    }
    sendSignalTelemetry(cue, source) {
        const isScreenReaderOptimized = this.accessibilityService.isScreenReaderOptimized();
        const key = cue.name + (source ? `::${source}` : '') + (isScreenReaderOptimized ? '{screenReaderOptimized}' : '');
        // Only send once per user session
        if (this.sentTelemetry.has(key) || this.getVolumeInPercent() === 0) {
            return;
        }
        this.sentTelemetry.add(key);
        this.telemetryService.publicLog2('signal.played', {
            signal: cue.name,
            source: source !== null && source !== void 0 ? source : '',
            isScreenReaderOptimized,
        });
    }
    getVolumeInPercent() {
        const volume = this.configurationService.getValue('accessibilitySignals.volume');
        if (typeof volume !== 'number') {
            return 50;
        }
        return Math.max(Math.min(volume, 100), 0);
    }
    async playSound(sound, allowManyInParallel = false) {
        if (!allowManyInParallel && this.playingSounds.has(sound)) {
            return;
        }
        this.playingSounds.add(sound);
        const url = network_1.FileAccess.asBrowserUri(`vs/platform/accessibilitySignal/browser/media/${sound.fileName}`).toString(true);
        try {
            const sound = this.sounds.get(url);
            if (sound) {
                sound.volume = this.getVolumeInPercent() / 100;
                sound.currentTime = 0;
                await sound.play();
            }
            else {
                const playedSound = await playAudio(url, this.getVolumeInPercent() / 100);
                this.sounds.set(url, playedSound);
            }
        }
        catch (e) {
            if (!e.message.includes('play() can only be initiated by a user gesture')) {
                // tracking this issue in #178642, no need to spam the console
                console.error('Error while playing sound', e);
            }
        }
        finally {
            this.playingSounds.delete(sound);
        }
    }
    playSignalLoop(signal, milliseconds) {
        let playing = true;
        const playSound = () => {
            if (playing) {
                this.playSignal(signal, { allowManyInParallel: true }).finally(() => {
                    setTimeout(() => {
                        if (playing) {
                            playSound();
                        }
                    }, milliseconds);
                });
            }
        };
        playSound();
        return (0, lifecycle_1.toDisposable)(() => playing = false);
    }
    isAnnouncementEnabled(signal, userGesture) {
        var _a;
        if (!signal.announcementMessage) {
            return false;
        }
        return (_a = this.isAnnouncementEnabledCache.get({ signal, userGesture }).get()) !== null && _a !== void 0 ? _a : false;
    }
    isSoundEnabled(signal, userGesture) {
        var _a;
        return (_a = this.isSoundEnabledCache.get({ signal, userGesture }).get()) !== null && _a !== void 0 ? _a : false;
    }
    onSoundEnabledChanged(signal) {
        return event_1.Event.fromObservableLight(this.isSoundEnabledCache.get({ signal }));
    }
    onAnnouncementEnabledChanged(cue) {
        return event_1.Event.fromObservableLight(this.isAnnouncementEnabledCache.get({ signal: cue }));
    }
};
exports.AccessibilitySignalService = AccessibilitySignalService;
exports.AccessibilitySignalService = AccessibilitySignalService = __decorate([
    __param(0, configuration_1.IConfigurationService),
    __param(1, accessibility_1.IAccessibilityService),
    __param(2, telemetry_1.ITelemetryService)
], AccessibilitySignalService);
/**
 * Play the given audio url.
 * @volume value between 0 and 1
 */
function playAudio(url, volume) {
    return new Promise((resolve, reject) => {
        const audio = new Audio(url);
        audio.volume = volume;
        audio.addEventListener('ended', () => {
            resolve(audio);
        });
        audio.addEventListener('error', (e) => {
            // When the error event fires, ended might not be called
            reject(e.error);
        });
        audio.play().catch(e => {
            // When play fails, the error event is not fired.
            reject(e);
        });
    });
}
class Cache {
    constructor(getValue, getKey) {
        this.getValue = getValue;
        this.getKey = getKey;
        this.map = new Map();
    }
    get(arg) {
        if (this.map.has(arg)) {
            return this.map.get(arg);
        }
        const value = this.getValue(arg);
        const key = this.getKey(arg);
        this.map.set(key, value);
        return value;
    }
}
/**
 * Corresponds to the audio files in ./media.
*/
class Sound {
    static register(options) {
        const sound = new Sound(options.fileName);
        return sound;
    }
    constructor(fileName) {
        this.fileName = fileName;
    }
}
exports.Sound = Sound;
Sound.error = Sound.register({ fileName: 'error.mp3' });
Sound.warning = Sound.register({ fileName: 'warning.mp3' });
Sound.foldedArea = Sound.register({ fileName: 'foldedAreas.mp3' });
Sound.break = Sound.register({ fileName: 'break.mp3' });
Sound.quickFixes = Sound.register({ fileName: 'quickFixes.mp3' });
Sound.taskCompleted = Sound.register({ fileName: 'taskCompleted.mp3' });
Sound.taskFailed = Sound.register({ fileName: 'taskFailed.mp3' });
Sound.terminalBell = Sound.register({ fileName: 'terminalBell.mp3' });
Sound.diffLineInserted = Sound.register({ fileName: 'diffLineInserted.mp3' });
Sound.diffLineDeleted = Sound.register({ fileName: 'diffLineDeleted.mp3' });
Sound.diffLineModified = Sound.register({ fileName: 'diffLineModified.mp3' });
Sound.chatRequestSent = Sound.register({ fileName: 'chatRequestSent.mp3' });
Sound.chatResponsePending = Sound.register({ fileName: 'chatResponsePending.mp3' });
Sound.chatResponseReceived1 = Sound.register({ fileName: 'chatResponseReceived1.mp3' });
Sound.chatResponseReceived2 = Sound.register({ fileName: 'chatResponseReceived2.mp3' });
Sound.chatResponseReceived3 = Sound.register({ fileName: 'chatResponseReceived3.mp3' });
Sound.chatResponseReceived4 = Sound.register({ fileName: 'chatResponseReceived4.mp3' });
Sound.clear = Sound.register({ fileName: 'clear.mp3' });
Sound.save = Sound.register({ fileName: 'save.mp3' });
Sound.format = Sound.register({ fileName: 'format.mp3' });
class SoundSource {
    constructor(randomOneOf) {
        this.randomOneOf = randomOneOf;
    }
    getSound(deterministic = false) {
        if (deterministic || this.randomOneOf.length === 1) {
            return this.randomOneOf[0];
        }
        else {
            const index = Math.floor(Math.random() * this.randomOneOf.length);
            return this.randomOneOf[index];
        }
    }
}
exports.SoundSource = SoundSource;
var AccessibilityAlertSettingId;
(function (AccessibilityAlertSettingId) {
    AccessibilityAlertSettingId["Save"] = "accessibility.alert.save";
    AccessibilityAlertSettingId["Format"] = "accessibility.alert.format";
    AccessibilityAlertSettingId["Clear"] = "accessibility.alert.clear";
    AccessibilityAlertSettingId["Breakpoint"] = "accessibility.alert.breakpoint";
    AccessibilityAlertSettingId["Error"] = "accessibility.alert.error";
    AccessibilityAlertSettingId["Warning"] = "accessibility.alert.warning";
    AccessibilityAlertSettingId["FoldedArea"] = "accessibility.alert.foldedArea";
    AccessibilityAlertSettingId["TerminalQuickFix"] = "accessibility.alert.terminalQuickFix";
    AccessibilityAlertSettingId["TerminalBell"] = "accessibility.alert.terminalBell";
    AccessibilityAlertSettingId["TerminalCommandFailed"] = "accessibility.alert.terminalCommandFailed";
    AccessibilityAlertSettingId["TaskCompleted"] = "accessibility.alert.taskCompleted";
    AccessibilityAlertSettingId["TaskFailed"] = "accessibility.alert.taskFailed";
    AccessibilityAlertSettingId["ChatRequestSent"] = "accessibility.alert.chatRequestSent";
    AccessibilityAlertSettingId["NotebookCellCompleted"] = "accessibility.alert.notebookCellCompleted";
    AccessibilityAlertSettingId["NotebookCellFailed"] = "accessibility.alert.notebookCellFailed";
    AccessibilityAlertSettingId["OnDebugBreak"] = "accessibility.alert.onDebugBreak";
    AccessibilityAlertSettingId["NoInlayHints"] = "accessibility.alert.noInlayHints";
    AccessibilityAlertSettingId["LineHasBreakpoint"] = "accessibility.alert.lineHasBreakpoint";
    AccessibilityAlertSettingId["ChatResponsePending"] = "accessibility.alert.chatResponsePending";
})(AccessibilityAlertSettingId || (exports.AccessibilityAlertSettingId = AccessibilityAlertSettingId = {}));
class AccessibilitySignal {
    static register(options) {
        const soundSource = new SoundSource('randomOneOf' in options.sound ? options.sound.randomOneOf : [options.sound]);
        const signal = new AccessibilitySignal(soundSource, options.name, options.legacySoundSettingsKey, options.settingsKey, options.legacyAnnouncementSettingsKey, options.announcementMessage);
        AccessibilitySignal._signals.add(signal);
        return signal;
    }
    static get allAccessibilitySignals() {
        return [...this._signals];
    }
    constructor(sound, name, legacySoundSettingsKey, settingsKey, legacyAnnouncementSettingsKey, announcementMessage) {
        this.sound = sound;
        this.name = name;
        this.legacySoundSettingsKey = legacySoundSettingsKey;
        this.settingsKey = settingsKey;
        this.legacyAnnouncementSettingsKey = legacyAnnouncementSettingsKey;
        this.announcementMessage = announcementMessage;
    }
}
exports.AccessibilitySignal = AccessibilitySignal;
AccessibilitySignal._signals = new Set();
AccessibilitySignal.error = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",0, 'Error on Line'),
    sound: Sound.error,
    legacySoundSettingsKey: 'audioCues.lineHasError',
    legacyAnnouncementSettingsKey: "accessibility.alert.error" /* AccessibilityAlertSettingId.Error */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",1, 'Error'),
    settingsKey: 'accessibility.signals.lineHasError'
});
AccessibilitySignal.warning = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",2, 'Warning on Line'),
    sound: Sound.warning,
    legacySoundSettingsKey: 'audioCues.lineHasWarning',
    legacyAnnouncementSettingsKey: "accessibility.alert.warning" /* AccessibilityAlertSettingId.Warning */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",3, 'Warning'),
    settingsKey: 'accessibility.signals.lineHasWarning'
});
AccessibilitySignal.foldedArea = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",4, 'Folded Area on Line'),
    sound: Sound.foldedArea,
    legacySoundSettingsKey: 'audioCues.lineHasFoldedArea',
    legacyAnnouncementSettingsKey: "accessibility.alert.foldedArea" /* AccessibilityAlertSettingId.FoldedArea */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",5, 'Folded'),
    settingsKey: 'accessibility.signals.lineHasFoldedArea'
});
AccessibilitySignal.break = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",6, 'Breakpoint on Line'),
    sound: Sound.break,
    legacySoundSettingsKey: 'audioCues.lineHasBreakpoint',
    legacyAnnouncementSettingsKey: "accessibility.alert.breakpoint" /* AccessibilityAlertSettingId.Breakpoint */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",7, 'Breakpoint'),
    settingsKey: 'accessibility.signals.lineHasBreakpoint'
});
AccessibilitySignal.inlineSuggestion = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",8, 'Inline Suggestion on Line'),
    sound: Sound.quickFixes,
    legacySoundSettingsKey: 'audioCues.lineHasInlineSuggestion',
    settingsKey: 'accessibility.signals.lineHasInlineSuggestion'
});
AccessibilitySignal.terminalQuickFix = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",9, 'Terminal Quick Fix'),
    sound: Sound.quickFixes,
    legacySoundSettingsKey: 'audioCues.terminalQuickFix',
    legacyAnnouncementSettingsKey: "accessibility.alert.terminalQuickFix" /* AccessibilityAlertSettingId.TerminalQuickFix */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",10, 'Quick Fix'),
    settingsKey: 'accessibility.signals.terminalQuickFix'
});
AccessibilitySignal.onDebugBreak = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",11, 'Debugger Stopped on Breakpoint'),
    sound: Sound.break,
    legacySoundSettingsKey: 'audioCues.onDebugBreak',
    legacyAnnouncementSettingsKey: "accessibility.alert.onDebugBreak" /* AccessibilityAlertSettingId.OnDebugBreak */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",12, 'Breakpoint'),
    settingsKey: 'accessibility.signals.onDebugBreak'
});
AccessibilitySignal.noInlayHints = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",13, 'No Inlay Hints on Line'),
    sound: Sound.error,
    legacySoundSettingsKey: 'audioCues.noInlayHints',
    legacyAnnouncementSettingsKey: "accessibility.alert.noInlayHints" /* AccessibilityAlertSettingId.NoInlayHints */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",14, 'No Inlay Hints'),
    settingsKey: 'accessibility.signals.noInlayHints'
});
AccessibilitySignal.taskCompleted = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",15, 'Task Completed'),
    sound: Sound.taskCompleted,
    legacySoundSettingsKey: 'audioCues.taskCompleted',
    legacyAnnouncementSettingsKey: "accessibility.alert.taskCompleted" /* AccessibilityAlertSettingId.TaskCompleted */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",16, 'Task Completed'),
    settingsKey: 'accessibility.signals.taskCompleted'
});
AccessibilitySignal.taskFailed = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",17, 'Task Failed'),
    sound: Sound.taskFailed,
    legacySoundSettingsKey: 'audioCues.taskFailed',
    legacyAnnouncementSettingsKey: "accessibility.alert.taskFailed" /* AccessibilityAlertSettingId.TaskFailed */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",18, 'Task Failed'),
    settingsKey: 'accessibility.signals.taskFailed'
});
AccessibilitySignal.terminalCommandFailed = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",19, 'Terminal Command Failed'),
    sound: Sound.error,
    legacySoundSettingsKey: 'audioCues.terminalCommandFailed',
    legacyAnnouncementSettingsKey: "accessibility.alert.terminalCommandFailed" /* AccessibilityAlertSettingId.TerminalCommandFailed */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",20, 'Command Failed'),
    settingsKey: 'accessibility.signals.terminalCommandFailed'
});
AccessibilitySignal.terminalBell = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",21, 'Terminal Bell'),
    sound: Sound.terminalBell,
    legacySoundSettingsKey: 'audioCues.terminalBell',
    legacyAnnouncementSettingsKey: "accessibility.alert.terminalBell" /* AccessibilityAlertSettingId.TerminalBell */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",22, 'Terminal Bell'),
    settingsKey: 'accessibility.signals.terminalBell'
});
AccessibilitySignal.notebookCellCompleted = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",23, 'Notebook Cell Completed'),
    sound: Sound.taskCompleted,
    legacySoundSettingsKey: 'audioCues.notebookCellCompleted',
    legacyAnnouncementSettingsKey: "accessibility.alert.notebookCellCompleted" /* AccessibilityAlertSettingId.NotebookCellCompleted */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",24, 'Notebook Cell Completed'),
    settingsKey: 'accessibility.signals.notebookCellCompleted'
});
AccessibilitySignal.notebookCellFailed = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",25, 'Notebook Cell Failed'),
    sound: Sound.taskFailed,
    legacySoundSettingsKey: 'audioCues.notebookCellFailed',
    legacyAnnouncementSettingsKey: "accessibility.alert.notebookCellFailed" /* AccessibilityAlertSettingId.NotebookCellFailed */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",26, 'Notebook Cell Failed'),
    settingsKey: 'accessibility.signals.notebookCellFailed'
});
AccessibilitySignal.diffLineInserted = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",27, 'Diff Line Inserted'),
    sound: Sound.diffLineInserted,
    legacySoundSettingsKey: 'audioCues.diffLineInserted',
    settingsKey: 'accessibility.signals.diffLineInserted'
});
AccessibilitySignal.diffLineDeleted = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",28, 'Diff Line Deleted'),
    sound: Sound.diffLineDeleted,
    legacySoundSettingsKey: 'audioCues.diffLineDeleted',
    settingsKey: 'accessibility.signals.diffLineDeleted'
});
AccessibilitySignal.diffLineModified = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",29, 'Diff Line Modified'),
    sound: Sound.diffLineModified,
    legacySoundSettingsKey: 'audioCues.diffLineModified',
    settingsKey: 'accessibility.signals.diffLineModified'
});
AccessibilitySignal.chatRequestSent = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",30, 'Chat Request Sent'),
    sound: Sound.chatRequestSent,
    legacySoundSettingsKey: 'audioCues.chatRequestSent',
    legacyAnnouncementSettingsKey: "accessibility.alert.chatRequestSent" /* AccessibilityAlertSettingId.ChatRequestSent */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",31, 'Chat Request Sent'),
    settingsKey: 'accessibility.signals.chatRequestSent'
});
AccessibilitySignal.chatResponseReceived = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",32, 'Chat Response Received'),
    legacySoundSettingsKey: 'audioCues.chatResponseReceived',
    sound: {
        randomOneOf: [
            Sound.chatResponseReceived1,
            Sound.chatResponseReceived2,
            Sound.chatResponseReceived3,
            Sound.chatResponseReceived4
        ]
    },
    settingsKey: 'accessibility.signals.chatResponseReceived'
});
AccessibilitySignal.chatResponsePending = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",33, 'Chat Response Pending'),
    sound: Sound.chatResponsePending,
    legacySoundSettingsKey: 'audioCues.chatResponsePending',
    legacyAnnouncementSettingsKey: "accessibility.alert.chatResponsePending" /* AccessibilityAlertSettingId.ChatResponsePending */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",34, 'Chat Response Pending'),
    settingsKey: 'accessibility.signals.chatResponsePending'
});
AccessibilitySignal.clear = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",35, 'Clear'),
    sound: Sound.clear,
    legacySoundSettingsKey: 'audioCues.clear',
    legacyAnnouncementSettingsKey: "accessibility.alert.clear" /* AccessibilityAlertSettingId.Clear */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",36, 'Clear'),
    settingsKey: 'accessibility.signals.clear'
});
AccessibilitySignal.save = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",37, 'Save'),
    sound: Sound.save,
    legacySoundSettingsKey: 'audioCues.save',
    legacyAnnouncementSettingsKey: "accessibility.alert.save" /* AccessibilityAlertSettingId.Save */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",38, 'Save'),
    settingsKey: 'accessibility.signals.save'
});
AccessibilitySignal.format = AccessibilitySignal.register({
    name: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",39, 'Format'),
    sound: Sound.format,
    legacySoundSettingsKey: 'audioCues.format',
    legacyAnnouncementSettingsKey: "accessibility.alert.format" /* AccessibilityAlertSettingId.Format */,
    announcementMessage: (0, nls_1.localize)("vs/platform/accessibilitySignal/browser/accessibilitySignalService",40, 'Format'),
    settingsKey: 'accessibility.signals.format'
});
//# sourceMappingURL=accessibilitySignalService.js.map