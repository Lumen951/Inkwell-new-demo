"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MenuWorkbenchToolBar = exports.WorkbenchToolBar = exports.HiddenItemStrategy = void 0;
const dom_1 = require("../../../base/browser/dom");
const mouseEvent_1 = require("../../../base/browser/mouseEvent");
const toolbar_1 = require("../../../base/browser/ui/toolbar/toolbar");
const actions_1 = require("../../../base/common/actions");
const arrays_1 = require("../../../base/common/arrays");
const collections_1 = require("../../../base/common/collections");
const errors_1 = require("../../../base/common/errors");
const event_1 = require("../../../base/common/event");
const iterator_1 = require("../../../base/common/iterator");
const lifecycle_1 = require("../../../base/common/lifecycle");
const nls_1 = require("../../../nls");
const menuEntryActionViewItem_1 = require("./menuEntryActionViewItem");
const actions_2 = require("../common/actions");
const contextkey_1 = require("../../contextkey/common/contextkey");
const contextView_1 = require("../../contextview/browser/contextView");
const keybinding_1 = require("../../keybinding/common/keybinding");
const telemetry_1 = require("../../telemetry/common/telemetry");
var HiddenItemStrategy;
(function (HiddenItemStrategy) {
    /** This toolbar doesn't support hiding*/
    HiddenItemStrategy[HiddenItemStrategy["NoHide"] = -1] = "NoHide";
    /** Hidden items aren't shown anywhere */
    HiddenItemStrategy[HiddenItemStrategy["Ignore"] = 0] = "Ignore";
    /** Hidden items move into the secondary group */
    HiddenItemStrategy[HiddenItemStrategy["RenderInSecondaryGroup"] = 1] = "RenderInSecondaryGroup";
})(HiddenItemStrategy || (exports.HiddenItemStrategy = HiddenItemStrategy = {}));
/**
 * The `WorkbenchToolBar` does
 * - support hiding of menu items
 * - lookup keybindings for each actions automatically
 * - send `workbenchActionExecuted`-events for each action
 *
 * See {@link MenuWorkbenchToolBar} for a toolbar that is backed by a menu.
 */
let WorkbenchToolBar = class WorkbenchToolBar extends toolbar_1.ToolBar {
    constructor(container, _options, _menuService, _contextKeyService, _contextMenuService, keybindingService, telemetryService) {
        super(container, _contextMenuService, {
            // defaults
            getKeyBinding: (action) => { var _a; return (_a = keybindingService.lookupKeybinding(action.id)) !== null && _a !== void 0 ? _a : undefined; },
            // options (override defaults)
            ..._options,
            // mandatory (overide options)
            allowContextMenu: true,
            skipTelemetry: typeof (_options === null || _options === void 0 ? void 0 : _options.telemetrySource) === 'string',
        });
        this._options = _options;
        this._menuService = _menuService;
        this._contextKeyService = _contextKeyService;
        this._contextMenuService = _contextMenuService;
        this._sessionDisposables = this._store.add(new lifecycle_1.DisposableStore());
        // telemetry logic
        const telemetrySource = _options === null || _options === void 0 ? void 0 : _options.telemetrySource;
        if (telemetrySource) {
            this._store.add(this.actionBar.onDidRun(e => telemetryService.publicLog2('workbenchActionExecuted', { id: e.action.id, from: telemetrySource })));
        }
    }
    setActions(_primary, _secondary = [], menuIds) {
        var _a, _b, _c;
        this._sessionDisposables.clear();
        const primary = _primary.slice(); // for hiding and overflow we set some items to undefined
        const secondary = _secondary.slice();
        const toggleActions = [];
        let toggleActionsCheckedCount = 0;
        const extraSecondary = [];
        let someAreHidden = false;
        // unless disabled, move all hidden items to secondary group or ignore them
        if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.hiddenItemStrategy) !== -1 /* HiddenItemStrategy.NoHide */) {
            for (let i = 0; i < primary.length; i++) {
                const action = primary[i];
                if (!(action instanceof actions_2.MenuItemAction) && !(action instanceof actions_2.SubmenuItemAction)) {
                    // console.warn(`Action ${action.id}/${action.label} is not a MenuItemAction`);
                    continue;
                }
                if (!action.hideActions) {
                    continue;
                }
                // collect all toggle actions
                toggleActions.push(action.hideActions.toggle);
                if (action.hideActions.toggle.checked) {
                    toggleActionsCheckedCount++;
                }
                // hidden items move into overflow or ignore
                if (action.hideActions.isHidden) {
                    someAreHidden = true;
                    primary[i] = undefined;
                    if (((_b = this._options) === null || _b === void 0 ? void 0 : _b.hiddenItemStrategy) !== 0 /* HiddenItemStrategy.Ignore */) {
                        extraSecondary[i] = action;
                    }
                }
            }
        }
        // count for max
        if (((_c = this._options) === null || _c === void 0 ? void 0 : _c.overflowBehavior) !== undefined) {
            const exemptedIds = (0, collections_1.intersection)(new Set(this._options.overflowBehavior.exempted), iterator_1.Iterable.map(primary, a => a === null || a === void 0 ? void 0 : a.id));
            const maxItems = this._options.overflowBehavior.maxItems - exemptedIds.size;
            let count = 0;
            for (let i = 0; i < primary.length; i++) {
                const action = primary[i];
                if (!action) {
                    continue;
                }
                count++;
                if (exemptedIds.has(action.id)) {
                    continue;
                }
                if (count >= maxItems) {
                    primary[i] = undefined;
                    extraSecondary[i] = action;
                }
            }
        }
        // coalesce turns Array<IAction|undefined> into IAction[]
        (0, arrays_1.coalesceInPlace)(primary);
        (0, arrays_1.coalesceInPlace)(extraSecondary);
        super.setActions(primary, actions_1.Separator.join(extraSecondary, secondary));
        // add context menu for toggle actions
        if (toggleActions.length > 0) {
            this._sessionDisposables.add((0, dom_1.addDisposableListener)(this.getElement(), 'contextmenu', e => {
                var _a, _b, _c, _d, _e;
                const event = new mouseEvent_1.StandardMouseEvent((0, dom_1.getWindow)(this.getElement()), e);
                const action = this.getItemAction(event.target);
                if (!(action)) {
                    return;
                }
                event.preventDefault();
                event.stopPropagation();
                let noHide = false;
                // last item cannot be hidden when using ignore strategy
                if (toggleActionsCheckedCount === 1 && ((_a = this._options) === null || _a === void 0 ? void 0 : _a.hiddenItemStrategy) === 0 /* HiddenItemStrategy.Ignore */) {
                    noHide = true;
                    for (let i = 0; i < toggleActions.length; i++) {
                        if (toggleActions[i].checked) {
                            toggleActions[i] = (0, actions_1.toAction)({
                                id: action.id,
                                label: action.label,
                                checked: true,
                                enabled: false,
                                run() { }
                            });
                            break; // there is only one
                        }
                    }
                }
                // add "hide foo" actions
                let hideAction;
                if (!noHide && (action instanceof actions_2.MenuItemAction || action instanceof actions_2.SubmenuItemAction)) {
                    if (!action.hideActions) {
                        // no context menu for MenuItemAction instances that support no hiding
                        // those are fake actions and need to be cleaned up
                        return;
                    }
                    hideAction = action.hideActions.hide;
                }
                else {
                    hideAction = (0, actions_1.toAction)({
                        id: 'label',
                        label: (0, nls_1.localize)("vs/platform/actions/browser/toolbar",0, "Hide"),
                        enabled: false,
                        run() { }
                    });
                }
                const actions = actions_1.Separator.join([hideAction], toggleActions);
                // add "Reset Menu" action
                if (((_b = this._options) === null || _b === void 0 ? void 0 : _b.resetMenu) && !menuIds) {
                    menuIds = [this._options.resetMenu];
                }
                if (someAreHidden && menuIds) {
                    actions.push(new actions_1.Separator());
                    actions.push((0, actions_1.toAction)({
                        id: 'resetThisMenu',
                        label: (0, nls_1.localize)("vs/platform/actions/browser/toolbar",1, "Reset Menu"),
                        run: () => this._menuService.resetHiddenStates(menuIds)
                    }));
                }
                this._contextMenuService.showContextMenu({
                    getAnchor: () => event,
                    getActions: () => actions,
                    // add context menu actions (iff appicable)
                    menuId: (_c = this._options) === null || _c === void 0 ? void 0 : _c.contextMenu,
                    menuActionOptions: { renderShortTitle: true, ...(_d = this._options) === null || _d === void 0 ? void 0 : _d.menuOptions },
                    skipTelemetry: typeof ((_e = this._options) === null || _e === void 0 ? void 0 : _e.telemetrySource) === 'string',
                    contextKeyService: this._contextKeyService,
                });
            }));
        }
    }
};
exports.WorkbenchToolBar = WorkbenchToolBar;
exports.WorkbenchToolBar = WorkbenchToolBar = __decorate([
    __param(2, actions_2.IMenuService),
    __param(3, contextkey_1.IContextKeyService),
    __param(4, contextView_1.IContextMenuService),
    __param(5, keybinding_1.IKeybindingService),
    __param(6, telemetry_1.ITelemetryService)
], WorkbenchToolBar);
/**
 * A {@link WorkbenchToolBar workbench toolbar} that is purely driven from a {@link MenuId menu}-identifier.
 *
 * *Note* that Manual updates via `setActions` are NOT supported.
 */
let MenuWorkbenchToolBar = class MenuWorkbenchToolBar extends WorkbenchToolBar {
    constructor(container, menuId, options, menuService, contextKeyService, contextMenuService, keybindingService, telemetryService) {
        super(container, { resetMenu: menuId, ...options }, menuService, contextKeyService, contextMenuService, keybindingService, telemetryService);
        this._onDidChangeMenuItems = this._store.add(new event_1.Emitter());
        this.onDidChangeMenuItems = this._onDidChangeMenuItems.event;
        // update logic
        const menu = this._store.add(menuService.createMenu(menuId, contextKeyService, { emitEventsForSubmenuChanges: true }));
        const updateToolbar = () => {
            var _a, _b, _c;
            const primary = [];
            const secondary = [];
            (0, menuEntryActionViewItem_1.createAndFillInActionBarActions)(menu, options === null || options === void 0 ? void 0 : options.menuOptions, { primary, secondary }, (_a = options === null || options === void 0 ? void 0 : options.toolbarOptions) === null || _a === void 0 ? void 0 : _a.primaryGroup, (_b = options === null || options === void 0 ? void 0 : options.toolbarOptions) === null || _b === void 0 ? void 0 : _b.shouldInlineSubmenu, (_c = options === null || options === void 0 ? void 0 : options.toolbarOptions) === null || _c === void 0 ? void 0 : _c.useSeparatorsInPrimaryActions);
            container.classList.toggle('has-no-actions', primary.length === 0 && secondary.length === 0);
            super.setActions(primary, secondary);
        };
        this._store.add(menu.onDidChange(() => {
            updateToolbar();
            this._onDidChangeMenuItems.fire(this);
        }));
        updateToolbar();
    }
    /**
     * @deprecated The WorkbenchToolBar does not support this method because it works with menus.
     */
    setActions() {
        throw new errors_1.BugIndicatingError('This toolbar is populated from a menu.');
    }
};
exports.MenuWorkbenchToolBar = MenuWorkbenchToolBar;
exports.MenuWorkbenchToolBar = MenuWorkbenchToolBar = __decorate([
    __param(3, actions_2.IMenuService),
    __param(4, contextkey_1.IContextKeyService),
    __param(5, contextView_1.IContextMenuService),
    __param(6, keybinding_1.IKeybindingService),
    __param(7, telemetry_1.ITelemetryService)
], MenuWorkbenchToolBar);
//# sourceMappingURL=toolbar.js.map