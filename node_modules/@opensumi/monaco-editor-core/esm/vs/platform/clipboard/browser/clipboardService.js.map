{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/platform/clipboard/browser/clipboardService.ts","vs/platform/clipboard/browser/clipboardService.ts"],"names":[],"mappings":"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","file":"clipboardService.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isSafari, isWebkitWebView } from '../../../base/browser/browser';\nimport { $, addDisposableListener, getActiveDocument, onDidRegisterWindow } from '../../../base/browser/dom';\nimport { mainWindow } from '../../../base/browser/window';\nimport { DeferredPromise } from '../../../base/common/async';\nimport { Event } from '../../../base/common/event';\nimport { hash } from '../../../base/common/hash';\nimport { Disposable } from '../../../base/common/lifecycle';\nimport { URI } from '../../../base/common/uri';\nimport { IClipboardService } from '../common/clipboardService';\nimport { ILayoutService } from '../../layout/browser/layoutService';\nimport { ILogService } from '../../log/common/log';\n\nexport class BrowserClipboardService extends Disposable implements IClipboardService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tconstructor(\n\t\t@ILayoutService private readonly layoutService: ILayoutService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tif (isSafari || isWebkitWebView) {\n\t\t\tthis.installWebKitWriteTextWorkaround();\n\t\t}\n\n\t\t// Keep track of copy operations to reset our set of\n\t\t// copied resources: since we keep resources in memory\n\t\t// and not in the clipboard, we have to invalidate\n\t\t// that state when the user copies other data.\n\t\tthis._register(Event.runAndSubscribe(onDidRegisterWindow, ({ window, disposables }) => {\n\t\t\tdisposables.add(addDisposableListener(window.document, 'copy', () => this.clearResources()));\n\t\t}, { window: mainWindow, disposables: this._store }));\n\t}\n\n\tprivate webKitPendingClipboardWritePromise: DeferredPromise<string> | undefined;\n\n\t// In Safari, it has the following note:\n\t//\n\t// \"The request to write to the clipboard must be triggered during a user gesture.\n\t// A call to clipboard.write or clipboard.writeText outside the scope of a user\n\t// gesture(such as \"click\" or \"touch\" event handlers) will result in the immediate\n\t// rejection of the promise returned by the API call.\"\n\t// From: https://webkit.org/blog/10855/async-clipboard-api/\n\t//\n\t// Since extensions run in a web worker, and handle gestures in an asynchronous way,\n\t// they are not classified by Safari as \"in response to a user gesture\" and will reject.\n\t//\n\t// This function sets up some handlers to work around that behavior.\n\tprivate installWebKitWriteTextWorkaround(): void {\n\t\tconst handler = () => {\n\t\t\tconst currentWritePromise = new DeferredPromise<string>();\n\n\t\t\t// Cancel the previous promise since we just created a new one in response to this new event\n\t\t\tif (this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled) {\n\t\t\t\tthis.webKitPendingClipboardWritePromise.cancel();\n\t\t\t}\n\t\t\tthis.webKitPendingClipboardWritePromise = currentWritePromise;\n\n\t\t\t// The ctor of ClipboardItem allows you to pass in a promise that will resolve to a string.\n\t\t\t// This allows us to pass in a Promise that will either be cancelled by another event or\n\t\t\t// resolved with the contents of the first call to this.writeText.\n\t\t\t// see https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem/ClipboardItem#parameters\n\t\t\tnavigator.clipboard.write([new ClipboardItem({\n\t\t\t\t'text/plain': currentWritePromise.p,\n\t\t\t})]).catch(async err => {\n\t\t\t\tif (!(err instanceof Error) || err.name !== 'NotAllowedError' || !currentWritePromise.isRejected) {\n\t\t\t\t\tthis.logService.error(err);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tthis._register(Event.runAndSubscribe(this.layoutService.onDidAddContainer, ({ container, disposables }) => {\n\t\t\tdisposables.add(addDisposableListener(container, 'click', handler));\n\t\t\tdisposables.add(addDisposableListener(container, 'keydown', handler));\n\t\t}, { container: this.layoutService.mainContainer, disposables: this._store }));\n\t}\n\n\tprivate readonly mapTextToType = new Map<string, string>(); // unsupported in web (only in-memory)\n\n\tasync writeText(text: string, type?: string): Promise<void> {\n\n\t\t// Clear resources given we are writing text\n\t\tthis.writeResources([]);\n\n\t\t// With type: only in-memory is supported\n\t\tif (type) {\n\t\t\tthis.mapTextToType.set(type, text);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.webKitPendingClipboardWritePromise) {\n\t\t\t// For Safari, we complete this Promise which allows the call to `navigator.clipboard.write()`\n\t\t\t// above to resolve and successfully copy to the clipboard. If we let this continue, Safari\n\t\t\t// would throw an error because this call stack doesn't appear to originate from a user gesture.\n\t\t\treturn this.webKitPendingClipboardWritePromise.complete(text);\n\t\t}\n\n\t\t// Guard access to navigator.clipboard with try/catch\n\t\t// as we have seen DOMExceptions in certain browsers\n\t\t// due to security policies.\n\t\ttry {\n\t\t\treturn await navigator.clipboard.writeText(text);\n\t\t} catch (error) {\n\t\t\tconsole.error(error);\n\t\t}\n\n\t\t// Fallback to textarea and execCommand solution\n\t\tthis.fallbackWriteText(text);\n\t}\n\n\tprivate fallbackWriteText(text: string): void {\n\t\tconst activeDocument = getActiveDocument();\n\t\tconst activeElement = activeDocument.activeElement;\n\n\t\tconst textArea: HTMLTextAreaElement = activeDocument.body.appendChild($('textarea', { 'aria-hidden': true }));\n\t\ttextArea.style.height = '1px';\n\t\ttextArea.style.width = '1px';\n\t\ttextArea.style.position = 'absolute';\n\n\t\ttextArea.value = text;\n\t\ttextArea.focus();\n\t\ttextArea.select();\n\n\t\tactiveDocument.execCommand('copy');\n\n\t\tif (activeElement instanceof HTMLElement) {\n\t\t\tactiveElement.focus();\n\t\t}\n\n\t\tactiveDocument.body.removeChild(textArea);\n\t}\n\n\tasync readText(type?: string): Promise<string> {\n\n\t\t// With type: only in-memory is supported\n\t\tif (type) {\n\t\t\treturn this.mapTextToType.get(type) || '';\n\t\t}\n\n\t\t// Guard access to navigator.clipboard with try/catch\n\t\t// as we have seen DOMExceptions in certain browsers\n\t\t// due to security policies.\n\t\ttry {\n\t\t\treturn await navigator.clipboard.readText();\n\t\t} catch (error) {\n\t\t\tconsole.error(error);\n\t\t}\n\n\t\treturn '';\n\t}\n\n\tprivate findText = ''; // unsupported in web (only in-memory)\n\n\tasync readFindText(): Promise<string> {\n\t\treturn this.findText;\n\t}\n\n\tasync writeFindText(text: string): Promise<void> {\n\t\tthis.findText = text;\n\t}\n\n\tprivate resources: URI[] = []; // unsupported in web (only in-memory)\n\tprivate resourcesStateHash: number | undefined = undefined;\n\n\tprivate static readonly MAX_RESOURCE_STATE_SOURCE_LENGTH = 1000;\n\n\tasync writeResources(resources: URI[]): Promise<void> {\n\t\tif (resources.length === 0) {\n\t\t\tthis.clearResources();\n\t\t} else {\n\t\t\tthis.resources = resources;\n\t\t\tthis.resourcesStateHash = await this.computeResourcesStateHash();\n\t\t}\n\t}\n\n\tasync readResources(): Promise<URI[]> {\n\t\tconst resourcesStateHash = await this.computeResourcesStateHash();\n\t\tif (this.resourcesStateHash !== resourcesStateHash) {\n\t\t\tthis.clearResources(); // state mismatch, resources no longer valid\n\t\t}\n\n\t\treturn this.resources;\n\t}\n\n\tprivate async computeResourcesStateHash(): Promise<number | undefined> {\n\t\tif (this.resources.length === 0) {\n\t\t\treturn undefined; // no resources, no hash needed\n\t\t}\n\n\t\t// Resources clipboard is managed in-memory only and thus\n\t\t// fails to invalidate when clipboard data is changing.\n\t\t// As such, we compute the hash of the current clipboard\n\t\t// and use that to later validate the resources clipboard.\n\n\t\tconst clipboardText = await this.readText();\n\t\treturn hash(clipboardText.substring(0, BrowserClipboardService.MAX_RESOURCE_STATE_SOURCE_LENGTH));\n\t}\n\n\tasync hasResources(): Promise<boolean> {\n\t\treturn this.resources.length > 0;\n\t}\n\n\tprivate clearResources(): void {\n\t\tthis.resources = [];\n\t\tthis.resourcesStateHash = undefined;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isSafari, isWebkitWebView } from '../../../base/browser/browser';\nimport { $, addDisposableListener, getActiveDocument, onDidRegisterWindow } from '../../../base/browser/dom';\nimport { mainWindow } from '../../../base/browser/window';\nimport { DeferredPromise } from '../../../base/common/async';\nimport { Event } from '../../../base/common/event';\nimport { hash } from '../../../base/common/hash';\nimport { Disposable } from '../../../base/common/lifecycle';\nimport { URI } from '../../../base/common/uri';\nimport { IClipboardService } from '../common/clipboardService';\nimport { ILayoutService } from '../../layout/browser/layoutService';\nimport { ILogService } from '../../log/common/log';\n\nexport class BrowserClipboardService extends Disposable implements IClipboardService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tconstructor(\n\t\t@ILayoutService private readonly layoutService: ILayoutService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tif (isSafari || isWebkitWebView) {\n\t\t\tthis.installWebKitWriteTextWorkaround();\n\t\t}\n\n\t\t// Keep track of copy operations to reset our set of\n\t\t// copied resources: since we keep resources in memory\n\t\t// and not in the clipboard, we have to invalidate\n\t\t// that state when the user copies other data.\n\t\tthis._register(Event.runAndSubscribe(onDidRegisterWindow, ({ window, disposables }) => {\n\t\t\tdisposables.add(addDisposableListener(window.document, 'copy', () => this.clearResources()));\n\t\t}, { window: mainWindow, disposables: this._store }));\n\t}\n\n\tprivate webKitPendingClipboardWritePromise: DeferredPromise<string> | undefined;\n\n\t// In Safari, it has the following note:\n\t//\n\t// \"The request to write to the clipboard must be triggered during a user gesture.\n\t// A call to clipboard.write or clipboard.writeText outside the scope of a user\n\t// gesture(such as \"click\" or \"touch\" event handlers) will result in the immediate\n\t// rejection of the promise returned by the API call.\"\n\t// From: https://webkit.org/blog/10855/async-clipboard-api/\n\t//\n\t// Since extensions run in a web worker, and handle gestures in an asynchronous way,\n\t// they are not classified by Safari as \"in response to a user gesture\" and will reject.\n\t//\n\t// This function sets up some handlers to work around that behavior.\n\tprivate installWebKitWriteTextWorkaround(): void {\n\t\tconst handler = () => {\n\t\t\tconst currentWritePromise = new DeferredPromise<string>();\n\n\t\t\t// Cancel the previous promise since we just created a new one in response to this new event\n\t\t\tif (this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled) {\n\t\t\t\tthis.webKitPendingClipboardWritePromise.cancel();\n\t\t\t}\n\t\t\tthis.webKitPendingClipboardWritePromise = currentWritePromise;\n\n\t\t\t// The ctor of ClipboardItem allows you to pass in a promise that will resolve to a string.\n\t\t\t// This allows us to pass in a Promise that will either be cancelled by another event or\n\t\t\t// resolved with the contents of the first call to this.writeText.\n\t\t\t// see https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem/ClipboardItem#parameters\n\t\t\tnavigator.clipboard.write([new ClipboardItem({\n\t\t\t\t'text/plain': currentWritePromise.p,\n\t\t\t})]).catch(async err => {\n\t\t\t\tif (!(err instanceof Error) || err.name !== 'NotAllowedError' || !currentWritePromise.isRejected) {\n\t\t\t\t\tthis.logService.error(err);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tthis._register(Event.runAndSubscribe(this.layoutService.onDidAddContainer, ({ container, disposables }) => {\n\t\t\tdisposables.add(addDisposableListener(container, 'click', handler));\n\t\t\tdisposables.add(addDisposableListener(container, 'keydown', handler));\n\t\t}, { container: this.layoutService.mainContainer, disposables: this._store }));\n\t}\n\n\tprivate readonly mapTextToType = new Map<string, string>(); // unsupported in web (only in-memory)\n\n\tasync writeText(text: string, type?: string): Promise<void> {\n\n\t\t// Clear resources given we are writing text\n\t\tthis.writeResources([]);\n\n\t\t// With type: only in-memory is supported\n\t\tif (type) {\n\t\t\tthis.mapTextToType.set(type, text);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.webKitPendingClipboardWritePromise) {\n\t\t\t// For Safari, we complete this Promise which allows the call to `navigator.clipboard.write()`\n\t\t\t// above to resolve and successfully copy to the clipboard. If we let this continue, Safari\n\t\t\t// would throw an error because this call stack doesn't appear to originate from a user gesture.\n\t\t\treturn this.webKitPendingClipboardWritePromise.complete(text);\n\t\t}\n\n\t\t// Guard access to navigator.clipboard with try/catch\n\t\t// as we have seen DOMExceptions in certain browsers\n\t\t// due to security policies.\n\t\ttry {\n\t\t\treturn await navigator.clipboard.writeText(text);\n\t\t} catch (error) {\n\t\t\tconsole.error(error);\n\t\t}\n\n\t\t// Fallback to textarea and execCommand solution\n\t\tthis.fallbackWriteText(text);\n\t}\n\n\tprivate fallbackWriteText(text: string): void {\n\t\tconst activeDocument = getActiveDocument();\n\t\tconst activeElement = activeDocument.activeElement;\n\n\t\tconst textArea: HTMLTextAreaElement = activeDocument.body.appendChild($('textarea', { 'aria-hidden': true }));\n\t\ttextArea.style.height = '1px';\n\t\ttextArea.style.width = '1px';\n\t\ttextArea.style.position = 'absolute';\n\n\t\ttextArea.value = text;\n\t\ttextArea.focus();\n\t\ttextArea.select();\n\n\t\tactiveDocument.execCommand('copy');\n\n\t\tif (activeElement instanceof HTMLElement) {\n\t\t\tactiveElement.focus();\n\t\t}\n\n\t\tactiveDocument.body.removeChild(textArea);\n\t}\n\n\tasync readText(type?: string): Promise<string> {\n\n\t\t// With type: only in-memory is supported\n\t\tif (type) {\n\t\t\treturn this.mapTextToType.get(type) || '';\n\t\t}\n\n\t\t// Guard access to navigator.clipboard with try/catch\n\t\t// as we have seen DOMExceptions in certain browsers\n\t\t// due to security policies.\n\t\ttry {\n\t\t\treturn await navigator.clipboard.readText();\n\t\t} catch (error) {\n\t\t\tconsole.error(error);\n\t\t}\n\n\t\treturn '';\n\t}\n\n\tprivate findText = ''; // unsupported in web (only in-memory)\n\n\tasync readFindText(): Promise<string> {\n\t\treturn this.findText;\n\t}\n\n\tasync writeFindText(text: string): Promise<void> {\n\t\tthis.findText = text;\n\t}\n\n\tprivate resources: URI[] = []; // unsupported in web (only in-memory)\n\tprivate resourcesStateHash: number | undefined = undefined;\n\n\tprivate static readonly MAX_RESOURCE_STATE_SOURCE_LENGTH = 1000;\n\n\tasync writeResources(resources: URI[]): Promise<void> {\n\t\tif (resources.length === 0) {\n\t\t\tthis.clearResources();\n\t\t} else {\n\t\t\tthis.resources = resources;\n\t\t\tthis.resourcesStateHash = await this.computeResourcesStateHash();\n\t\t}\n\t}\n\n\tasync readResources(): Promise<URI[]> {\n\t\tconst resourcesStateHash = await this.computeResourcesStateHash();\n\t\tif (this.resourcesStateHash !== resourcesStateHash) {\n\t\t\tthis.clearResources(); // state mismatch, resources no longer valid\n\t\t}\n\n\t\treturn this.resources;\n\t}\n\n\tprivate async computeResourcesStateHash(): Promise<number | undefined> {\n\t\tif (this.resources.length === 0) {\n\t\t\treturn undefined; // no resources, no hash needed\n\t\t}\n\n\t\t// Resources clipboard is managed in-memory only and thus\n\t\t// fails to invalidate when clipboard data is changing.\n\t\t// As such, we compute the hash of the current clipboard\n\t\t// and use that to later validate the resources clipboard.\n\n\t\tconst clipboardText = await this.readText();\n\t\treturn hash(clipboardText.substring(0, BrowserClipboardService.MAX_RESOURCE_STATE_SOURCE_LENGTH));\n\t}\n\n\tasync hasResources(): Promise<boolean> {\n\t\treturn this.resources.length > 0;\n\t}\n\n\tprivate clearResources(): void {\n\t\tthis.resources = [];\n\t\tthis.resourcesStateHash = undefined;\n\t}\n}\n"]}