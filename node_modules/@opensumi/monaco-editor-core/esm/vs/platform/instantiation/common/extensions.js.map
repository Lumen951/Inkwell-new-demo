{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/platform/instantiation/common/extensions.ts","vs/platform/instantiation/common/extensions.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;;AAEhG,+CAA+C;AAG/C,MAAM,SAAS,GAAoD,EAAE,CAAC;AAEtE,IAAkB,iBAYjB;AAZD,WAAkB,iBAAiB;IAClC;;;OAGG;IACH,2DAAS,CAAA;IAET;;;OAGG;IACH,+DAAW,CAAA;AACZ,CAAC,EAZiB,iBAAiB,iCAAjB,iBAAiB,QAYlC;AAID,SAAgB,iBAAiB,CAAuC,EAAwB,EAAE,gBAAyE,EAAE,4BAA0D;IACtO,IAAI,CAAC,CAAC,gBAAgB,YAAY,4BAAc,CAAC,EAAE,CAAC;QACnD,gBAAgB,GAAG,IAAI,4BAAc,CAAI,gBAA6C,EAAE,EAAE,EAAE,OAAO,CAAC,4BAA4B,CAAC,CAAC,CAAC;IACpI,CAAC;IAED,SAAS,CAAC,IAAI,CAAC,CAAC,EAAE,EAAE,gBAAgB,CAAC,CAAC,CAAC;AACxC,CAAC;AAND,8CAMC;AAED,SAAgB,8BAA8B;IAC7C,OAAO,SAAS,CAAC;AAClB,CAAC;AAFD,wEAEC","file":"extensions.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { SyncDescriptor } from './descriptors';\nimport { BrandedService, ServiceIdentifier } from './instantiation';\n\nconst _registry: [ServiceIdentifier<any>, SyncDescriptor<any>][] = [];\n\nexport const enum InstantiationType {\n\t/**\n\t * Instantiate this service as soon as a consumer depends on it. _Note_ that this\n\t * is more costly as some upfront work is done that is likely not needed\n\t */\n\tEager = 0,\n\n\t/**\n\t * Instantiate this service as soon as a consumer uses it. This is the _better_\n\t * way of registering a service.\n\t */\n\tDelayed = 1\n}\n\nexport function registerSingleton<T, Services extends BrandedService[]>(id: ServiceIdentifier<T>, ctor: new (...services: Services) => T, supportsDelayedInstantiation: InstantiationType): void;\nexport function registerSingleton<T, Services extends BrandedService[]>(id: ServiceIdentifier<T>, descriptor: SyncDescriptor<any>): void;\nexport function registerSingleton<T, Services extends BrandedService[]>(id: ServiceIdentifier<T>, ctorOrDescriptor: { new(...services: Services): T } | SyncDescriptor<any>, supportsDelayedInstantiation?: boolean | InstantiationType): void {\n\tif (!(ctorOrDescriptor instanceof SyncDescriptor)) {\n\t\tctorOrDescriptor = new SyncDescriptor<T>(ctorOrDescriptor as new (...args: any[]) => T, [], Boolean(supportsDelayedInstantiation));\n\t}\n\n\t_registry.push([id, ctorOrDescriptor]);\n}\n\nexport function getSingletonServiceDescriptors(): [ServiceIdentifier<any>, SyncDescriptor<any>][] {\n\treturn _registry;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { SyncDescriptor } from './descriptors';\nimport { BrandedService, ServiceIdentifier } from './instantiation';\n\nconst _registry: [ServiceIdentifier<any>, SyncDescriptor<any>][] = [];\n\nexport const enum InstantiationType {\n\t/**\n\t * Instantiate this service as soon as a consumer depends on it. _Note_ that this\n\t * is more costly as some upfront work is done that is likely not needed\n\t */\n\tEager = 0,\n\n\t/**\n\t * Instantiate this service as soon as a consumer uses it. This is the _better_\n\t * way of registering a service.\n\t */\n\tDelayed = 1\n}\n\nexport function registerSingleton<T, Services extends BrandedService[]>(id: ServiceIdentifier<T>, ctor: new (...services: Services) => T, supportsDelayedInstantiation: InstantiationType): void;\nexport function registerSingleton<T, Services extends BrandedService[]>(id: ServiceIdentifier<T>, descriptor: SyncDescriptor<any>): void;\nexport function registerSingleton<T, Services extends BrandedService[]>(id: ServiceIdentifier<T>, ctorOrDescriptor: { new(...services: Services): T } | SyncDescriptor<any>, supportsDelayedInstantiation?: boolean | InstantiationType): void {\n\tif (!(ctorOrDescriptor instanceof SyncDescriptor)) {\n\t\tctorOrDescriptor = new SyncDescriptor<T>(ctorOrDescriptor as new (...args: any[]) => T, [], Boolean(supportsDelayedInstantiation));\n\t}\n\n\t_registry.push([id, ctorOrDescriptor]);\n}\n\nexport function getSingletonServiceDescriptors(): [ServiceIdentifier<any>, SyncDescriptor<any>][] {\n\treturn _registry;\n}\n"]}