{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/base/common/labels.ts","vs/base/common/labels.ts"],"names":[],"mappings":"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","file":"labels.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { firstOrDefault } from './arrays';\nimport { hasDriveLetter, toSlashes } from './extpath';\nimport { posix, sep, win32 } from './path';\nimport { isMacintosh, isWindows, OperatingSystem, OS } from './platform';\nimport { extUri, extUriIgnorePathCase } from './resources';\nimport { rtrim, startsWithIgnoreCase } from './strings';\nimport { URI } from './uri';\n\nexport interface IPathLabelFormatting {\n\n\t/**\n\t * The OS the path label is from to produce a label\n\t * that matches OS expectations.\n\t */\n\treadonly os: OperatingSystem;\n\n\t/**\n\t * Whether to add a `~` when the path is in the\n\t * user home directory.\n\t *\n\t * Note: this only applies to Linux, macOS but not\n\t * Windows.\n\t */\n\treadonly tildify?: IUserHomeProvider;\n\n\t/**\n\t * Whether to convert to a relative path if the path\n\t * is within any of the opened workspace folders.\n\t */\n\treadonly relative?: IRelativePathProvider;\n}\n\nexport interface IRelativePathProvider {\n\n\t/**\n\t * Whether to not add a prefix when in multi-root workspace.\n\t */\n\treadonly noPrefix?: boolean;\n\n\tgetWorkspace(): { folders: { uri: URI; name?: string }[] };\n\tgetWorkspaceFolder(resource: URI): { uri: URI; name?: string } | null;\n}\n\nexport interface IUserHomeProvider {\n\tuserHome: URI;\n}\n\nexport function getPathLabel(resource: URI, formatting: IPathLabelFormatting): string {\n\tconst { os, tildify: tildifier, relative: relatifier } = formatting;\n\n\t// return early with a relative path if we can resolve one\n\tif (relatifier) {\n\t\tconst relativePath = getRelativePathLabel(resource, relatifier, os);\n\t\tif (typeof relativePath === 'string') {\n\t\t\treturn relativePath;\n\t\t}\n\t}\n\n\t// otherwise try to resolve a absolute path label and\n\t// apply target OS standard path separators if target\n\t// OS differs from actual OS we are running in\n\tlet absolutePath = resource.fsPath;\n\tif (os === OperatingSystem.Windows && !isWindows) {\n\t\tabsolutePath = absolutePath.replace(/\\//g, '\\\\');\n\t} else if (os !== OperatingSystem.Windows && isWindows) {\n\t\tabsolutePath = absolutePath.replace(/\\\\/g, '/');\n\t}\n\n\t// macOS/Linux: tildify with provided user home directory\n\tif (os !== OperatingSystem.Windows && tildifier?.userHome) {\n\t\tconst userHome = tildifier.userHome.fsPath;\n\n\t\t// This is a bit of a hack, but in order to figure out if the\n\t\t// resource is in the user home, we need to make sure to convert it\n\t\t// to a user home resource. We cannot assume that the resource is\n\t\t// already a user home resource.\n\t\tlet userHomeCandidate: string;\n\t\tif (resource.scheme !== tildifier.userHome.scheme && resource.path[0] === posix.sep && resource.path[1] !== posix.sep) {\n\t\t\tuserHomeCandidate = tildifier.userHome.with({ path: resource.path }).fsPath;\n\t\t} else {\n\t\t\tuserHomeCandidate = absolutePath;\n\t\t}\n\n\t\tabsolutePath = tildify(userHomeCandidate, userHome, os);\n\t}\n\n\t// normalize\n\tconst pathLib = os === OperatingSystem.Windows ? win32 : posix;\n\treturn pathLib.normalize(normalizeDriveLetter(absolutePath, os === OperatingSystem.Windows));\n}\n\nfunction getRelativePathLabel(resource: URI, relativePathProvider: IRelativePathProvider, os: OperatingSystem): string | undefined {\n\tconst pathLib = os === OperatingSystem.Windows ? win32 : posix;\n\tconst extUriLib = os === OperatingSystem.Linux ? extUri : extUriIgnorePathCase;\n\n\tconst workspace = relativePathProvider.getWorkspace();\n\tconst firstFolder = firstOrDefault(workspace.folders);\n\tif (!firstFolder) {\n\t\treturn undefined;\n\t}\n\n\t// This is a bit of a hack, but in order to figure out the folder\n\t// the resource belongs to, we need to make sure to convert it\n\t// to a workspace resource. We cannot assume that the resource is\n\t// already matching the workspace.\n\tif (resource.scheme !== firstFolder.uri.scheme && resource.path[0] === posix.sep && resource.path[1] !== posix.sep) {\n\t\tresource = firstFolder.uri.with({ path: resource.path });\n\t}\n\n\tconst folder = relativePathProvider.getWorkspaceFolder(resource);\n\tif (!folder) {\n\t\treturn undefined;\n\t}\n\n\tlet relativePathLabel: string | undefined = undefined;\n\tif (extUriLib.isEqual(folder.uri, resource)) {\n\t\trelativePathLabel = ''; // no label if paths are identical\n\t} else {\n\t\trelativePathLabel = extUriLib.relativePath(folder.uri, resource) ?? '';\n\t}\n\n\t// normalize\n\tif (relativePathLabel) {\n\t\trelativePathLabel = pathLib.normalize(relativePathLabel);\n\t}\n\n\t// always show root basename if there are multiple folders\n\tif (workspace.folders.length > 1 && !relativePathProvider.noPrefix) {\n\t\tconst rootName = folder.name ? folder.name : extUriLib.basenameOrAuthority(folder.uri);\n\t\trelativePathLabel = relativePathLabel ? `${rootName} • ${relativePathLabel}` : rootName;\n\t}\n\n\treturn relativePathLabel;\n}\n\nexport function normalizeDriveLetter(path: string, isWindowsOS: boolean = isWindows): string {\n\tif (hasDriveLetter(path, isWindowsOS)) {\n\t\treturn path.charAt(0).toUpperCase() + path.slice(1);\n\t}\n\n\treturn path;\n}\n\nlet normalizedUserHomeCached: { original: string; normalized: string } = Object.create(null);\nexport function tildify(path: string, userHome: string, os = OS): string {\n\tif (os === OperatingSystem.Windows || !path || !userHome) {\n\t\treturn path; // unsupported on Windows\n\t}\n\n\tlet normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;\n\tif (!normalizedUserHome) {\n\t\tnormalizedUserHome = userHome;\n\t\tif (isWindows) {\n\t\t\tnormalizedUserHome = toSlashes(normalizedUserHome); // make sure that the path is POSIX normalized on Windows\n\t\t}\n\t\tnormalizedUserHome = `${rtrim(normalizedUserHome, posix.sep)}${posix.sep}`;\n\t\tnormalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };\n\t}\n\n\tlet normalizedPath = path;\n\tif (isWindows) {\n\t\tnormalizedPath = toSlashes(normalizedPath); // make sure that the path is POSIX normalized on Windows\n\t}\n\n\t// Linux: case sensitive, macOS: case insensitive\n\tif (os === OperatingSystem.Linux ? normalizedPath.startsWith(normalizedUserHome) : startsWithIgnoreCase(normalizedPath, normalizedUserHome)) {\n\t\treturn `~/${normalizedPath.substr(normalizedUserHome.length)}`;\n\t}\n\n\treturn path;\n}\n\nexport function untildify(path: string, userHome: string): string {\n\treturn path.replace(/^~($|\\/|\\\\)/, `${userHome}$1`);\n}\n\n/**\n * Shortens the paths but keeps them easy to distinguish.\n * Replaces not important parts with ellipsis.\n * Every shorten path matches only one original path and vice versa.\n *\n * Algorithm for shortening paths is as follows:\n * 1. For every path in list, find unique substring of that path.\n * 2. Unique substring along with ellipsis is shortened path of that path.\n * 3. To find unique substring of path, consider every segment of length from 1 to path.length of path from end of string\n *    and if present segment is not substring to any other paths then present segment is unique path,\n *    else check if it is not present as suffix of any other path and present segment is suffix of path itself,\n *    if it is true take present segment as unique path.\n * 4. Apply ellipsis to unique segment according to whether segment is present at start/in-between/end of path.\n *\n * Example 1\n * 1. consider 2 paths i.e. ['a\\\\b\\\\c\\\\d', 'a\\\\f\\\\b\\\\c\\\\d']\n * 2. find unique path of first path,\n * \ta. 'd' is present in path2 and is suffix of path2, hence not unique of present path.\n * \tb. 'c' is present in path2 and 'c' is not suffix of present path, similarly for 'b' and 'a' also.\n * \tc. 'd\\\\c' is suffix of path2.\n *  d. 'b\\\\c' is not suffix of present path.\n *  e. 'a\\\\b' is not present in path2, hence unique path is 'a\\\\b...'.\n * 3. for path2, 'f' is not present in path1 hence unique is '...\\\\f\\\\...'.\n *\n * Example 2\n * 1. consider 2 paths i.e. ['a\\\\b', 'a\\\\b\\\\c'].\n * \ta. Even if 'b' is present in path2, as 'b' is suffix of path1 and is not suffix of path2, unique path will be '...\\\\b'.\n * 2. for path2, 'c' is not present in path1 hence unique path is '..\\\\c'.\n */\nconst ellipsis = '\\u2026';\nconst unc = '\\\\\\\\';\nconst home = '~';\nexport function shorten(paths: string[], pathSeparator: string = sep): string[] {\n\tconst shortenedPaths: string[] = new Array(paths.length);\n\n\t// for every path\n\tlet match = false;\n\tfor (let pathIndex = 0; pathIndex < paths.length; pathIndex++) {\n\t\tconst originalPath = paths[pathIndex];\n\n\t\tif (originalPath === '') {\n\t\t\tshortenedPaths[pathIndex] = `.${pathSeparator}`;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!originalPath) {\n\t\t\tshortenedPaths[pathIndex] = originalPath;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmatch = true;\n\n\t\t// trim for now and concatenate unc path (e.g. \\\\network) or root path (/etc, ~/etc) later\n\t\tlet prefix = '';\n\t\tlet trimmedPath = originalPath;\n\t\tif (trimmedPath.indexOf(unc) === 0) {\n\t\t\tprefix = trimmedPath.substr(0, trimmedPath.indexOf(unc) + unc.length);\n\t\t\ttrimmedPath = trimmedPath.substr(trimmedPath.indexOf(unc) + unc.length);\n\t\t} else if (trimmedPath.indexOf(pathSeparator) === 0) {\n\t\t\tprefix = trimmedPath.substr(0, trimmedPath.indexOf(pathSeparator) + pathSeparator.length);\n\t\t\ttrimmedPath = trimmedPath.substr(trimmedPath.indexOf(pathSeparator) + pathSeparator.length);\n\t\t} else if (trimmedPath.indexOf(home) === 0) {\n\t\t\tprefix = trimmedPath.substr(0, trimmedPath.indexOf(home) + home.length);\n\t\t\ttrimmedPath = trimmedPath.substr(trimmedPath.indexOf(home) + home.length);\n\t\t}\n\n\t\t// pick the first shortest subpath found\n\t\tconst segments: string[] = trimmedPath.split(pathSeparator);\n\t\tfor (let subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {\n\t\t\tfor (let start = segments.length - subpathLength; match && start >= 0; start--) {\n\t\t\t\tmatch = false;\n\t\t\t\tlet subpath = segments.slice(start, start + subpathLength).join(pathSeparator);\n\n\t\t\t\t// that is unique to any other path\n\t\t\t\tfor (let otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {\n\n\t\t\t\t\t// suffix subpath treated specially as we consider no match 'x' and 'x/...'\n\t\t\t\t\tif (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {\n\t\t\t\t\t\tconst isSubpathEnding: boolean = (start + subpathLength === segments.length);\n\n\t\t\t\t\t\t// Adding separator as prefix for subpath, such that 'endsWith(src, trgt)' considers subpath as directory name instead of plain string.\n\t\t\t\t\t\t// prefix is not added when either subpath is root directory or path[otherPathIndex] does not have multiple directories.\n\t\t\t\t\t\tconst subpathWithSep: string = (start > 0 && paths[otherPathIndex].indexOf(pathSeparator) > -1) ? pathSeparator + subpath : subpath;\n\t\t\t\t\t\tconst isOtherPathEnding: boolean = paths[otherPathIndex].endsWith(subpathWithSep);\n\n\t\t\t\t\t\tmatch = !isSubpathEnding || isOtherPathEnding;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// found unique subpath\n\t\t\t\tif (!match) {\n\t\t\t\t\tlet result = '';\n\n\t\t\t\t\t// preserve disk drive or root prefix\n\t\t\t\t\tif (segments[0].endsWith(':') || prefix !== '') {\n\t\t\t\t\t\tif (start === 1) {\n\t\t\t\t\t\t\t// extend subpath to include disk drive prefix\n\t\t\t\t\t\t\tstart = 0;\n\t\t\t\t\t\t\tsubpathLength++;\n\t\t\t\t\t\t\tsubpath = segments[0] + pathSeparator + subpath;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (start > 0) {\n\t\t\t\t\t\t\tresult = segments[0] + pathSeparator;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult = prefix + result;\n\t\t\t\t\t}\n\n\t\t\t\t\t// add ellipsis at the beginning if needed\n\t\t\t\t\tif (start > 0) {\n\t\t\t\t\t\tresult = result + ellipsis + pathSeparator;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = result + subpath;\n\n\t\t\t\t\t// add ellipsis at the end if needed\n\t\t\t\t\tif (start + subpathLength < segments.length) {\n\t\t\t\t\t\tresult = result + pathSeparator + ellipsis;\n\t\t\t\t\t}\n\n\t\t\t\t\tshortenedPaths[pathIndex] = result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (match) {\n\t\t\tshortenedPaths[pathIndex] = originalPath; // use original path if no unique subpaths found\n\t\t}\n\t}\n\n\treturn shortenedPaths;\n}\n\nexport interface ISeparator {\n\tlabel: string;\n}\n\nenum Type {\n\tTEXT,\n\tVARIABLE,\n\tSEPARATOR\n}\n\ninterface ISegment {\n\tvalue: string;\n\ttype: Type;\n}\n\n/**\n * Helper to insert values for specific template variables into the string. E.g. \"this $(is) a $(template)\" can be\n * passed to this function together with an object that maps \"is\" and \"template\" to strings to have them replaced.\n * @param value string to which template is applied\n * @param values the values of the templates to use\n */\nexport function template(template: string, values: { [key: string]: string | ISeparator | undefined | null } = Object.create(null)): string {\n\tconst segments: ISegment[] = [];\n\n\tlet inVariable = false;\n\tlet curVal = '';\n\tfor (const char of template) {\n\t\t// Beginning of variable\n\t\tif (char === '$' || (inVariable && char === '{')) {\n\t\t\tif (curVal) {\n\t\t\t\tsegments.push({ value: curVal, type: Type.TEXT });\n\t\t\t}\n\n\t\t\tcurVal = '';\n\t\t\tinVariable = true;\n\t\t}\n\n\t\t// End of variable\n\t\telse if (char === '}' && inVariable) {\n\t\t\tconst resolved = values[curVal];\n\n\t\t\t// Variable\n\t\t\tif (typeof resolved === 'string') {\n\t\t\t\tif (resolved.length) {\n\t\t\t\t\tsegments.push({ value: resolved, type: Type.VARIABLE });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Separator\n\t\t\telse if (resolved) {\n\t\t\t\tconst prevSegment = segments[segments.length - 1];\n\t\t\t\tif (!prevSegment || prevSegment.type !== Type.SEPARATOR) {\n\t\t\t\t\tsegments.push({ value: resolved.label, type: Type.SEPARATOR }); // prevent duplicate separators\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurVal = '';\n\t\t\tinVariable = false;\n\t\t}\n\n\t\t// Text or Variable Name\n\t\telse {\n\t\t\tcurVal += char;\n\t\t}\n\t}\n\n\t// Tail\n\tif (curVal && !inVariable) {\n\t\tsegments.push({ value: curVal, type: Type.TEXT });\n\t}\n\n\treturn segments.filter((segment, index) => {\n\n\t\t// Only keep separator if we have values to the left and right\n\t\tif (segment.type === Type.SEPARATOR) {\n\t\t\tconst left = segments[index - 1];\n\t\t\tconst right = segments[index + 1];\n\n\t\t\treturn [left, right].every(segment => segment && (segment.type === Type.VARIABLE || segment.type === Type.TEXT) && segment.value.length > 0);\n\t\t}\n\n\t\t// accept any TEXT and VARIABLE\n\t\treturn true;\n\t}).map(segment => segment.value).join('');\n}\n\n/**\n * Handles mnemonics for menu items. Depending on OS:\n * - Windows: Supported via & character (replace && with &)\n * -   Linux: Supported via & character (replace && with &)\n * -   macOS: Unsupported (replace && with empty string)\n */\nexport function mnemonicMenuLabel(label: string, forceDisableMnemonics?: boolean): string {\n\tif (isMacintosh || forceDisableMnemonics) {\n\t\treturn label.replace(/\\(&&\\w\\)|&&/g, '').replace(/&/g, isMacintosh ? '&' : '&&');\n\t}\n\n\treturn label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n}\n\n/**\n * Handles mnemonics for buttons. Depending on OS:\n * - Windows: Supported via & character (replace && with & and & with && for escaping)\n * -   Linux: Supported via _ character (replace && with _)\n * -   macOS: Unsupported (replace && with empty string)\n */\nexport function mnemonicButtonLabel(label: string, forceDisableMnemonics?: boolean): string {\n\tif (isMacintosh || forceDisableMnemonics) {\n\t\treturn label.replace(/\\(&&\\w\\)|&&/g, '');\n\t}\n\n\tif (isWindows) {\n\t\treturn label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n\t}\n\n\treturn label.replace(/&&/g, '_');\n}\n\nexport function unmnemonicLabel(label: string): string {\n\treturn label.replace(/&/g, '&&');\n}\n\n/**\n * Splits a recent label in name and parent path, supporting both '/' and '\\' and workspace suffixes.\n * If the location is remote, the remote name is included in the name part.\n */\nexport function splitRecentLabel(recentLabel: string): { name: string; parentPath: string } {\n\tif (recentLabel.endsWith(']')) {\n\t\t// label with workspace suffix\n\t\tconst lastIndexOfSquareBracket = recentLabel.lastIndexOf(' [', recentLabel.length - 2);\n\t\tif (lastIndexOfSquareBracket !== -1) {\n\t\t\tconst split = splitName(recentLabel.substring(0, lastIndexOfSquareBracket));\n\t\t\tconst remoteNameWithSpace = recentLabel.substring(lastIndexOfSquareBracket);\n\t\t\treturn { name: split.name + remoteNameWithSpace, parentPath: split.parentPath };\n\t\t}\n\t}\n\treturn splitName(recentLabel);\n}\n\nfunction splitName(fullPath: string): { name: string; parentPath: string } {\n\tconst p = fullPath.indexOf('/') !== -1 ? posix : win32;\n\tconst name = p.basename(fullPath);\n\tconst parentPath = p.dirname(fullPath);\n\tif (name.length) {\n\t\treturn { name, parentPath };\n\t}\n\t// only the root segment\n\treturn { name: parentPath, parentPath: '' };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { firstOrDefault } from './arrays';\nimport { hasDriveLetter, toSlashes } from './extpath';\nimport { posix, sep, win32 } from './path';\nimport { isMacintosh, isWindows, OperatingSystem, OS } from './platform';\nimport { extUri, extUriIgnorePathCase } from './resources';\nimport { rtrim, startsWithIgnoreCase } from './strings';\nimport { URI } from './uri';\n\nexport interface IPathLabelFormatting {\n\n\t/**\n\t * The OS the path label is from to produce a label\n\t * that matches OS expectations.\n\t */\n\treadonly os: OperatingSystem;\n\n\t/**\n\t * Whether to add a `~` when the path is in the\n\t * user home directory.\n\t *\n\t * Note: this only applies to Linux, macOS but not\n\t * Windows.\n\t */\n\treadonly tildify?: IUserHomeProvider;\n\n\t/**\n\t * Whether to convert to a relative path if the path\n\t * is within any of the opened workspace folders.\n\t */\n\treadonly relative?: IRelativePathProvider;\n}\n\nexport interface IRelativePathProvider {\n\n\t/**\n\t * Whether to not add a prefix when in multi-root workspace.\n\t */\n\treadonly noPrefix?: boolean;\n\n\tgetWorkspace(): { folders: { uri: URI; name?: string }[] };\n\tgetWorkspaceFolder(resource: URI): { uri: URI; name?: string } | null;\n}\n\nexport interface IUserHomeProvider {\n\tuserHome: URI;\n}\n\nexport function getPathLabel(resource: URI, formatting: IPathLabelFormatting): string {\n\tconst { os, tildify: tildifier, relative: relatifier } = formatting;\n\n\t// return early with a relative path if we can resolve one\n\tif (relatifier) {\n\t\tconst relativePath = getRelativePathLabel(resource, relatifier, os);\n\t\tif (typeof relativePath === 'string') {\n\t\t\treturn relativePath;\n\t\t}\n\t}\n\n\t// otherwise try to resolve a absolute path label and\n\t// apply target OS standard path separators if target\n\t// OS differs from actual OS we are running in\n\tlet absolutePath = resource.fsPath;\n\tif (os === OperatingSystem.Windows && !isWindows) {\n\t\tabsolutePath = absolutePath.replace(/\\//g, '\\\\');\n\t} else if (os !== OperatingSystem.Windows && isWindows) {\n\t\tabsolutePath = absolutePath.replace(/\\\\/g, '/');\n\t}\n\n\t// macOS/Linux: tildify with provided user home directory\n\tif (os !== OperatingSystem.Windows && tildifier?.userHome) {\n\t\tconst userHome = tildifier.userHome.fsPath;\n\n\t\t// This is a bit of a hack, but in order to figure out if the\n\t\t// resource is in the user home, we need to make sure to convert it\n\t\t// to a user home resource. We cannot assume that the resource is\n\t\t// already a user home resource.\n\t\tlet userHomeCandidate: string;\n\t\tif (resource.scheme !== tildifier.userHome.scheme && resource.path[0] === posix.sep && resource.path[1] !== posix.sep) {\n\t\t\tuserHomeCandidate = tildifier.userHome.with({ path: resource.path }).fsPath;\n\t\t} else {\n\t\t\tuserHomeCandidate = absolutePath;\n\t\t}\n\n\t\tabsolutePath = tildify(userHomeCandidate, userHome, os);\n\t}\n\n\t// normalize\n\tconst pathLib = os === OperatingSystem.Windows ? win32 : posix;\n\treturn pathLib.normalize(normalizeDriveLetter(absolutePath, os === OperatingSystem.Windows));\n}\n\nfunction getRelativePathLabel(resource: URI, relativePathProvider: IRelativePathProvider, os: OperatingSystem): string | undefined {\n\tconst pathLib = os === OperatingSystem.Windows ? win32 : posix;\n\tconst extUriLib = os === OperatingSystem.Linux ? extUri : extUriIgnorePathCase;\n\n\tconst workspace = relativePathProvider.getWorkspace();\n\tconst firstFolder = firstOrDefault(workspace.folders);\n\tif (!firstFolder) {\n\t\treturn undefined;\n\t}\n\n\t// This is a bit of a hack, but in order to figure out the folder\n\t// the resource belongs to, we need to make sure to convert it\n\t// to a workspace resource. We cannot assume that the resource is\n\t// already matching the workspace.\n\tif (resource.scheme !== firstFolder.uri.scheme && resource.path[0] === posix.sep && resource.path[1] !== posix.sep) {\n\t\tresource = firstFolder.uri.with({ path: resource.path });\n\t}\n\n\tconst folder = relativePathProvider.getWorkspaceFolder(resource);\n\tif (!folder) {\n\t\treturn undefined;\n\t}\n\n\tlet relativePathLabel: string | undefined = undefined;\n\tif (extUriLib.isEqual(folder.uri, resource)) {\n\t\trelativePathLabel = ''; // no label if paths are identical\n\t} else {\n\t\trelativePathLabel = extUriLib.relativePath(folder.uri, resource) ?? '';\n\t}\n\n\t// normalize\n\tif (relativePathLabel) {\n\t\trelativePathLabel = pathLib.normalize(relativePathLabel);\n\t}\n\n\t// always show root basename if there are multiple folders\n\tif (workspace.folders.length > 1 && !relativePathProvider.noPrefix) {\n\t\tconst rootName = folder.name ? folder.name : extUriLib.basenameOrAuthority(folder.uri);\n\t\trelativePathLabel = relativePathLabel ? `${rootName} • ${relativePathLabel}` : rootName;\n\t}\n\n\treturn relativePathLabel;\n}\n\nexport function normalizeDriveLetter(path: string, isWindowsOS: boolean = isWindows): string {\n\tif (hasDriveLetter(path, isWindowsOS)) {\n\t\treturn path.charAt(0).toUpperCase() + path.slice(1);\n\t}\n\n\treturn path;\n}\n\nlet normalizedUserHomeCached: { original: string; normalized: string } = Object.create(null);\nexport function tildify(path: string, userHome: string, os = OS): string {\n\tif (os === OperatingSystem.Windows || !path || !userHome) {\n\t\treturn path; // unsupported on Windows\n\t}\n\n\tlet normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;\n\tif (!normalizedUserHome) {\n\t\tnormalizedUserHome = userHome;\n\t\tif (isWindows) {\n\t\t\tnormalizedUserHome = toSlashes(normalizedUserHome); // make sure that the path is POSIX normalized on Windows\n\t\t}\n\t\tnormalizedUserHome = `${rtrim(normalizedUserHome, posix.sep)}${posix.sep}`;\n\t\tnormalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };\n\t}\n\n\tlet normalizedPath = path;\n\tif (isWindows) {\n\t\tnormalizedPath = toSlashes(normalizedPath); // make sure that the path is POSIX normalized on Windows\n\t}\n\n\t// Linux: case sensitive, macOS: case insensitive\n\tif (os === OperatingSystem.Linux ? normalizedPath.startsWith(normalizedUserHome) : startsWithIgnoreCase(normalizedPath, normalizedUserHome)) {\n\t\treturn `~/${normalizedPath.substr(normalizedUserHome.length)}`;\n\t}\n\n\treturn path;\n}\n\nexport function untildify(path: string, userHome: string): string {\n\treturn path.replace(/^~($|\\/|\\\\)/, `${userHome}$1`);\n}\n\n/**\n * Shortens the paths but keeps them easy to distinguish.\n * Replaces not important parts with ellipsis.\n * Every shorten path matches only one original path and vice versa.\n *\n * Algorithm for shortening paths is as follows:\n * 1. For every path in list, find unique substring of that path.\n * 2. Unique substring along with ellipsis is shortened path of that path.\n * 3. To find unique substring of path, consider every segment of length from 1 to path.length of path from end of string\n *    and if present segment is not substring to any other paths then present segment is unique path,\n *    else check if it is not present as suffix of any other path and present segment is suffix of path itself,\n *    if it is true take present segment as unique path.\n * 4. Apply ellipsis to unique segment according to whether segment is present at start/in-between/end of path.\n *\n * Example 1\n * 1. consider 2 paths i.e. ['a\\\\b\\\\c\\\\d', 'a\\\\f\\\\b\\\\c\\\\d']\n * 2. find unique path of first path,\n * \ta. 'd' is present in path2 and is suffix of path2, hence not unique of present path.\n * \tb. 'c' is present in path2 and 'c' is not suffix of present path, similarly for 'b' and 'a' also.\n * \tc. 'd\\\\c' is suffix of path2.\n *  d. 'b\\\\c' is not suffix of present path.\n *  e. 'a\\\\b' is not present in path2, hence unique path is 'a\\\\b...'.\n * 3. for path2, 'f' is not present in path1 hence unique is '...\\\\f\\\\...'.\n *\n * Example 2\n * 1. consider 2 paths i.e. ['a\\\\b', 'a\\\\b\\\\c'].\n * \ta. Even if 'b' is present in path2, as 'b' is suffix of path1 and is not suffix of path2, unique path will be '...\\\\b'.\n * 2. for path2, 'c' is not present in path1 hence unique path is '..\\\\c'.\n */\nconst ellipsis = '\\u2026';\nconst unc = '\\\\\\\\';\nconst home = '~';\nexport function shorten(paths: string[], pathSeparator: string = sep): string[] {\n\tconst shortenedPaths: string[] = new Array(paths.length);\n\n\t// for every path\n\tlet match = false;\n\tfor (let pathIndex = 0; pathIndex < paths.length; pathIndex++) {\n\t\tconst originalPath = paths[pathIndex];\n\n\t\tif (originalPath === '') {\n\t\t\tshortenedPaths[pathIndex] = `.${pathSeparator}`;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!originalPath) {\n\t\t\tshortenedPaths[pathIndex] = originalPath;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmatch = true;\n\n\t\t// trim for now and concatenate unc path (e.g. \\\\network) or root path (/etc, ~/etc) later\n\t\tlet prefix = '';\n\t\tlet trimmedPath = originalPath;\n\t\tif (trimmedPath.indexOf(unc) === 0) {\n\t\t\tprefix = trimmedPath.substr(0, trimmedPath.indexOf(unc) + unc.length);\n\t\t\ttrimmedPath = trimmedPath.substr(trimmedPath.indexOf(unc) + unc.length);\n\t\t} else if (trimmedPath.indexOf(pathSeparator) === 0) {\n\t\t\tprefix = trimmedPath.substr(0, trimmedPath.indexOf(pathSeparator) + pathSeparator.length);\n\t\t\ttrimmedPath = trimmedPath.substr(trimmedPath.indexOf(pathSeparator) + pathSeparator.length);\n\t\t} else if (trimmedPath.indexOf(home) === 0) {\n\t\t\tprefix = trimmedPath.substr(0, trimmedPath.indexOf(home) + home.length);\n\t\t\ttrimmedPath = trimmedPath.substr(trimmedPath.indexOf(home) + home.length);\n\t\t}\n\n\t\t// pick the first shortest subpath found\n\t\tconst segments: string[] = trimmedPath.split(pathSeparator);\n\t\tfor (let subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {\n\t\t\tfor (let start = segments.length - subpathLength; match && start >= 0; start--) {\n\t\t\t\tmatch = false;\n\t\t\t\tlet subpath = segments.slice(start, start + subpathLength).join(pathSeparator);\n\n\t\t\t\t// that is unique to any other path\n\t\t\t\tfor (let otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {\n\n\t\t\t\t\t// suffix subpath treated specially as we consider no match 'x' and 'x/...'\n\t\t\t\t\tif (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {\n\t\t\t\t\t\tconst isSubpathEnding: boolean = (start + subpathLength === segments.length);\n\n\t\t\t\t\t\t// Adding separator as prefix for subpath, such that 'endsWith(src, trgt)' considers subpath as directory name instead of plain string.\n\t\t\t\t\t\t// prefix is not added when either subpath is root directory or path[otherPathIndex] does not have multiple directories.\n\t\t\t\t\t\tconst subpathWithSep: string = (start > 0 && paths[otherPathIndex].indexOf(pathSeparator) > -1) ? pathSeparator + subpath : subpath;\n\t\t\t\t\t\tconst isOtherPathEnding: boolean = paths[otherPathIndex].endsWith(subpathWithSep);\n\n\t\t\t\t\t\tmatch = !isSubpathEnding || isOtherPathEnding;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// found unique subpath\n\t\t\t\tif (!match) {\n\t\t\t\t\tlet result = '';\n\n\t\t\t\t\t// preserve disk drive or root prefix\n\t\t\t\t\tif (segments[0].endsWith(':') || prefix !== '') {\n\t\t\t\t\t\tif (start === 1) {\n\t\t\t\t\t\t\t// extend subpath to include disk drive prefix\n\t\t\t\t\t\t\tstart = 0;\n\t\t\t\t\t\t\tsubpathLength++;\n\t\t\t\t\t\t\tsubpath = segments[0] + pathSeparator + subpath;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (start > 0) {\n\t\t\t\t\t\t\tresult = segments[0] + pathSeparator;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult = prefix + result;\n\t\t\t\t\t}\n\n\t\t\t\t\t// add ellipsis at the beginning if needed\n\t\t\t\t\tif (start > 0) {\n\t\t\t\t\t\tresult = result + ellipsis + pathSeparator;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = result + subpath;\n\n\t\t\t\t\t// add ellipsis at the end if needed\n\t\t\t\t\tif (start + subpathLength < segments.length) {\n\t\t\t\t\t\tresult = result + pathSeparator + ellipsis;\n\t\t\t\t\t}\n\n\t\t\t\t\tshortenedPaths[pathIndex] = result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (match) {\n\t\t\tshortenedPaths[pathIndex] = originalPath; // use original path if no unique subpaths found\n\t\t}\n\t}\n\n\treturn shortenedPaths;\n}\n\nexport interface ISeparator {\n\tlabel: string;\n}\n\nenum Type {\n\tTEXT,\n\tVARIABLE,\n\tSEPARATOR\n}\n\ninterface ISegment {\n\tvalue: string;\n\ttype: Type;\n}\n\n/**\n * Helper to insert values for specific template variables into the string. E.g. \"this $(is) a $(template)\" can be\n * passed to this function together with an object that maps \"is\" and \"template\" to strings to have them replaced.\n * @param value string to which template is applied\n * @param values the values of the templates to use\n */\nexport function template(template: string, values: { [key: string]: string | ISeparator | undefined | null } = Object.create(null)): string {\n\tconst segments: ISegment[] = [];\n\n\tlet inVariable = false;\n\tlet curVal = '';\n\tfor (const char of template) {\n\t\t// Beginning of variable\n\t\tif (char === '$' || (inVariable && char === '{')) {\n\t\t\tif (curVal) {\n\t\t\t\tsegments.push({ value: curVal, type: Type.TEXT });\n\t\t\t}\n\n\t\t\tcurVal = '';\n\t\t\tinVariable = true;\n\t\t}\n\n\t\t// End of variable\n\t\telse if (char === '}' && inVariable) {\n\t\t\tconst resolved = values[curVal];\n\n\t\t\t// Variable\n\t\t\tif (typeof resolved === 'string') {\n\t\t\t\tif (resolved.length) {\n\t\t\t\t\tsegments.push({ value: resolved, type: Type.VARIABLE });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Separator\n\t\t\telse if (resolved) {\n\t\t\t\tconst prevSegment = segments[segments.length - 1];\n\t\t\t\tif (!prevSegment || prevSegment.type !== Type.SEPARATOR) {\n\t\t\t\t\tsegments.push({ value: resolved.label, type: Type.SEPARATOR }); // prevent duplicate separators\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurVal = '';\n\t\t\tinVariable = false;\n\t\t}\n\n\t\t// Text or Variable Name\n\t\telse {\n\t\t\tcurVal += char;\n\t\t}\n\t}\n\n\t// Tail\n\tif (curVal && !inVariable) {\n\t\tsegments.push({ value: curVal, type: Type.TEXT });\n\t}\n\n\treturn segments.filter((segment, index) => {\n\n\t\t// Only keep separator if we have values to the left and right\n\t\tif (segment.type === Type.SEPARATOR) {\n\t\t\tconst left = segments[index - 1];\n\t\t\tconst right = segments[index + 1];\n\n\t\t\treturn [left, right].every(segment => segment && (segment.type === Type.VARIABLE || segment.type === Type.TEXT) && segment.value.length > 0);\n\t\t}\n\n\t\t// accept any TEXT and VARIABLE\n\t\treturn true;\n\t}).map(segment => segment.value).join('');\n}\n\n/**\n * Handles mnemonics for menu items. Depending on OS:\n * - Windows: Supported via & character (replace && with &)\n * -   Linux: Supported via & character (replace && with &)\n * -   macOS: Unsupported (replace && with empty string)\n */\nexport function mnemonicMenuLabel(label: string, forceDisableMnemonics?: boolean): string {\n\tif (isMacintosh || forceDisableMnemonics) {\n\t\treturn label.replace(/\\(&&\\w\\)|&&/g, '').replace(/&/g, isMacintosh ? '&' : '&&');\n\t}\n\n\treturn label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n}\n\n/**\n * Handles mnemonics for buttons. Depending on OS:\n * - Windows: Supported via & character (replace && with & and & with && for escaping)\n * -   Linux: Supported via _ character (replace && with _)\n * -   macOS: Unsupported (replace && with empty string)\n */\nexport function mnemonicButtonLabel(label: string, forceDisableMnemonics?: boolean): string {\n\tif (isMacintosh || forceDisableMnemonics) {\n\t\treturn label.replace(/\\(&&\\w\\)|&&/g, '');\n\t}\n\n\tif (isWindows) {\n\t\treturn label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n\t}\n\n\treturn label.replace(/&&/g, '_');\n}\n\nexport function unmnemonicLabel(label: string): string {\n\treturn label.replace(/&/g, '&&');\n}\n\n/**\n * Splits a recent label in name and parent path, supporting both '/' and '\\' and workspace suffixes.\n * If the location is remote, the remote name is included in the name part.\n */\nexport function splitRecentLabel(recentLabel: string): { name: string; parentPath: string } {\n\tif (recentLabel.endsWith(']')) {\n\t\t// label with workspace suffix\n\t\tconst lastIndexOfSquareBracket = recentLabel.lastIndexOf(' [', recentLabel.length - 2);\n\t\tif (lastIndexOfSquareBracket !== -1) {\n\t\t\tconst split = splitName(recentLabel.substring(0, lastIndexOfSquareBracket));\n\t\t\tconst remoteNameWithSpace = recentLabel.substring(lastIndexOfSquareBracket);\n\t\t\treturn { name: split.name + remoteNameWithSpace, parentPath: split.parentPath };\n\t\t}\n\t}\n\treturn splitName(recentLabel);\n}\n\nfunction splitName(fullPath: string): { name: string; parentPath: string } {\n\tconst p = fullPath.indexOf('/') !== -1 ? posix : win32;\n\tconst name = p.basename(fullPath);\n\tconst parentPath = p.dirname(fullPath);\n\tif (name.length) {\n\t\treturn { name, parentPath };\n\t}\n\t// only the root segment\n\treturn { name: parentPath, parentPath: '' };\n}\n"]}