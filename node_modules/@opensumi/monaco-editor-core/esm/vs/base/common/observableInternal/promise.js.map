{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/base/common/observableInternal/promise.ts","vs/base/common/observableInternal/promise.ts"],"names":[],"mappings":"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","file":"promise.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { autorun } from './autorun';\nimport { IObservable, IReader, observableValue, transaction } from './base';\nimport { Derived, defaultEqualityComparer, derived } from './derived';\nimport { CancellationToken, CancellationTokenSource } from '../cancellation';\nimport { DebugNameData, Owner } from './debugName';\n\nexport class ObservableLazy<T> {\n\tprivate readonly _value = observableValue<T | undefined>(this, undefined);\n\n\t/**\n\t * The cached value.\n\t * Does not force a computation of the value.\n\t */\n\tpublic get cachedValue(): IObservable<T | undefined> { return this._value; }\n\n\tconstructor(private readonly _computeValue: () => T) {\n\t}\n\n\t/**\n\t * Returns the cached value.\n\t * Computes the value if the value has not been cached yet.\n\t */\n\tpublic getValue() {\n\t\tlet v = this._value.get();\n\t\tif (!v) {\n\t\t\tv = this._computeValue();\n\t\t\tthis._value.set(v, undefined);\n\t\t}\n\t\treturn v;\n\t}\n}\n\n/**\n * A promise whose state is observable.\n */\nexport class ObservablePromise<T> {\n\tprivate readonly _value = observableValue<PromiseResult<T> | undefined>(this, undefined);\n\n\t/**\n\t * The promise that this object wraps.\n\t */\n\tpublic readonly promise: Promise<T>;\n\n\t/**\n\t * The current state of the promise.\n\t * Is `undefined` if the promise didn't resolve yet.\n\t */\n\tpublic readonly promiseResult: IObservable<PromiseResult<T> | undefined> = this._value;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(value => {\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description onPromiseResolved */\n\t\t\t\tthis._value.set(new PromiseResult(value, undefined), tx);\n\t\t\t});\n\t\t\treturn value;\n\t\t}, error => {\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description onPromiseRejected */\n\t\t\t\tthis._value.set(new PromiseResult<T>(undefined, error), tx);\n\t\t\t});\n\t\t\tthrow error;\n\t\t});\n\t}\n}\n\nexport class PromiseResult<T> {\n\tconstructor(\n\t\t/**\n\t\t * The value of the resolved promise.\n\t\t * Undefined if the promise rejected.\n\t\t */\n\t\tpublic readonly data: T | undefined,\n\n\t\t/**\n\t\t * The error in case of a rejected promise.\n\t\t * Undefined if the promise resolved.\n\t\t */\n\t\tpublic readonly error: unknown | undefined,\n\t) {\n\t}\n\n\t/**\n\t * Returns the value if the promise resolved, otherwise throws the error.\n\t */\n\tpublic getDataOrThrow(): T {\n\t\tif (this.error) {\n\t\t\tthrow this.error;\n\t\t}\n\t\treturn this.data!;\n\t}\n}\n\n/**\n * A lazy promise whose state is observable.\n */\nexport class ObservableLazyPromise<T> {\n\tprivate readonly _lazyValue = new ObservableLazy(() => new ObservablePromise(this._computePromise()));\n\n\t/**\n\t * Does not enforce evaluation of the promise compute function.\n\t * Is undefined if the promise has not been computed yet.\n\t */\n\tpublic readonly cachedPromiseResult = derived(this, reader => this._lazyValue.cachedValue.read(reader)?.promiseResult.read(reader));\n\n\tconstructor(private readonly _computePromise: () => Promise<T>) {\n\t}\n\n\tpublic getPromise(): Promise<T> {\n\t\treturn this._lazyValue.getValue().promise;\n\t}\n}\n\n/**\n * Resolves the promise when the observables state matches the predicate.\n */\nexport function waitForState<T, TState extends T>(observable: IObservable<T>, predicate: (state: T) => state is TState, isError?: (state: T) => boolean | unknown | undefined): Promise<TState>;\nexport function waitForState<T>(observable: IObservable<T>, predicate: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined): Promise<T>;\nexport function waitForState<T>(observable: IObservable<T>, predicate: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tlet isImmediateRun = true;\n\t\tlet shouldDispose = false;\n\t\tconst stateObs = observable.map(state => {\n\t\t\t/** @description waitForState.state */\n\t\t\treturn {\n\t\t\t\tisFinished: predicate(state),\n\t\t\t\terror: isError ? isError(state) : false,\n\t\t\t\tstate\n\t\t\t};\n\t\t});\n\t\tconst d = autorun(reader => {\n\t\t\t/** @description waitForState */\n\t\t\tconst { isFinished, error, state } = stateObs.read(reader);\n\t\t\tif (isFinished || error) {\n\t\t\t\tif (isImmediateRun) {\n\t\t\t\t\t// The variable `d` is not initialized yet\n\t\t\t\t\tshouldDispose = true;\n\t\t\t\t} else {\n\t\t\t\t\td.dispose();\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error === true ? state : error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(state);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tisImmediateRun = false;\n\t\tif (shouldDispose) {\n\t\t\td.dispose();\n\t\t}\n\t});\n}\n\nexport function derivedWithCancellationToken<T>(computeFn: (reader: IReader, cancellationToken: CancellationToken) => T): IObservable<T>;\nexport function derivedWithCancellationToken<T>(owner: object, computeFn: (reader: IReader, cancellationToken: CancellationToken) => T): IObservable<T>;\nexport function derivedWithCancellationToken<T>(computeFnOrOwner: ((reader: IReader, cancellationToken: CancellationToken) => T) | object, computeFnOrUndefined?: ((reader: IReader, cancellationToken: CancellationToken) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader, store: CancellationToken) => T;\n\tlet owner: Owner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tlet cancellationTokenSource: CancellationTokenSource | undefined = undefined;\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tif (cancellationTokenSource) {\n\t\t\t\tcancellationTokenSource.dispose(true);\n\t\t\t}\n\t\t\tcancellationTokenSource = new CancellationTokenSource();\n\t\t\treturn computeFn(r, cancellationTokenSource.token);\n\t\t}, undefined,\n\t\tundefined,\n\t\t() => cancellationTokenSource?.dispose(),\n\t\tdefaultEqualityComparer,\n\t);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { autorun } from './autorun';\nimport { IObservable, IReader, observableValue, transaction } from './base';\nimport { Derived, defaultEqualityComparer, derived } from './derived';\nimport { CancellationToken, CancellationTokenSource } from '../cancellation';\nimport { DebugNameData, Owner } from './debugName';\n\nexport class ObservableLazy<T> {\n\tprivate readonly _value = observableValue<T | undefined>(this, undefined);\n\n\t/**\n\t * The cached value.\n\t * Does not force a computation of the value.\n\t */\n\tpublic get cachedValue(): IObservable<T | undefined> { return this._value; }\n\n\tconstructor(private readonly _computeValue: () => T) {\n\t}\n\n\t/**\n\t * Returns the cached value.\n\t * Computes the value if the value has not been cached yet.\n\t */\n\tpublic getValue() {\n\t\tlet v = this._value.get();\n\t\tif (!v) {\n\t\t\tv = this._computeValue();\n\t\t\tthis._value.set(v, undefined);\n\t\t}\n\t\treturn v;\n\t}\n}\n\n/**\n * A promise whose state is observable.\n */\nexport class ObservablePromise<T> {\n\tprivate readonly _value = observableValue<PromiseResult<T> | undefined>(this, undefined);\n\n\t/**\n\t * The promise that this object wraps.\n\t */\n\tpublic readonly promise: Promise<T>;\n\n\t/**\n\t * The current state of the promise.\n\t * Is `undefined` if the promise didn't resolve yet.\n\t */\n\tpublic readonly promiseResult: IObservable<PromiseResult<T> | undefined> = this._value;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(value => {\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description onPromiseResolved */\n\t\t\t\tthis._value.set(new PromiseResult(value, undefined), tx);\n\t\t\t});\n\t\t\treturn value;\n\t\t}, error => {\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description onPromiseRejected */\n\t\t\t\tthis._value.set(new PromiseResult<T>(undefined, error), tx);\n\t\t\t});\n\t\t\tthrow error;\n\t\t});\n\t}\n}\n\nexport class PromiseResult<T> {\n\tconstructor(\n\t\t/**\n\t\t * The value of the resolved promise.\n\t\t * Undefined if the promise rejected.\n\t\t */\n\t\tpublic readonly data: T | undefined,\n\n\t\t/**\n\t\t * The error in case of a rejected promise.\n\t\t * Undefined if the promise resolved.\n\t\t */\n\t\tpublic readonly error: unknown | undefined,\n\t) {\n\t}\n\n\t/**\n\t * Returns the value if the promise resolved, otherwise throws the error.\n\t */\n\tpublic getDataOrThrow(): T {\n\t\tif (this.error) {\n\t\t\tthrow this.error;\n\t\t}\n\t\treturn this.data!;\n\t}\n}\n\n/**\n * A lazy promise whose state is observable.\n */\nexport class ObservableLazyPromise<T> {\n\tprivate readonly _lazyValue = new ObservableLazy(() => new ObservablePromise(this._computePromise()));\n\n\t/**\n\t * Does not enforce evaluation of the promise compute function.\n\t * Is undefined if the promise has not been computed yet.\n\t */\n\tpublic readonly cachedPromiseResult = derived(this, reader => this._lazyValue.cachedValue.read(reader)?.promiseResult.read(reader));\n\n\tconstructor(private readonly _computePromise: () => Promise<T>) {\n\t}\n\n\tpublic getPromise(): Promise<T> {\n\t\treturn this._lazyValue.getValue().promise;\n\t}\n}\n\n/**\n * Resolves the promise when the observables state matches the predicate.\n */\nexport function waitForState<T, TState extends T>(observable: IObservable<T>, predicate: (state: T) => state is TState, isError?: (state: T) => boolean | unknown | undefined): Promise<TState>;\nexport function waitForState<T>(observable: IObservable<T>, predicate: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined): Promise<T>;\nexport function waitForState<T>(observable: IObservable<T>, predicate: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tlet isImmediateRun = true;\n\t\tlet shouldDispose = false;\n\t\tconst stateObs = observable.map(state => {\n\t\t\t/** @description waitForState.state */\n\t\t\treturn {\n\t\t\t\tisFinished: predicate(state),\n\t\t\t\terror: isError ? isError(state) : false,\n\t\t\t\tstate\n\t\t\t};\n\t\t});\n\t\tconst d = autorun(reader => {\n\t\t\t/** @description waitForState */\n\t\t\tconst { isFinished, error, state } = stateObs.read(reader);\n\t\t\tif (isFinished || error) {\n\t\t\t\tif (isImmediateRun) {\n\t\t\t\t\t// The variable `d` is not initialized yet\n\t\t\t\t\tshouldDispose = true;\n\t\t\t\t} else {\n\t\t\t\t\td.dispose();\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error === true ? state : error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(state);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tisImmediateRun = false;\n\t\tif (shouldDispose) {\n\t\t\td.dispose();\n\t\t}\n\t});\n}\n\nexport function derivedWithCancellationToken<T>(computeFn: (reader: IReader, cancellationToken: CancellationToken) => T): IObservable<T>;\nexport function derivedWithCancellationToken<T>(owner: object, computeFn: (reader: IReader, cancellationToken: CancellationToken) => T): IObservable<T>;\nexport function derivedWithCancellationToken<T>(computeFnOrOwner: ((reader: IReader, cancellationToken: CancellationToken) => T) | object, computeFnOrUndefined?: ((reader: IReader, cancellationToken: CancellationToken) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader, store: CancellationToken) => T;\n\tlet owner: Owner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tlet cancellationTokenSource: CancellationTokenSource | undefined = undefined;\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tif (cancellationTokenSource) {\n\t\t\t\tcancellationTokenSource.dispose(true);\n\t\t\t}\n\t\t\tcancellationTokenSource = new CancellationTokenSource();\n\t\t\treturn computeFn(r, cancellationTokenSource.token);\n\t\t}, undefined,\n\t\tundefined,\n\t\t() => cancellationTokenSource?.dispose(),\n\t\tdefaultEqualityComparer,\n\t);\n}\n"]}