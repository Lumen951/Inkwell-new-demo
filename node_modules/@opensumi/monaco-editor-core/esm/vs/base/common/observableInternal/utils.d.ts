import { Event } from '../event';
import { DisposableStore, IDisposable } from '../lifecycle';
import { BaseObservable, IObservable, IObserver, IReader, ITransaction } from './base';
import { Owner } from './debugName';
/**
 * Represents an efficient observable whose value never changes.
 */
export declare function constObservable<T>(value: T): IObservable<T>;
export declare function observableFromPromise<T>(promise: Promise<T>): IObservable<{
    value?: T;
}>;
export declare function observableFromEvent<T, TArgs = unknown>(event: Event<TArgs>, getValue: (args: TArgs | undefined) => T): IObservable<T>;
export declare class FromEventObservable<TArgs, T> extends BaseObservable<T> {
    private readonly event;
    readonly _getValue: (args: TArgs | undefined) => T;
    static globalTransaction: ITransaction | undefined;
    private value;
    private hasValue;
    private subscription;
    constructor(event: Event<TArgs>, _getValue: (args: TArgs | undefined) => T);
    private getDebugName;
    get debugName(): string;
    protected onFirstObserverAdded(): void;
    private readonly handleEvent;
    protected onLastObserverRemoved(): void;
    get(): T;
}
export declare namespace observableFromEvent {
    const Observer: typeof FromEventObservable;
    function batchEventsGlobally(tx: ITransaction, fn: () => void): void;
}
export declare function observableSignalFromEvent(debugName: string, event: Event<any>): IObservable<void>;
/**
 * Creates a signal that can be triggered to invalidate observers.
 * Signals don't have a value - when they are triggered they indicate a change.
 * However, signals can carry a delta that is passed to observers.
 */
export declare function observableSignal<TDelta = void>(debugName: string): IObservableSignal<TDelta>;
export declare function observableSignal<TDelta = void>(owner: object): IObservableSignal<TDelta>;
export interface IObservableSignal<TChange> extends IObservable<void, TChange> {
    trigger(tx: ITransaction | undefined, change: TChange): void;
}
export declare function debouncedObservable<T>(observable: IObservable<T>, debounceMs: number, disposableStore: DisposableStore): IObservable<T | undefined>;
export declare function wasEventTriggeredRecently(event: Event<any>, timeoutMs: number, disposableStore: DisposableStore): IObservable<boolean>;
/**
 * This makes sure the observable is being observed and keeps its cache alive.
 */
export declare function keepObserved<T>(observable: IObservable<T>): IDisposable;
/**
 * This converts the given observable into an autorun.
 */
export declare function recomputeInitiallyAndOnChange<T>(observable: IObservable<T>, handleValue?: (value: T) => void): IDisposable;
export declare class KeepAliveObserver implements IObserver {
    private readonly _forceRecompute;
    private readonly _handleValue;
    private _counter;
    constructor(_forceRecompute: boolean, _handleValue: ((value: any) => void) | undefined);
    beginUpdate<T>(observable: IObservable<T, void>): void;
    endUpdate<T>(observable: IObservable<T, void>): void;
    handlePossibleChange<T>(observable: IObservable<T, unknown>): void;
    handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;
}
export declare function derivedObservableWithCache<T>(computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T>;
export declare function derivedObservableWithWritableCache<T>(owner: object, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> & {
    clearCache(transaction: ITransaction): void;
};
/**
 * When the items array changes, referential equal items are not mapped again.
 */
export declare function mapObservableArrayCached<TIn, TOut, TKey = TIn>(owner: Owner, items: IObservable<readonly TIn[]>, map: (input: TIn, store: DisposableStore) => TOut, keySelector?: (input: TIn) => TKey): IObservable<readonly TOut[]>;
