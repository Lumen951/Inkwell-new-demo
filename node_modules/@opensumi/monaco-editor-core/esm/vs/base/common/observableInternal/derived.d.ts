import { DisposableStore, IDisposable } from '../lifecycle';
import { BaseObservable, IChangeContext, IObservable, IObserver, IReader } from './base';
import { DebugNameData, IDebugNameData, Owner } from './debugName';
export type EqualityComparer<T> = (a: T, b: T) => boolean;
export declare const defaultEqualityComparer: EqualityComparer<any>;
/**
 * Creates an observable that is derived from other observables.
 * The value is only recomputed when absolutely needed.
 *
 * {@link computeFn} should start with a JS Doc using `@description` to name the derived.
 */
export declare function derived<T>(computeFn: (reader: IReader) => T): IObservable<T>;
export declare function derived<T>(owner: object, computeFn: (reader: IReader) => T): IObservable<T>;
export declare function derivedOpts<T>(options: IDebugNameData & {
    equalityComparer?: EqualityComparer<T>;
    onLastObserverRemoved?: (() => void);
}, computeFn: (reader: IReader) => T): IObservable<T>;
/**
 * Represents an observable that is derived from other observables.
 * The value is only recomputed when absolutely needed.
 *
 * {@link computeFn} should start with a JS Doc using `@description` to name the derived.
 *
 * Use `createEmptyChangeSummary` to create a "change summary" that can collect the changes.
 * Use `handleChange` to add a reported change to the change summary.
 * The compute function is given the last change summary.
 * The change summary is discarded after the compute function was called.
 *
 * @see derived
 */
export declare function derivedHandleChanges<T, TChangeSummary>(options: IDebugNameData & {
    createEmptyChangeSummary: () => TChangeSummary;
    handleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;
    equalityComparer?: EqualityComparer<T>;
}, computeFn: (reader: IReader, changeSummary: TChangeSummary) => T): IObservable<T>;
export declare function derivedWithStore<T>(computeFn: (reader: IReader, store: DisposableStore) => T): IObservable<T>;
export declare function derivedWithStore<T>(owner: object, computeFn: (reader: IReader, store: DisposableStore) => T): IObservable<T>;
export declare function derivedDisposable<T extends IDisposable | undefined>(computeFn: (reader: IReader) => T): IObservable<T>;
export declare function derivedDisposable<T extends IDisposable | undefined>(owner: Owner, computeFn: (reader: IReader) => T): IObservable<T>;
export declare class Derived<T, TChangeSummary = any> extends BaseObservable<T, void> implements IReader, IObserver {
    private readonly _debugNameData;
    readonly _computeFn: (reader: IReader, changeSummary: TChangeSummary) => T;
    private readonly createChangeSummary;
    private readonly _handleChange;
    private readonly _handleLastObserverRemoved;
    private readonly _equalityComparator;
    private state;
    private value;
    private updateCount;
    private dependencies;
    private dependenciesToBeRemoved;
    private changeSummary;
    get debugName(): string;
    constructor(_debugNameData: DebugNameData, _computeFn: (reader: IReader, changeSummary: TChangeSummary) => T, createChangeSummary: (() => TChangeSummary) | undefined, _handleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined, _handleLastObserverRemoved: (() => void) | undefined, _equalityComparator: EqualityComparer<T>);
    protected onLastObserverRemoved(): void;
    get(): T;
    private _recomputeIfNeeded;
    toString(): string;
    beginUpdate<T>(_observable: IObservable<T>): void;
    endUpdate<T>(_observable: IObservable<T>): void;
    handlePossibleChange<T>(observable: IObservable<T, unknown>): void;
    handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;
    readObservable<T>(observable: IObservable<T>): T;
    addObserver(observer: IObserver): void;
    removeObserver(observer: IObserver): void;
}
