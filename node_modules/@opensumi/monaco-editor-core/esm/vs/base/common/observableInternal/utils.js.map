{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/base/common/observableInternal/utils.ts","vs/base/common/observableInternal/utils.ts"],"names":[],"mappings":"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","file":"utils.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../event';\nimport { DisposableStore, IDisposable, toDisposable } from '../lifecycle';\nimport { autorun } from './autorun';\nimport { BaseObservable, ConvenientObservable, IObservable, IObserver, IReader, ITransaction, _setKeepObserved, _setRecomputeInitiallyAndOnChange, observableValue, subtransaction, transaction } from './base';\nimport { DebugNameData, Owner, getFunctionName } from './debugName';\nimport { derived, derivedOpts } from './derived';\nimport { getLogger } from './logging';\n\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable<T>(value: T): IObservable<T> {\n\treturn new ConstObservable(value);\n}\n\nclass ConstObservable<T> extends ConvenientObservable<T, void> {\n\tconstructor(private readonly value: T) {\n\t\tsuper();\n\t}\n\n\tpublic override get debugName(): string {\n\t\treturn this.toString();\n\t}\n\n\tpublic get(): T {\n\t\treturn this.value;\n\t}\n\tpublic addObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\tpublic removeObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\n\toverride toString(): string {\n\t\treturn `Const: ${this.value}`;\n\t}\n}\n\n\nexport function observableFromPromise<T>(promise: Promise<T>): IObservable<{ value?: T }> {\n\tconst observable = observableValue<{ value?: T }>('promiseValue', {});\n\tpromise.then((value) => {\n\t\tobservable.set({ value }, undefined);\n\t});\n\treturn observable;\n}\n\nexport function observableFromEvent<T, TArgs = unknown>(\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T\n): IObservable<T> {\n\treturn new FromEventObservable(event, getValue);\n}\n\nexport class FromEventObservable<TArgs, T> extends BaseObservable<T> {\n\tpublic static globalTransaction: ITransaction | undefined;\n\n\tprivate value: T | undefined;\n\tprivate hasValue = false;\n\tprivate subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tprivate readonly event: Event<TArgs>,\n\t\tpublic readonly _getValue: (args: TArgs | undefined) => T\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate getDebugName(): string | undefined {\n\t\treturn getFunctionName(this._getValue);\n\t}\n\n\tpublic get debugName(): string {\n\t\tconst name = this.getDebugName();\n\t\treturn 'From Event' + (name ? `: ${name}` : '');\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = (args: TArgs | undefined) => {\n\t\tconst newValue = this._getValue(args);\n\t\tconst oldValue = this.value;\n\n\t\tconst didChange = !this.hasValue || oldValue !== newValue;\n\t\tlet didRunTransaction = false;\n\n\t\tif (didChange) {\n\t\t\tthis.value = newValue;\n\n\t\t\tif (this.hasValue) {\n\t\t\t\tdidRunTransaction = true;\n\t\t\t\tsubtransaction(\n\t\t\t\t\tFromEventObservable.globalTransaction,\n\t\t\t\t\t(tx) => {\n\t\t\t\t\t\tgetLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n\n\t\t\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\tconst name = this.getDebugName();\n\t\t\t\t\t\treturn 'Event fired' + (name ? `: ${name}` : '');\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.hasValue = true;\n\t\t}\n\n\t\tif (!didRunTransaction) {\n\t\t\tgetLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n\t\t}\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t\tthis.hasValue = false;\n\t\tthis.value = undefined;\n\t}\n\n\tpublic get(): T {\n\t\tif (this.subscription) {\n\t\t\tif (!this.hasValue) {\n\t\t\t\tthis.handleEvent(undefined);\n\t\t\t}\n\t\t\treturn this.value!;\n\t\t} else {\n\t\t\t// no cache, as there are no subscribers to keep it updated\n\t\t\treturn this._getValue(undefined);\n\t\t}\n\t}\n}\n\nexport namespace observableFromEvent {\n\texport const Observer = FromEventObservable;\n\n\texport function batchEventsGlobally(tx: ITransaction, fn: () => void): void {\n\t\tlet didSet = false;\n\t\tif (FromEventObservable.globalTransaction === undefined) {\n\t\t\tFromEventObservable.globalTransaction = tx;\n\t\t\tdidSet = true;\n\t\t}\n\t\ttry {\n\t\t\tfn();\n\t\t} finally {\n\t\t\tif (didSet) {\n\t\t\t\tFromEventObservable.globalTransaction = undefined;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function observableSignalFromEvent(\n\tdebugName: string,\n\tevent: Event<any>\n): IObservable<void> {\n\treturn new FromEventObservableSignal(debugName, event);\n}\n\nclass FromEventObservableSignal extends BaseObservable<void> {\n\tprivate subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tpublic readonly debugName: string,\n\t\tprivate readonly event: Event<any>,\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = () => {\n\t\ttransaction(\n\t\t\t(tx) => {\n\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\t() => this.debugName\n\t\t);\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\n/**\n * Creates a signal that can be triggered to invalidate observers.\n * Signals don't have a value - when they are triggered they indicate a change.\n * However, signals can carry a delta that is passed to observers.\n */\nexport function observableSignal<TDelta = void>(debugName: string): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(owner: object): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(debugNameOrOwner: string | object): IObservableSignal<TDelta> {\n\tif (typeof debugNameOrOwner === 'string') {\n\t\treturn new ObservableSignal<TDelta>(debugNameOrOwner);\n\t} else {\n\t\treturn new ObservableSignal<TDelta>(undefined, debugNameOrOwner);\n\t}\n}\n\nexport interface IObservableSignal<TChange> extends IObservable<void, TChange> {\n\ttrigger(tx: ITransaction | undefined, change: TChange): void;\n}\n\nclass ObservableSignal<TChange> extends BaseObservable<void, TChange> implements IObservableSignal<TChange> {\n\tpublic get debugName() {\n\t\treturn new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugName: string | undefined,\n\t\tprivate readonly _owner?: object,\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic trigger(tx: ITransaction | undefined, change: TChange): void {\n\t\tif (!tx) {\n\t\t\ttransaction(tx => {\n\t\t\t\tthis.trigger(tx, change);\n\t\t\t}, () => `Trigger signal ${this.debugName}`);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const o of this.observers) {\n\t\t\ttx.updateObserver(o, this);\n\t\t\to.handleChange(this, change);\n\t\t}\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\nexport function debouncedObservable<T>(observable: IObservable<T>, debounceMs: number, disposableStore: DisposableStore): IObservable<T | undefined> {\n\tconst debouncedObservable = observableValue<T | undefined>('debounced', undefined);\n\n\tlet timeout: any = undefined;\n\n\tdisposableStore.add(autorun(reader => {\n\t\t/** @description debounce */\n\t\tconst value = observable.read(reader);\n\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\t\ttimeout = setTimeout(() => {\n\t\t\ttransaction(tx => {\n\t\t\t\tdebouncedObservable.set(value, tx);\n\t\t\t});\n\t\t}, debounceMs);\n\n\t}));\n\n\treturn debouncedObservable;\n}\n\nexport function wasEventTriggeredRecently(event: Event<any>, timeoutMs: number, disposableStore: DisposableStore): IObservable<boolean> {\n\tconst observable = observableValue('triggeredRecently', false);\n\n\tlet timeout: any = undefined;\n\n\tdisposableStore.add(event(() => {\n\t\tobservable.set(true, undefined);\n\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\t\ttimeout = setTimeout(() => {\n\t\t\tobservable.set(false, undefined);\n\t\t}, timeoutMs);\n\t}));\n\n\treturn observable;\n}\n\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved<T>(observable: IObservable<T>): IDisposable {\n\tconst o = new KeepAliveObserver(false, undefined);\n\tobservable.addObserver(o);\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setKeepObserved(keepObserved);\n\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange<T>(observable: IObservable<T>, handleValue?: (value: T) => void): IDisposable {\n\tconst o = new KeepAliveObserver(true, handleValue);\n\tobservable.addObserver(o);\n\tif (handleValue) {\n\t\thandleValue(observable.get());\n\t} else {\n\t\tobservable.reportChanges();\n\t}\n\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\n\nexport class KeepAliveObserver implements IObserver {\n\tprivate _counter = 0;\n\n\tconstructor(\n\t\tprivate readonly _forceRecompute: boolean,\n\t\tprivate readonly _handleValue: ((value: any) => void) | undefined,\n\t) { }\n\n\tbeginUpdate<T>(observable: IObservable<T, void>): void {\n\t\tthis._counter++;\n\t}\n\n\tendUpdate<T>(observable: IObservable<T, void>): void {\n\t\tthis._counter--;\n\t\tif (this._counter === 0 && this._forceRecompute) {\n\t\t\tif (this._handleValue) {\n\t\t\t\tthis._handleValue(observable.get());\n\t\t\t} else {\n\t\t\t\tobservable.reportChanges();\n\t\t\t}\n\t\t}\n\t}\n\n\thandlePossibleChange<T>(observable: IObservable<T, unknown>): void {\n\t\t// NO OP\n\t}\n\n\thandleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void {\n\t\t// NO OP\n\t}\n}\n\nexport function derivedObservableWithCache<T>(computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> {\n\tlet lastValue: T | undefined = undefined;\n\tconst observable = derived(reader => {\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn observable;\n}\n\nexport function derivedObservableWithWritableCache<T>(owner: object, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> & { clearCache(transaction: ITransaction): void } {\n\tlet lastValue: T | undefined = undefined;\n\tconst counter = observableValue('derivedObservableWithWritableCache.counter', 0);\n\tconst observable = derived(owner, reader => {\n\t\tcounter.read(reader);\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn Object.assign(observable, {\n\t\tclearCache: (transaction: ITransaction) => {\n\t\t\tlastValue = undefined;\n\t\t\tcounter.set(counter.get() + 1, transaction);\n\t\t},\n\t});\n}\n\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached<TIn, TOut, TKey = TIn>(owner: Owner, items: IObservable<readonly TIn[]>, map: (input: TIn, store: DisposableStore) => TOut, keySelector?: (input: TIn) => TKey): IObservable<readonly TOut[]> {\n\tlet m = new ArrayMap(map, keySelector);\n\tconst self = derivedOpts({\n\t\tdebugReferenceFn: map,\n\t\towner,\n\t\tonLastObserverRemoved: () => {\n\t\t\tm.dispose();\n\t\t\tm = new ArrayMap(map);\n\t\t}\n\t}, (reader) => {\n\t\tm.setItems(items.read(reader));\n\t\treturn m.getItems();\n\t});\n\treturn self;\n}\n\nclass ArrayMap<TIn, TOut, TKey> implements IDisposable {\n\tprivate readonly _cache = new Map<TKey, { out: TOut; store: DisposableStore }>();\n\tprivate _items: TOut[] = [];\n\tconstructor(\n\t\tprivate readonly _map: (input: TIn, store: DisposableStore) => TOut,\n\t\tprivate readonly _keySelector?: (input: TIn) => TKey,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._cache.forEach(entry => entry.store.dispose());\n\t\tthis._cache.clear();\n\t}\n\n\tpublic setItems(items: readonly TIn[]): void {\n\t\tconst newItems: TOut[] = [];\n\t\tconst itemsToRemove = new Set(this._cache.keys());\n\n\t\tfor (const item of items) {\n\t\t\tconst key = this._keySelector ? this._keySelector(item) : item as unknown as TKey;\n\n\t\t\tlet entry = this._cache.get(key);\n\t\t\tif (!entry) {\n\t\t\t\tconst store = new DisposableStore();\n\t\t\t\tconst out = this._map(item, store);\n\t\t\t\tentry = { out, store };\n\t\t\t\tthis._cache.set(key, entry);\n\t\t\t} else {\n\t\t\t\titemsToRemove.delete(key);\n\t\t\t}\n\t\t\tnewItems.push(entry.out);\n\t\t}\n\n\t\tfor (const item of itemsToRemove) {\n\t\t\tconst entry = this._cache.get(item)!;\n\t\t\tentry.store.dispose();\n\t\t\tthis._cache.delete(item);\n\t\t}\n\n\t\tthis._items = newItems;\n\t}\n\n\tpublic getItems(): TOut[] {\n\t\treturn this._items;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../event';\nimport { DisposableStore, IDisposable, toDisposable } from '../lifecycle';\nimport { autorun } from './autorun';\nimport { BaseObservable, ConvenientObservable, IObservable, IObserver, IReader, ITransaction, _setKeepObserved, _setRecomputeInitiallyAndOnChange, observableValue, subtransaction, transaction } from './base';\nimport { DebugNameData, Owner, getFunctionName } from './debugName';\nimport { derived, derivedOpts } from './derived';\nimport { getLogger } from './logging';\n\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable<T>(value: T): IObservable<T> {\n\treturn new ConstObservable(value);\n}\n\nclass ConstObservable<T> extends ConvenientObservable<T, void> {\n\tconstructor(private readonly value: T) {\n\t\tsuper();\n\t}\n\n\tpublic override get debugName(): string {\n\t\treturn this.toString();\n\t}\n\n\tpublic get(): T {\n\t\treturn this.value;\n\t}\n\tpublic addObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\tpublic removeObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\n\toverride toString(): string {\n\t\treturn `Const: ${this.value}`;\n\t}\n}\n\n\nexport function observableFromPromise<T>(promise: Promise<T>): IObservable<{ value?: T }> {\n\tconst observable = observableValue<{ value?: T }>('promiseValue', {});\n\tpromise.then((value) => {\n\t\tobservable.set({ value }, undefined);\n\t});\n\treturn observable;\n}\n\nexport function observableFromEvent<T, TArgs = unknown>(\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T\n): IObservable<T> {\n\treturn new FromEventObservable(event, getValue);\n}\n\nexport class FromEventObservable<TArgs, T> extends BaseObservable<T> {\n\tpublic static globalTransaction: ITransaction | undefined;\n\n\tprivate value: T | undefined;\n\tprivate hasValue = false;\n\tprivate subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tprivate readonly event: Event<TArgs>,\n\t\tpublic readonly _getValue: (args: TArgs | undefined) => T\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate getDebugName(): string | undefined {\n\t\treturn getFunctionName(this._getValue);\n\t}\n\n\tpublic get debugName(): string {\n\t\tconst name = this.getDebugName();\n\t\treturn 'From Event' + (name ? `: ${name}` : '');\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = (args: TArgs | undefined) => {\n\t\tconst newValue = this._getValue(args);\n\t\tconst oldValue = this.value;\n\n\t\tconst didChange = !this.hasValue || oldValue !== newValue;\n\t\tlet didRunTransaction = false;\n\n\t\tif (didChange) {\n\t\t\tthis.value = newValue;\n\n\t\t\tif (this.hasValue) {\n\t\t\t\tdidRunTransaction = true;\n\t\t\t\tsubtransaction(\n\t\t\t\t\tFromEventObservable.globalTransaction,\n\t\t\t\t\t(tx) => {\n\t\t\t\t\t\tgetLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n\n\t\t\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\tconst name = this.getDebugName();\n\t\t\t\t\t\treturn 'Event fired' + (name ? `: ${name}` : '');\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.hasValue = true;\n\t\t}\n\n\t\tif (!didRunTransaction) {\n\t\t\tgetLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n\t\t}\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t\tthis.hasValue = false;\n\t\tthis.value = undefined;\n\t}\n\n\tpublic get(): T {\n\t\tif (this.subscription) {\n\t\t\tif (!this.hasValue) {\n\t\t\t\tthis.handleEvent(undefined);\n\t\t\t}\n\t\t\treturn this.value!;\n\t\t} else {\n\t\t\t// no cache, as there are no subscribers to keep it updated\n\t\t\treturn this._getValue(undefined);\n\t\t}\n\t}\n}\n\nexport namespace observableFromEvent {\n\texport const Observer = FromEventObservable;\n\n\texport function batchEventsGlobally(tx: ITransaction, fn: () => void): void {\n\t\tlet didSet = false;\n\t\tif (FromEventObservable.globalTransaction === undefined) {\n\t\t\tFromEventObservable.globalTransaction = tx;\n\t\t\tdidSet = true;\n\t\t}\n\t\ttry {\n\t\t\tfn();\n\t\t} finally {\n\t\t\tif (didSet) {\n\t\t\t\tFromEventObservable.globalTransaction = undefined;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function observableSignalFromEvent(\n\tdebugName: string,\n\tevent: Event<any>\n): IObservable<void> {\n\treturn new FromEventObservableSignal(debugName, event);\n}\n\nclass FromEventObservableSignal extends BaseObservable<void> {\n\tprivate subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tpublic readonly debugName: string,\n\t\tprivate readonly event: Event<any>,\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = () => {\n\t\ttransaction(\n\t\t\t(tx) => {\n\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\t() => this.debugName\n\t\t);\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\n/**\n * Creates a signal that can be triggered to invalidate observers.\n * Signals don't have a value - when they are triggered they indicate a change.\n * However, signals can carry a delta that is passed to observers.\n */\nexport function observableSignal<TDelta = void>(debugName: string): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(owner: object): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(debugNameOrOwner: string | object): IObservableSignal<TDelta> {\n\tif (typeof debugNameOrOwner === 'string') {\n\t\treturn new ObservableSignal<TDelta>(debugNameOrOwner);\n\t} else {\n\t\treturn new ObservableSignal<TDelta>(undefined, debugNameOrOwner);\n\t}\n}\n\nexport interface IObservableSignal<TChange> extends IObservable<void, TChange> {\n\ttrigger(tx: ITransaction | undefined, change: TChange): void;\n}\n\nclass ObservableSignal<TChange> extends BaseObservable<void, TChange> implements IObservableSignal<TChange> {\n\tpublic get debugName() {\n\t\treturn new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugName: string | undefined,\n\t\tprivate readonly _owner?: object,\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic trigger(tx: ITransaction | undefined, change: TChange): void {\n\t\tif (!tx) {\n\t\t\ttransaction(tx => {\n\t\t\t\tthis.trigger(tx, change);\n\t\t\t}, () => `Trigger signal ${this.debugName}`);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const o of this.observers) {\n\t\t\ttx.updateObserver(o, this);\n\t\t\to.handleChange(this, change);\n\t\t}\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\nexport function debouncedObservable<T>(observable: IObservable<T>, debounceMs: number, disposableStore: DisposableStore): IObservable<T | undefined> {\n\tconst debouncedObservable = observableValue<T | undefined>('debounced', undefined);\n\n\tlet timeout: any = undefined;\n\n\tdisposableStore.add(autorun(reader => {\n\t\t/** @description debounce */\n\t\tconst value = observable.read(reader);\n\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\t\ttimeout = setTimeout(() => {\n\t\t\ttransaction(tx => {\n\t\t\t\tdebouncedObservable.set(value, tx);\n\t\t\t});\n\t\t}, debounceMs);\n\n\t}));\n\n\treturn debouncedObservable;\n}\n\nexport function wasEventTriggeredRecently(event: Event<any>, timeoutMs: number, disposableStore: DisposableStore): IObservable<boolean> {\n\tconst observable = observableValue('triggeredRecently', false);\n\n\tlet timeout: any = undefined;\n\n\tdisposableStore.add(event(() => {\n\t\tobservable.set(true, undefined);\n\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\t\ttimeout = setTimeout(() => {\n\t\t\tobservable.set(false, undefined);\n\t\t}, timeoutMs);\n\t}));\n\n\treturn observable;\n}\n\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved<T>(observable: IObservable<T>): IDisposable {\n\tconst o = new KeepAliveObserver(false, undefined);\n\tobservable.addObserver(o);\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setKeepObserved(keepObserved);\n\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange<T>(observable: IObservable<T>, handleValue?: (value: T) => void): IDisposable {\n\tconst o = new KeepAliveObserver(true, handleValue);\n\tobservable.addObserver(o);\n\tif (handleValue) {\n\t\thandleValue(observable.get());\n\t} else {\n\t\tobservable.reportChanges();\n\t}\n\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\n\nexport class KeepAliveObserver implements IObserver {\n\tprivate _counter = 0;\n\n\tconstructor(\n\t\tprivate readonly _forceRecompute: boolean,\n\t\tprivate readonly _handleValue: ((value: any) => void) | undefined,\n\t) { }\n\n\tbeginUpdate<T>(observable: IObservable<T, void>): void {\n\t\tthis._counter++;\n\t}\n\n\tendUpdate<T>(observable: IObservable<T, void>): void {\n\t\tthis._counter--;\n\t\tif (this._counter === 0 && this._forceRecompute) {\n\t\t\tif (this._handleValue) {\n\t\t\t\tthis._handleValue(observable.get());\n\t\t\t} else {\n\t\t\t\tobservable.reportChanges();\n\t\t\t}\n\t\t}\n\t}\n\n\thandlePossibleChange<T>(observable: IObservable<T, unknown>): void {\n\t\t// NO OP\n\t}\n\n\thandleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void {\n\t\t// NO OP\n\t}\n}\n\nexport function derivedObservableWithCache<T>(computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> {\n\tlet lastValue: T | undefined = undefined;\n\tconst observable = derived(reader => {\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn observable;\n}\n\nexport function derivedObservableWithWritableCache<T>(owner: object, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> & { clearCache(transaction: ITransaction): void } {\n\tlet lastValue: T | undefined = undefined;\n\tconst counter = observableValue('derivedObservableWithWritableCache.counter', 0);\n\tconst observable = derived(owner, reader => {\n\t\tcounter.read(reader);\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn Object.assign(observable, {\n\t\tclearCache: (transaction: ITransaction) => {\n\t\t\tlastValue = undefined;\n\t\t\tcounter.set(counter.get() + 1, transaction);\n\t\t},\n\t});\n}\n\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached<TIn, TOut, TKey = TIn>(owner: Owner, items: IObservable<readonly TIn[]>, map: (input: TIn, store: DisposableStore) => TOut, keySelector?: (input: TIn) => TKey): IObservable<readonly TOut[]> {\n\tlet m = new ArrayMap(map, keySelector);\n\tconst self = derivedOpts({\n\t\tdebugReferenceFn: map,\n\t\towner,\n\t\tonLastObserverRemoved: () => {\n\t\t\tm.dispose();\n\t\t\tm = new ArrayMap(map);\n\t\t}\n\t}, (reader) => {\n\t\tm.setItems(items.read(reader));\n\t\treturn m.getItems();\n\t});\n\treturn self;\n}\n\nclass ArrayMap<TIn, TOut, TKey> implements IDisposable {\n\tprivate readonly _cache = new Map<TKey, { out: TOut; store: DisposableStore }>();\n\tprivate _items: TOut[] = [];\n\tconstructor(\n\t\tprivate readonly _map: (input: TIn, store: DisposableStore) => TOut,\n\t\tprivate readonly _keySelector?: (input: TIn) => TKey,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._cache.forEach(entry => entry.store.dispose());\n\t\tthis._cache.clear();\n\t}\n\n\tpublic setItems(items: readonly TIn[]): void {\n\t\tconst newItems: TOut[] = [];\n\t\tconst itemsToRemove = new Set(this._cache.keys());\n\n\t\tfor (const item of items) {\n\t\t\tconst key = this._keySelector ? this._keySelector(item) : item as unknown as TKey;\n\n\t\t\tlet entry = this._cache.get(key);\n\t\t\tif (!entry) {\n\t\t\t\tconst store = new DisposableStore();\n\t\t\t\tconst out = this._map(item, store);\n\t\t\t\tentry = { out, store };\n\t\t\t\tthis._cache.set(key, entry);\n\t\t\t} else {\n\t\t\t\titemsToRemove.delete(key);\n\t\t\t}\n\t\t\tnewItems.push(entry.out);\n\t\t}\n\n\t\tfor (const item of itemsToRemove) {\n\t\t\tconst entry = this._cache.get(item)!;\n\t\t\tentry.store.dispose();\n\t\t\tthis._cache.delete(item);\n\t\t}\n\n\t\tthis._items = newItems;\n\t}\n\n\tpublic getItems(): TOut[] {\n\t\treturn this._items;\n\t}\n}\n"]}