"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapObservableArrayCached = exports.derivedObservableWithWritableCache = exports.derivedObservableWithCache = exports.KeepAliveObserver = exports.recomputeInitiallyAndOnChange = exports.keepObserved = exports.wasEventTriggeredRecently = exports.debouncedObservable = exports.observableSignal = exports.observableSignalFromEvent = exports.FromEventObservable = exports.observableFromEvent = exports.observableFromPromise = exports.constObservable = void 0;
const lifecycle_1 = require("../lifecycle");
const autorun_1 = require("./autorun");
const base_1 = require("./base");
const debugName_1 = require("./debugName");
const derived_1 = require("./derived");
const logging_1 = require("./logging");
/**
 * Represents an efficient observable whose value never changes.
 */
function constObservable(value) {
    return new ConstObservable(value);
}
exports.constObservable = constObservable;
class ConstObservable extends base_1.ConvenientObservable {
    constructor(value) {
        super();
        this.value = value;
    }
    get debugName() {
        return this.toString();
    }
    get() {
        return this.value;
    }
    addObserver(observer) {
        // NO OP
    }
    removeObserver(observer) {
        // NO OP
    }
    toString() {
        return `Const: ${this.value}`;
    }
}
function observableFromPromise(promise) {
    const observable = (0, base_1.observableValue)('promiseValue', {});
    promise.then((value) => {
        observable.set({ value }, undefined);
    });
    return observable;
}
exports.observableFromPromise = observableFromPromise;
function observableFromEvent(event, getValue) {
    return new FromEventObservable(event, getValue);
}
exports.observableFromEvent = observableFromEvent;
class FromEventObservable extends base_1.BaseObservable {
    constructor(event, _getValue) {
        super();
        this.event = event;
        this._getValue = _getValue;
        this.hasValue = false;
        this.handleEvent = (args) => {
            var _a;
            const newValue = this._getValue(args);
            const oldValue = this.value;
            const didChange = !this.hasValue || oldValue !== newValue;
            let didRunTransaction = false;
            if (didChange) {
                this.value = newValue;
                if (this.hasValue) {
                    didRunTransaction = true;
                    (0, base_1.subtransaction)(FromEventObservable.globalTransaction, (tx) => {
                        var _a;
                        (_a = (0, logging_1.getLogger)()) === null || _a === void 0 ? void 0 : _a.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });
                        for (const o of this.observers) {
                            tx.updateObserver(o, this);
                            o.handleChange(this, undefined);
                        }
                    }, () => {
                        const name = this.getDebugName();
                        return 'Event fired' + (name ? `: ${name}` : '');
                    });
                }
                this.hasValue = true;
            }
            if (!didRunTransaction) {
                (_a = (0, logging_1.getLogger)()) === null || _a === void 0 ? void 0 : _a.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });
            }
        };
    }
    getDebugName() {
        return (0, debugName_1.getFunctionName)(this._getValue);
    }
    get debugName() {
        const name = this.getDebugName();
        return 'From Event' + (name ? `: ${name}` : '');
    }
    onFirstObserverAdded() {
        this.subscription = this.event(this.handleEvent);
    }
    onLastObserverRemoved() {
        this.subscription.dispose();
        this.subscription = undefined;
        this.hasValue = false;
        this.value = undefined;
    }
    get() {
        if (this.subscription) {
            if (!this.hasValue) {
                this.handleEvent(undefined);
            }
            return this.value;
        }
        else {
            // no cache, as there are no subscribers to keep it updated
            return this._getValue(undefined);
        }
    }
}
exports.FromEventObservable = FromEventObservable;
(function (observableFromEvent) {
    observableFromEvent.Observer = FromEventObservable;
    function batchEventsGlobally(tx, fn) {
        let didSet = false;
        if (FromEventObservable.globalTransaction === undefined) {
            FromEventObservable.globalTransaction = tx;
            didSet = true;
        }
        try {
            fn();
        }
        finally {
            if (didSet) {
                FromEventObservable.globalTransaction = undefined;
            }
        }
    }
    observableFromEvent.batchEventsGlobally = batchEventsGlobally;
})(observableFromEvent || (exports.observableFromEvent = observableFromEvent = {}));
function observableSignalFromEvent(debugName, event) {
    return new FromEventObservableSignal(debugName, event);
}
exports.observableSignalFromEvent = observableSignalFromEvent;
class FromEventObservableSignal extends base_1.BaseObservable {
    constructor(debugName, event) {
        super();
        this.debugName = debugName;
        this.event = event;
        this.handleEvent = () => {
            (0, base_1.transaction)((tx) => {
                for (const o of this.observers) {
                    tx.updateObserver(o, this);
                    o.handleChange(this, undefined);
                }
            }, () => this.debugName);
        };
    }
    onFirstObserverAdded() {
        this.subscription = this.event(this.handleEvent);
    }
    onLastObserverRemoved() {
        this.subscription.dispose();
        this.subscription = undefined;
    }
    get() {
        // NO OP
    }
}
function observableSignal(debugNameOrOwner) {
    if (typeof debugNameOrOwner === 'string') {
        return new ObservableSignal(debugNameOrOwner);
    }
    else {
        return new ObservableSignal(undefined, debugNameOrOwner);
    }
}
exports.observableSignal = observableSignal;
class ObservableSignal extends base_1.BaseObservable {
    get debugName() {
        var _a;
        return (_a = new debugName_1.DebugNameData(this._owner, this._debugName, undefined).getDebugName(this)) !== null && _a !== void 0 ? _a : 'Observable Signal';
    }
    constructor(_debugName, _owner) {
        super();
        this._debugName = _debugName;
        this._owner = _owner;
    }
    trigger(tx, change) {
        if (!tx) {
            (0, base_1.transaction)(tx => {
                this.trigger(tx, change);
            }, () => `Trigger signal ${this.debugName}`);
            return;
        }
        for (const o of this.observers) {
            tx.updateObserver(o, this);
            o.handleChange(this, change);
        }
    }
    get() {
        // NO OP
    }
}
function debouncedObservable(observable, debounceMs, disposableStore) {
    const debouncedObservable = (0, base_1.observableValue)('debounced', undefined);
    let timeout = undefined;
    disposableStore.add((0, autorun_1.autorun)(reader => {
        /** @description debounce */
        const value = observable.read(reader);
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(() => {
            (0, base_1.transaction)(tx => {
                debouncedObservable.set(value, tx);
            });
        }, debounceMs);
    }));
    return debouncedObservable;
}
exports.debouncedObservable = debouncedObservable;
function wasEventTriggeredRecently(event, timeoutMs, disposableStore) {
    const observable = (0, base_1.observableValue)('triggeredRecently', false);
    let timeout = undefined;
    disposableStore.add(event(() => {
        observable.set(true, undefined);
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(() => {
            observable.set(false, undefined);
        }, timeoutMs);
    }));
    return observable;
}
exports.wasEventTriggeredRecently = wasEventTriggeredRecently;
/**
 * This makes sure the observable is being observed and keeps its cache alive.
 */
function keepObserved(observable) {
    const o = new KeepAliveObserver(false, undefined);
    observable.addObserver(o);
    return (0, lifecycle_1.toDisposable)(() => {
        observable.removeObserver(o);
    });
}
exports.keepObserved = keepObserved;
(0, base_1._setKeepObserved)(keepObserved);
/**
 * This converts the given observable into an autorun.
 */
function recomputeInitiallyAndOnChange(observable, handleValue) {
    const o = new KeepAliveObserver(true, handleValue);
    observable.addObserver(o);
    if (handleValue) {
        handleValue(observable.get());
    }
    else {
        observable.reportChanges();
    }
    return (0, lifecycle_1.toDisposable)(() => {
        observable.removeObserver(o);
    });
}
exports.recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;
(0, base_1._setRecomputeInitiallyAndOnChange)(recomputeInitiallyAndOnChange);
class KeepAliveObserver {
    constructor(_forceRecompute, _handleValue) {
        this._forceRecompute = _forceRecompute;
        this._handleValue = _handleValue;
        this._counter = 0;
    }
    beginUpdate(observable) {
        this._counter++;
    }
    endUpdate(observable) {
        this._counter--;
        if (this._counter === 0 && this._forceRecompute) {
            if (this._handleValue) {
                this._handleValue(observable.get());
            }
            else {
                observable.reportChanges();
            }
        }
    }
    handlePossibleChange(observable) {
        // NO OP
    }
    handleChange(observable, change) {
        // NO OP
    }
}
exports.KeepAliveObserver = KeepAliveObserver;
function derivedObservableWithCache(computeFn) {
    let lastValue = undefined;
    const observable = (0, derived_1.derived)(reader => {
        lastValue = computeFn(reader, lastValue);
        return lastValue;
    });
    return observable;
}
exports.derivedObservableWithCache = derivedObservableWithCache;
function derivedObservableWithWritableCache(owner, computeFn) {
    let lastValue = undefined;
    const counter = (0, base_1.observableValue)('derivedObservableWithWritableCache.counter', 0);
    const observable = (0, derived_1.derived)(owner, reader => {
        counter.read(reader);
        lastValue = computeFn(reader, lastValue);
        return lastValue;
    });
    return Object.assign(observable, {
        clearCache: (transaction) => {
            lastValue = undefined;
            counter.set(counter.get() + 1, transaction);
        },
    });
}
exports.derivedObservableWithWritableCache = derivedObservableWithWritableCache;
/**
 * When the items array changes, referential equal items are not mapped again.
 */
function mapObservableArrayCached(owner, items, map, keySelector) {
    let m = new ArrayMap(map, keySelector);
    const self = (0, derived_1.derivedOpts)({
        debugReferenceFn: map,
        owner,
        onLastObserverRemoved: () => {
            m.dispose();
            m = new ArrayMap(map);
        }
    }, (reader) => {
        m.setItems(items.read(reader));
        return m.getItems();
    });
    return self;
}
exports.mapObservableArrayCached = mapObservableArrayCached;
class ArrayMap {
    constructor(_map, _keySelector) {
        this._map = _map;
        this._keySelector = _keySelector;
        this._cache = new Map();
        this._items = [];
    }
    dispose() {
        this._cache.forEach(entry => entry.store.dispose());
        this._cache.clear();
    }
    setItems(items) {
        const newItems = [];
        const itemsToRemove = new Set(this._cache.keys());
        for (const item of items) {
            const key = this._keySelector ? this._keySelector(item) : item;
            let entry = this._cache.get(key);
            if (!entry) {
                const store = new lifecycle_1.DisposableStore();
                const out = this._map(item, store);
                entry = { out, store };
                this._cache.set(key, entry);
            }
            else {
                itemsToRemove.delete(key);
            }
            newItems.push(entry.out);
        }
        for (const item of itemsToRemove) {
            const entry = this._cache.get(item);
            entry.store.dispose();
            this._cache.delete(item);
        }
        this._items = newItems;
    }
    getItems() {
        return this._items;
    }
}
//# sourceMappingURL=utils.js.map