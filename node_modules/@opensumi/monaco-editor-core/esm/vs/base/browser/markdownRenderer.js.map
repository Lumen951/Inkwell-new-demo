{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/base/browser/markdownRenderer.ts","vs/base/browser/markdownRenderer.ts"],"names":[],"mappings":"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","file":"markdownRenderer.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as DOM from './dom';\nimport * as dompurify from './dompurify/dompurify';\nimport { DomEmitter } from './event';\nimport { createElement, FormattedTextRenderOptions } from './formattedTextRenderer';\nimport { StandardKeyboardEvent } from './keyboardEvent';\nimport { StandardMouseEvent } from './mouseEvent';\nimport { renderLabelWithIcons } from './ui/iconLabel/iconLabels';\nimport { onUnexpectedError } from '../common/errors';\nimport { Event } from '../common/event';\nimport { escapeDoubleQuotes, IMarkdownString, MarkdownStringTrustedOptions, parseHrefAndDimensions, removeMarkdownEscapes } from '../common/htmlContent';\nimport { markdownEscapeEscapedIcons } from '../common/iconLabels';\nimport { defaultGenerator } from '../common/idGenerator';\nimport { KeyCode } from '../common/keyCodes';\nimport { Lazy } from '../common/lazy';\nimport { DisposableStore } from '../common/lifecycle';\nimport { marked } from '../common/marked/marked';\nimport { parse } from '../common/marshalling';\nimport { FileAccess, Schemas } from '../common/network';\nimport { cloneAndChange } from '../common/objects';\nimport { dirname, resolvePath } from '../common/resources';\nimport { escape } from '../common/strings';\nimport { URI } from '../common/uri';\n\nexport interface MarkedOptions extends marked.MarkedOptions {\n\tbaseUrl?: never;\n}\n\nexport interface MarkdownRenderOptions extends FormattedTextRenderOptions {\n\treadonly codeBlockRenderer?: (languageId: string, value: string) => Promise<HTMLElement>;\n\treadonly codeBlockRendererSync?: (languageId: string, value: string) => HTMLElement;\n\treadonly asyncRenderCallback?: () => void;\n\treadonly fillInIncompleteTokens?: boolean;\n}\n\nconst defaultMarkedRenderers = Object.freeze({\n\timage: (href: string | null, title: string | null, text: string): string => {\n\t\tlet dimensions: string[] = [];\n\t\tlet attributes: string[] = [];\n\t\tif (href) {\n\t\t\t({ href, dimensions } = parseHrefAndDimensions(href));\n\t\t\tattributes.push(`src=\"${escapeDoubleQuotes(href)}\"`);\n\t\t}\n\t\tif (text) {\n\t\t\tattributes.push(`alt=\"${escapeDoubleQuotes(text)}\"`);\n\t\t}\n\t\tif (title) {\n\t\t\tattributes.push(`title=\"${escapeDoubleQuotes(title)}\"`);\n\t\t}\n\t\tif (dimensions.length) {\n\t\t\tattributes = attributes.concat(dimensions);\n\t\t}\n\t\treturn '<img ' + attributes.join(' ') + '>';\n\t},\n\n\tparagraph: (text: string): string => {\n\t\treturn `<p>${text}</p>`;\n\t},\n\n\tlink: (href: string | null, title: string | null, text: string): string => {\n\t\tif (typeof href !== 'string') {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Remove markdown escapes. Workaround for https://github.com/chjj/marked/issues/829\n\t\tif (href === text) { // raw link case\n\t\t\ttext = removeMarkdownEscapes(text);\n\t\t}\n\n\t\ttitle = typeof title === 'string' ? escapeDoubleQuotes(removeMarkdownEscapes(title)) : '';\n\t\thref = removeMarkdownEscapes(href);\n\n\t\t// HTML Encode href\n\t\thref = href.replace(/&/g, '&amp;')\n\t\t\t.replace(/</g, '&lt;')\n\t\t\t.replace(/>/g, '&gt;')\n\t\t\t.replace(/\"/g, '&quot;')\n\t\t\t.replace(/'/g, '&#39;');\n\n\t\treturn `<a href=\"${href}\" title=\"${title || href}\" draggable=\"false\">${text}</a>`;\n\t},\n});\n\n/**\n * Low-level way create a html element from a markdown string.\n *\n * **Note** that for most cases you should be using [`MarkdownRenderer`](./src/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.ts)\n * which comes with support for pretty code block rendering and which uses the default way of handling links.\n */\nexport function renderMarkdown(markdown: IMarkdownString, options: MarkdownRenderOptions = {}, markedOptions: MarkedOptions = {}): { element: HTMLElement; dispose: () => void } {\n\tconst disposables = new DisposableStore();\n\tlet isDisposed = false;\n\n\tconst element = createElement(options);\n\n\tconst _uriMassage = function (part: string): string {\n\t\tlet data: any;\n\t\ttry {\n\t\t\tdata = parse(decodeURIComponent(part));\n\t\t} catch (e) {\n\t\t\t// ignore\n\t\t}\n\t\tif (!data) {\n\t\t\treturn part;\n\t\t}\n\t\tdata = cloneAndChange(data, value => {\n\t\t\tif (markdown.uris && markdown.uris[value]) {\n\t\t\t\treturn URI.revive(markdown.uris[value]);\n\t\t\t} else {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t});\n\t\treturn encodeURIComponent(JSON.stringify(data));\n\t};\n\n\tconst _href = function (href: string, isDomUri: boolean): string {\n\t\tconst data = markdown.uris && markdown.uris[href];\n\t\tlet uri = URI.revive(data);\n\t\tif (isDomUri) {\n\t\t\tif (href.startsWith(Schemas.data + ':')) {\n\t\t\t\treturn href;\n\t\t\t}\n\t\t\tif (!uri) {\n\t\t\t\turi = URI.parse(href);\n\t\t\t}\n\t\t\t// this URI will end up as \"src\"-attribute of a dom node\n\t\t\t// and because of that special rewriting needs to be done\n\t\t\t// so that the URI uses a protocol that's understood by\n\t\t\t// browsers (like http or https)\n\t\t\treturn FileAccess.uriToBrowserUri(uri).toString(true);\n\t\t}\n\t\tif (!uri) {\n\t\t\treturn href;\n\t\t}\n\t\tif (URI.parse(href).toString() === uri.toString()) {\n\t\t\treturn href; // no transformation performed\n\t\t}\n\t\tif (uri.query) {\n\t\t\turi = uri.with({ query: _uriMassage(uri.query) });\n\t\t}\n\t\treturn uri.toString();\n\t};\n\n\tconst renderer = new marked.Renderer();\n\trenderer.image = defaultMarkedRenderers.image;\n\trenderer.link = defaultMarkedRenderers.link;\n\trenderer.paragraph = defaultMarkedRenderers.paragraph;\n\n\t// Will collect [id, renderedElement] tuples\n\tconst codeBlocks: Promise<[string, HTMLElement]>[] = [];\n\tconst syncCodeBlocks: [string, HTMLElement][] = [];\n\n\tif (options.codeBlockRendererSync) {\n\t\trenderer.code = (code, lang) => {\n\t\t\tconst id = defaultGenerator.nextId();\n\t\t\tconst value = options.codeBlockRendererSync!(postProcessCodeBlockLanguageId(lang), code);\n\t\t\tsyncCodeBlocks.push([id, value]);\n\t\t\treturn `<div class=\"code\" data-code=\"${id}\">${escape(code)}</div>`;\n\t\t};\n\t} else if (options.codeBlockRenderer) {\n\t\trenderer.code = (code, lang) => {\n\t\t\tconst id = defaultGenerator.nextId();\n\t\t\tconst value = options.codeBlockRenderer!(postProcessCodeBlockLanguageId(lang), code);\n\t\t\tcodeBlocks.push(value.then(element => [id, element]));\n\t\t\treturn `<div class=\"code\" data-code=\"${id}\">${escape(code)}</div>`;\n\t\t};\n\t}\n\n\tif (options.actionHandler) {\n\t\tconst _activateLink = function (event: StandardMouseEvent | StandardKeyboardEvent): void {\n\t\t\tlet target: HTMLElement | null = event.target;\n\t\t\tif (target.tagName !== 'A') {\n\t\t\t\ttarget = target.parentElement;\n\t\t\t\tif (!target || target.tagName !== 'A') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tlet href = target.dataset['href'];\n\t\t\t\tif (href) {\n\t\t\t\t\tif (markdown.baseUri) {\n\t\t\t\t\t\thref = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n\t\t\t\t\t}\n\t\t\t\t\toptions.actionHandler!.callback(href, event);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tonUnexpectedError(err);\n\t\t\t} finally {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t};\n\t\tconst onClick = options.actionHandler.disposables.add(new DomEmitter(element, 'click'));\n\t\tconst onAuxClick = options.actionHandler.disposables.add(new DomEmitter(element, 'auxclick'));\n\t\toptions.actionHandler.disposables.add(Event.any(onClick.event, onAuxClick.event)(e => {\n\t\t\tconst mouseEvent = new StandardMouseEvent(DOM.getWindow(element), e);\n\t\t\tif (!mouseEvent.leftButton && !mouseEvent.middleButton) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t_activateLink(mouseEvent);\n\t\t}));\n\t\toptions.actionHandler.disposables.add(DOM.addDisposableListener(element, 'keydown', (e) => {\n\t\t\tconst keyboardEvent = new StandardKeyboardEvent(e);\n\t\t\tif (!keyboardEvent.equals(KeyCode.Space) && !keyboardEvent.equals(KeyCode.Enter)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t_activateLink(keyboardEvent);\n\t\t}));\n\t}\n\n\tif (!markdown.supportHtml) {\n\t\t// TODO: Can we deprecated this in favor of 'supportHtml'?\n\n\t\t// Use our own sanitizer so that we can let through only spans.\n\t\t// Otherwise, we'd be letting all html be rendered.\n\t\t// If we want to allow markdown permitted tags, then we can delete sanitizer and sanitize.\n\t\t// We always pass the output through dompurify after this so that we don't rely on\n\t\t// marked for sanitization.\n\t\tmarkedOptions.sanitizer = (html: string): string => {\n\t\t\tconst match = markdown.isTrusted ? html.match(/^(<span[^>]+>)|(<\\/\\s*span>)$/) : undefined;\n\t\t\treturn match ? html : '';\n\t\t};\n\t\tmarkedOptions.sanitize = true;\n\t\tmarkedOptions.silent = true;\n\t}\n\n\tmarkedOptions.renderer = renderer;\n\n\t// values that are too long will freeze the UI\n\tlet value = markdown.value ?? '';\n\tif (value.length > 100_000) {\n\t\tvalue = `${value.substr(0, 100_000)}…`;\n\t}\n\t// escape theme icons\n\tif (markdown.supportThemeIcons) {\n\t\tvalue = markdownEscapeEscapedIcons(value);\n\t}\n\n\tlet renderedMarkdown: string;\n\tif (options.fillInIncompleteTokens) {\n\t\t// The defaults are applied by parse but not lexer()/parser(), and they need to be present\n\t\tconst opts = {\n\t\t\t...marked.defaults,\n\t\t\t...markedOptions\n\t\t};\n\t\tconst tokens = marked.lexer(value, opts);\n\t\tconst newTokens = fillInIncompleteTokens(tokens);\n\t\trenderedMarkdown = marked.parser(newTokens, opts);\n\t} else {\n\t\trenderedMarkdown = marked.parse(value, markedOptions);\n\t}\n\n\t// Rewrite theme icons\n\tif (markdown.supportThemeIcons) {\n\t\tconst elements = renderLabelWithIcons(renderedMarkdown);\n\t\trenderedMarkdown = elements.map(e => typeof e === 'string' ? e : e.outerHTML).join('');\n\t}\n\n\tconst htmlParser = new DOMParser();\n\tconst markdownHtmlDoc = htmlParser.parseFromString(sanitizeRenderedMarkdown(markdown, renderedMarkdown) as unknown as string, 'text/html');\n\n\tmarkdownHtmlDoc.body.querySelectorAll('img')\n\t\t.forEach(img => {\n\t\t\tconst src = img.getAttribute('src'); // Get the raw 'src' attribute value as text, not the resolved 'src'\n\t\t\tif (src) {\n\t\t\t\tlet href = src;\n\t\t\t\ttry {\n\t\t\t\t\tif (markdown.baseUri) { // absolute or relative local path, or file: uri\n\t\t\t\t\t\thref = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n\t\t\t\t\t}\n\t\t\t\t} catch (err) { }\n\n\t\t\t\timg.src = _href(href, true);\n\t\t\t}\n\t\t});\n\n\tmarkdownHtmlDoc.body.querySelectorAll('a')\n\t\t.forEach(a => {\n\t\t\tconst href = a.getAttribute('href'); // Get the raw 'href' attribute value as text, not the resolved 'href'\n\t\t\ta.setAttribute('href', ''); // Clear out href. We use the `data-href` for handling clicks instead\n\t\t\tif (\n\t\t\t\t!href\n\t\t\t\t|| /^data:|javascript:/i.test(href)\n\t\t\t\t|| (/^command:/i.test(href) && !markdown.isTrusted)\n\t\t\t\t|| /^command:(\\/\\/\\/)?_workbench\\.downloadResource/i.test(href)\n\t\t\t) {\n\t\t\t\t// drop the link\n\t\t\t\ta.replaceWith(...a.childNodes);\n\t\t\t} else {\n\t\t\t\tlet resolvedHref = _href(href, false);\n\t\t\t\tif (markdown.baseUri) {\n\t\t\t\t\tresolvedHref = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n\t\t\t\t}\n\t\t\t\ta.dataset.href = resolvedHref;\n\t\t\t}\n\t\t});\n\n\telement.innerHTML = sanitizeRenderedMarkdown(markdown, markdownHtmlDoc.body.innerHTML) as unknown as string;\n\n\tif (codeBlocks.length > 0) {\n\t\tPromise.all(codeBlocks).then((tuples) => {\n\t\t\tif (isDisposed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst renderedElements = new Map(tuples);\n\t\t\tconst placeholderElements = element.querySelectorAll<HTMLDivElement>(`div[data-code]`);\n\t\t\tfor (const placeholderElement of placeholderElements) {\n\t\t\t\tconst renderedElement = renderedElements.get(placeholderElement.dataset['code'] ?? '');\n\t\t\t\tif (renderedElement) {\n\t\t\t\t\tDOM.reset(placeholderElement, renderedElement);\n\t\t\t\t}\n\t\t\t}\n\t\t\toptions.asyncRenderCallback?.();\n\t\t});\n\t} else if (syncCodeBlocks.length > 0) {\n\t\tconst renderedElements = new Map(syncCodeBlocks);\n\t\tconst placeholderElements = element.querySelectorAll<HTMLDivElement>(`div[data-code]`);\n\t\tfor (const placeholderElement of placeholderElements) {\n\t\t\tconst renderedElement = renderedElements.get(placeholderElement.dataset['code'] ?? '');\n\t\t\tif (renderedElement) {\n\t\t\t\tDOM.reset(placeholderElement, renderedElement);\n\t\t\t}\n\t\t}\n\t}\n\n\t// signal size changes for image tags\n\tif (options.asyncRenderCallback) {\n\t\tfor (const img of element.getElementsByTagName('img')) {\n\t\t\tconst listener = disposables.add(DOM.addDisposableListener(img, 'load', () => {\n\t\t\t\tlistener.dispose();\n\t\t\t\toptions.asyncRenderCallback!();\n\t\t\t}));\n\t\t}\n\t}\n\n\treturn {\n\t\telement,\n\t\tdispose: () => {\n\t\t\tisDisposed = true;\n\t\t\tdisposables.dispose();\n\t\t}\n\t};\n}\n\nfunction postProcessCodeBlockLanguageId(lang: string | undefined): string {\n\tif (!lang) {\n\t\treturn '';\n\t}\n\n\tconst parts = lang.split(/[\\s+|:|,|\\{|\\?]/, 1);\n\tif (parts.length) {\n\t\treturn parts[0];\n\t}\n\treturn lang;\n}\n\nfunction resolveWithBaseUri(baseUri: URI, href: string): string {\n\tconst hasScheme = /^\\w[\\w\\d+.-]*:/.test(href);\n\tif (hasScheme) {\n\t\treturn href;\n\t}\n\n\tif (baseUri.path.endsWith('/')) {\n\t\treturn resolvePath(baseUri, href).toString();\n\t} else {\n\t\treturn resolvePath(dirname(baseUri), href).toString();\n\t}\n}\n\nfunction sanitizeRenderedMarkdown(\n\toptions: { isTrusted?: boolean | MarkdownStringTrustedOptions },\n\trenderedMarkdown: string,\n): TrustedHTML {\n\tconst { config, allowedSchemes } = getSanitizerOptions(options);\n\tdompurify.addHook('uponSanitizeAttribute', (element, e) => {\n\t\tif (e.attrName === 'style' || e.attrName === 'class') {\n\t\t\tif (element.tagName === 'SPAN') {\n\t\t\t\tif (e.attrName === 'style') {\n\t\t\t\t\te.keepAttr = /^(color\\:(#[0-9a-fA-F]+|var\\(--vscode(-[a-zA-Z]+)+\\));)?(background-color\\:(#[0-9a-fA-F]+|var\\(--vscode(-[a-zA-Z]+)+\\));)?$/.test(e.attrValue);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (e.attrName === 'class') {\n\t\t\t\t\te.keepAttr = /^codicon codicon-[a-z\\-]+( codicon-modifier-[a-z\\-]+)?$/.test(e.attrValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\te.keepAttr = false;\n\t\t\treturn;\n\t\t} else if (element.tagName === 'INPUT' && element.attributes.getNamedItem('type')?.value === 'checkbox') {\n\t\t\tif ((e.attrName === 'type' && e.attrValue === 'checkbox') || e.attrName === 'disabled' || e.attrName === 'checked') {\n\t\t\t\te.keepAttr = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\te.keepAttr = false;\n\t\t}\n\t});\n\n\tdompurify.addHook('uponSanitizeElement', (element, e) => {\n\t\tif (e.tagName === 'input') {\n\t\t\tif (element.attributes.getNamedItem('type')?.value === 'checkbox') {\n\t\t\t\telement.setAttribute('disabled', '');\n\t\t\t} else {\n\t\t\t\telement.parentElement?.removeChild(element);\n\t\t\t}\n\t\t}\n\t});\n\n\n\tconst hook = DOM.hookDomPurifyHrefAndSrcSanitizer(allowedSchemes);\n\n\ttry {\n\t\treturn dompurify.sanitize(renderedMarkdown, { ...config, RETURN_TRUSTED_TYPE: true });\n\t} finally {\n\t\tdompurify.removeHook('uponSanitizeAttribute');\n\t\thook.dispose();\n\t}\n}\n\nexport const allowedMarkdownAttr = [\n\t'align',\n\t'autoplay',\n\t'alt',\n\t'checked',\n\t'class',\n\t'controls',\n\t'data-code',\n\t'data-href',\n\t'disabled',\n\t'draggable',\n\t'height',\n\t'href',\n\t'loop',\n\t'muted',\n\t'playsinline',\n\t'poster',\n\t'src',\n\t'style',\n\t'target',\n\t'title',\n\t'type',\n\t'width',\n\t'start',\n];\n\nfunction getSanitizerOptions(options: { readonly isTrusted?: boolean | MarkdownStringTrustedOptions }): { config: dompurify.Config; allowedSchemes: string[] } {\n\tconst allowedSchemes = [\n\t\tSchemas.http,\n\t\tSchemas.https,\n\t\tSchemas.mailto,\n\t\tSchemas.data,\n\t\tSchemas.file,\n\t\tSchemas.vscodeFileResource,\n\t\tSchemas.vscodeRemote,\n\t\tSchemas.vscodeRemoteResource,\n\t];\n\n\tif (options.isTrusted) {\n\t\tallowedSchemes.push(Schemas.command);\n\t}\n\n\treturn {\n\t\tconfig: {\n\t\t\t// allowedTags should included everything that markdown renders to.\n\t\t\t// Since we have our own sanitize function for marked, it's possible we missed some tag so let dompurify make sure.\n\t\t\t// HTML tags that can result from markdown are from reading https://spec.commonmark.org/0.29/\n\t\t\t// HTML table tags that can result from markdown are from https://github.github.com/gfm/#tables-extension-\n\t\t\tALLOWED_TAGS: [...DOM.basicMarkupHtmlTags],\n\t\t\tALLOWED_ATTR: allowedMarkdownAttr,\n\t\t\tALLOW_UNKNOWN_PROTOCOLS: true,\n\t\t},\n\t\tallowedSchemes\n\t};\n}\n\n/**\n * Strips all markdown from `string`, if it's an IMarkdownString. For example\n * `# Header` would be output as `Header`. If it's not, the string is returned.\n */\nexport function renderStringAsPlaintext(string: IMarkdownString | string) {\n\treturn typeof string === 'string' ? string : renderMarkdownAsPlaintext(string);\n}\n\n/**\n * Strips all markdown from `markdown`. For example `# Header` would be output as `Header`.\n */\nexport function renderMarkdownAsPlaintext(markdown: IMarkdownString) {\n\t// values that are too long will freeze the UI\n\tlet value = markdown.value ?? '';\n\tif (value.length > 100_000) {\n\t\tvalue = `${value.substr(0, 100_000)}…`;\n\t}\n\n\tconst html = marked.parse(value, { renderer: plainTextRenderer.value }).replace(/&(#\\d+|[a-zA-Z]+);/g, m => unescapeInfo.get(m) ?? m);\n\n\treturn sanitizeRenderedMarkdown({ isTrusted: false }, html).toString();\n}\n\nconst unescapeInfo = new Map<string, string>([\n\t['&quot;', '\"'],\n\t['&nbsp;', ' '],\n\t['&amp;', '&'],\n\t['&#39;', '\\''],\n\t['&lt;', '<'],\n\t['&gt;', '>'],\n]);\n\nconst plainTextRenderer = new Lazy<marked.Renderer>(() => {\n\tconst renderer = new marked.Renderer();\n\n\trenderer.code = (code: string): string => {\n\t\treturn code;\n\t};\n\trenderer.blockquote = (quote: string): string => {\n\t\treturn quote;\n\t};\n\trenderer.html = (_html: string): string => {\n\t\treturn '';\n\t};\n\trenderer.heading = (text: string, _level: 1 | 2 | 3 | 4 | 5 | 6, _raw: string): string => {\n\t\treturn text + '\\n';\n\t};\n\trenderer.hr = (): string => {\n\t\treturn '';\n\t};\n\trenderer.list = (body: string, _ordered: boolean): string => {\n\t\treturn body;\n\t};\n\trenderer.listitem = (text: string): string => {\n\t\treturn text + '\\n';\n\t};\n\trenderer.paragraph = (text: string): string => {\n\t\treturn text + '\\n';\n\t};\n\trenderer.table = (header: string, body: string): string => {\n\t\treturn header + body + '\\n';\n\t};\n\trenderer.tablerow = (content: string): string => {\n\t\treturn content;\n\t};\n\trenderer.tablecell = (content: string, _flags: {\n\t\theader: boolean;\n\t\talign: 'center' | 'left' | 'right' | null;\n\t}): string => {\n\t\treturn content + ' ';\n\t};\n\trenderer.strong = (text: string): string => {\n\t\treturn text;\n\t};\n\trenderer.em = (text: string): string => {\n\t\treturn text;\n\t};\n\trenderer.codespan = (code: string): string => {\n\t\treturn code;\n\t};\n\trenderer.br = (): string => {\n\t\treturn '\\n';\n\t};\n\trenderer.del = (text: string): string => {\n\t\treturn text;\n\t};\n\trenderer.image = (_href: string, _title: string, _text: string): string => {\n\t\treturn '';\n\t};\n\trenderer.text = (text: string): string => {\n\t\treturn text;\n\t};\n\trenderer.link = (_href: string, _title: string, text: string): string => {\n\t\treturn text;\n\t};\n\treturn renderer;\n});\n\nfunction mergeRawTokenText(tokens: marked.Token[]): string {\n\tlet mergedTokenText = '';\n\ttokens.forEach(token => {\n\t\tmergedTokenText += token.raw;\n\t});\n\treturn mergedTokenText;\n}\n\nfunction completeSingleLinePattern(token: marked.Tokens.ListItem | marked.Tokens.Paragraph): marked.Token | undefined {\n\tfor (let i = 0; i < token.tokens.length; i++) {\n\t\tconst subtoken = token.tokens[i];\n\t\tif (subtoken.type === 'text') {\n\t\t\tconst lines = subtoken.raw.split('\\n');\n\t\t\tconst lastLine = lines[lines.length - 1];\n\t\t\tif (lastLine.includes('`')) {\n\t\t\t\treturn completeCodespan(token);\n\t\t\t} else if (lastLine.includes('**')) {\n\t\t\t\treturn completeDoublestar(token);\n\t\t\t} else if (lastLine.match(/\\*\\w/)) {\n\t\t\t\treturn completeStar(token);\n\t\t\t} else if (lastLine.match(/(^|\\s)__\\w/)) {\n\t\t\t\treturn completeDoubleUnderscore(token);\n\t\t\t} else if (lastLine.match(/(^|\\s)_\\w/)) {\n\t\t\t\treturn completeUnderscore(token);\n\t\t\t} else if (lastLine.match(/(^|\\s)\\[.*\\]\\(\\w*/)) {\n\t\t\t\tconst nextTwoSubTokens = token.tokens.slice(i + 1);\n\t\t\t\tif (nextTwoSubTokens[0]?.type === 'link' && nextTwoSubTokens[1]?.type === 'text' && nextTwoSubTokens[1].raw.match(/^ *\"[^\"]*$/)) {\n\t\t\t\t\t// A markdown link can look like\n\t\t\t\t\t// [link text](https://microsoft.com \"more text\")\n\t\t\t\t\t// Where \"more text\" is a title for the link or an argument to a vscode command link\n\t\t\t\t\treturn completeLinkTargetArg(token);\n\t\t\t\t}\n\t\t\t\treturn completeLinkTarget(token);\n\t\t\t} else if (hasStartOfLinkTarget(lastLine)) {\n\t\t\t\treturn completeLinkTarget(token);\n\t\t\t} else if (lastLine.match(/(^|\\s)\\[\\w/) && !token.tokens.slice(i + 1).some(t => hasStartOfLinkTarget(t.raw))) {\n\t\t\t\treturn completeLinkText(token);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nfunction hasStartOfLinkTarget(str: string): boolean {\n\treturn !!str.match(/^[^\\[]*\\]\\([^\\)]*$/);\n}\n\n// function completeListItemPattern(token: marked.Tokens.List): marked.Tokens.List | undefined {\n// \t// Patch up this one list item\n// \tconst lastItem = token.items[token.items.length - 1];\n\n// \tconst newList = completeSingleLinePattern(lastItem);\n// \tif (!newList || newList.type !== 'list') {\n// \t\t// Nothing to fix, or not a pattern we were expecting\n// \t\treturn;\n// \t}\n\n// \t// Re-parse the whole list with the last item replaced\n// \tconst completeList = marked.lexer(mergeRawTokenText(token.items.slice(0, token.items.length - 1)) + newList.items[0].raw);\n// \tif (completeList.length === 1 && completeList[0].type === 'list') {\n// \t\treturn completeList[0];\n// \t}\n\n// \t// Not a pattern we were expecting\n// \treturn undefined;\n// }\n\nexport function fillInIncompleteTokens(tokens: marked.TokensList): marked.TokensList {\n\tlet i: number;\n\tlet newTokens: marked.Token[] | undefined;\n\tfor (i = 0; i < tokens.length; i++) {\n\t\tconst token = tokens[i];\n\t\tlet codeblockStart: RegExpMatchArray | null;\n\t\tif (token.type === 'paragraph' && (codeblockStart = token.raw.match(/(\\n|^)(````*)/))) {\n\t\t\tconst codeblockLead = codeblockStart[2];\n\t\t\t// If the code block was complete, it would be in a type='code'\n\t\t\tnewTokens = completeCodeBlock(tokens.slice(i), codeblockLead);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (token.type === 'paragraph' && token.raw.match(/(\\n|^)\\|/)) {\n\t\t\tnewTokens = completeTable(tokens.slice(i));\n\t\t\tbreak;\n\t\t}\n\n\t\t// if (i === tokens.length - 1 && token.type === 'list') {\n\t\t// \tconst newListToken = completeListItemPattern(token);\n\t\t// \tif (newListToken) {\n\t\t// \t\tnewTokens = [newListToken];\n\t\t// \t\tbreak;\n\t\t// \t}\n\t\t// }\n\n\t\tif (i === tokens.length - 1 && token.type === 'paragraph') {\n\t\t\t// Only operates on a single token, because any newline that follows this should break these patterns\n\t\t\tconst newToken = completeSingleLinePattern(token);\n\t\t\tif (newToken) {\n\t\t\t\tnewTokens = [newToken];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (newTokens) {\n\t\tconst newTokensList = [\n\t\t\t...tokens.slice(0, i),\n\t\t\t...newTokens\n\t\t];\n\t\t(newTokensList as marked.TokensList).links = tokens.links;\n\t\treturn newTokensList as marked.TokensList;\n\t}\n\n\treturn tokens;\n}\n\nfunction completeCodeBlock(tokens: marked.Token[], leader: string): marked.Token[] {\n\tconst mergedRawText = mergeRawTokenText(tokens);\n\treturn marked.lexer(mergedRawText + `\\n${leader}`);\n}\n\nfunction completeCodespan(token: marked.Token): marked.Token {\n\treturn completeWithString(token, '`');\n}\n\nfunction completeStar(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '*');\n}\n\nfunction completeUnderscore(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '_');\n}\n\nfunction completeLinkTarget(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, ')');\n}\n\nfunction completeLinkTargetArg(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '\")');\n}\n\nfunction completeLinkText(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '](about:blank)');\n}\n\nfunction completeDoublestar(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '**');\n}\n\nfunction completeDoubleUnderscore(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '__');\n}\n\nfunction completeWithString(tokens: marked.Token[] | marked.Token, closingString: string): marked.Token {\n\tconst mergedRawText = mergeRawTokenText(Array.isArray(tokens) ? tokens : [tokens]);\n\n\t// If it was completed correctly, this should be a single token.\n\t// Expecting either a Paragraph or a List\n\treturn marked.lexer(mergedRawText + closingString)[0] as marked.Token;\n}\n\nfunction completeTable(tokens: marked.Token[]): marked.Token[] | undefined {\n\tconst mergedRawText = mergeRawTokenText(tokens);\n\tconst lines = mergedRawText.split('\\n');\n\n\tlet numCols: number | undefined; // The number of line1 col headers\n\tlet hasSeparatorRow = false;\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tconst line = lines[i].trim();\n\t\tif (typeof numCols === 'undefined' && line.match(/^\\s*\\|/)) {\n\t\t\tconst line1Matches = line.match(/(\\|[^\\|]+)(?=\\||$)/g);\n\t\t\tif (line1Matches) {\n\t\t\t\tnumCols = line1Matches.length;\n\t\t\t}\n\t\t} else if (typeof numCols === 'number') {\n\t\t\tif (line.match(/^\\s*\\|/)) {\n\t\t\t\tif (i !== lines.length - 1) {\n\t\t\t\t\t// We got the line1 header row, and the line2 separator row, but there are more lines, and it wasn't parsed as a table!\n\t\t\t\t\t// That's strange and means that the table is probably malformed in the source, so I won't try to patch it up.\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// Got a line2 separator row- partial or complete, doesn't matter, we'll replace it with a correct one\n\t\t\t\thasSeparatorRow = true;\n\t\t\t} else {\n\t\t\t\t// The line after the header row isn't a valid separator row, so the table is malformed, don't fix it up\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (typeof numCols === 'number' && numCols > 0) {\n\t\tconst prefixText = hasSeparatorRow ? lines.slice(0, -1).join('\\n') : mergedRawText;\n\t\tconst line1EndsInPipe = !!prefixText.match(/\\|\\s*$/);\n\t\tconst newRawText = prefixText + (line1EndsInPipe ? '' : '|') + `\\n|${' --- |'.repeat(numCols)}`;\n\t\treturn marked.lexer(newRawText);\n\t}\n\n\treturn undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as DOM from './dom';\nimport * as dompurify from './dompurify/dompurify';\nimport { DomEmitter } from './event';\nimport { createElement, FormattedTextRenderOptions } from './formattedTextRenderer';\nimport { StandardKeyboardEvent } from './keyboardEvent';\nimport { StandardMouseEvent } from './mouseEvent';\nimport { renderLabelWithIcons } from './ui/iconLabel/iconLabels';\nimport { onUnexpectedError } from '../common/errors';\nimport { Event } from '../common/event';\nimport { escapeDoubleQuotes, IMarkdownString, MarkdownStringTrustedOptions, parseHrefAndDimensions, removeMarkdownEscapes } from '../common/htmlContent';\nimport { markdownEscapeEscapedIcons } from '../common/iconLabels';\nimport { defaultGenerator } from '../common/idGenerator';\nimport { KeyCode } from '../common/keyCodes';\nimport { Lazy } from '../common/lazy';\nimport { DisposableStore } from '../common/lifecycle';\nimport { marked } from '../common/marked/marked';\nimport { parse } from '../common/marshalling';\nimport { FileAccess, Schemas } from '../common/network';\nimport { cloneAndChange } from '../common/objects';\nimport { dirname, resolvePath } from '../common/resources';\nimport { escape } from '../common/strings';\nimport { URI } from '../common/uri';\n\nexport interface MarkedOptions extends marked.MarkedOptions {\n\tbaseUrl?: never;\n}\n\nexport interface MarkdownRenderOptions extends FormattedTextRenderOptions {\n\treadonly codeBlockRenderer?: (languageId: string, value: string) => Promise<HTMLElement>;\n\treadonly codeBlockRendererSync?: (languageId: string, value: string) => HTMLElement;\n\treadonly asyncRenderCallback?: () => void;\n\treadonly fillInIncompleteTokens?: boolean;\n}\n\nconst defaultMarkedRenderers = Object.freeze({\n\timage: (href: string | null, title: string | null, text: string): string => {\n\t\tlet dimensions: string[] = [];\n\t\tlet attributes: string[] = [];\n\t\tif (href) {\n\t\t\t({ href, dimensions } = parseHrefAndDimensions(href));\n\t\t\tattributes.push(`src=\"${escapeDoubleQuotes(href)}\"`);\n\t\t}\n\t\tif (text) {\n\t\t\tattributes.push(`alt=\"${escapeDoubleQuotes(text)}\"`);\n\t\t}\n\t\tif (title) {\n\t\t\tattributes.push(`title=\"${escapeDoubleQuotes(title)}\"`);\n\t\t}\n\t\tif (dimensions.length) {\n\t\t\tattributes = attributes.concat(dimensions);\n\t\t}\n\t\treturn '<img ' + attributes.join(' ') + '>';\n\t},\n\n\tparagraph: (text: string): string => {\n\t\treturn `<p>${text}</p>`;\n\t},\n\n\tlink: (href: string | null, title: string | null, text: string): string => {\n\t\tif (typeof href !== 'string') {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Remove markdown escapes. Workaround for https://github.com/chjj/marked/issues/829\n\t\tif (href === text) { // raw link case\n\t\t\ttext = removeMarkdownEscapes(text);\n\t\t}\n\n\t\ttitle = typeof title === 'string' ? escapeDoubleQuotes(removeMarkdownEscapes(title)) : '';\n\t\thref = removeMarkdownEscapes(href);\n\n\t\t// HTML Encode href\n\t\thref = href.replace(/&/g, '&amp;')\n\t\t\t.replace(/</g, '&lt;')\n\t\t\t.replace(/>/g, '&gt;')\n\t\t\t.replace(/\"/g, '&quot;')\n\t\t\t.replace(/'/g, '&#39;');\n\n\t\treturn `<a href=\"${href}\" title=\"${title || href}\" draggable=\"false\">${text}</a>`;\n\t},\n});\n\n/**\n * Low-level way create a html element from a markdown string.\n *\n * **Note** that for most cases you should be using [`MarkdownRenderer`](./src/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.ts)\n * which comes with support for pretty code block rendering and which uses the default way of handling links.\n */\nexport function renderMarkdown(markdown: IMarkdownString, options: MarkdownRenderOptions = {}, markedOptions: MarkedOptions = {}): { element: HTMLElement; dispose: () => void } {\n\tconst disposables = new DisposableStore();\n\tlet isDisposed = false;\n\n\tconst element = createElement(options);\n\n\tconst _uriMassage = function (part: string): string {\n\t\tlet data: any;\n\t\ttry {\n\t\t\tdata = parse(decodeURIComponent(part));\n\t\t} catch (e) {\n\t\t\t// ignore\n\t\t}\n\t\tif (!data) {\n\t\t\treturn part;\n\t\t}\n\t\tdata = cloneAndChange(data, value => {\n\t\t\tif (markdown.uris && markdown.uris[value]) {\n\t\t\t\treturn URI.revive(markdown.uris[value]);\n\t\t\t} else {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t});\n\t\treturn encodeURIComponent(JSON.stringify(data));\n\t};\n\n\tconst _href = function (href: string, isDomUri: boolean): string {\n\t\tconst data = markdown.uris && markdown.uris[href];\n\t\tlet uri = URI.revive(data);\n\t\tif (isDomUri) {\n\t\t\tif (href.startsWith(Schemas.data + ':')) {\n\t\t\t\treturn href;\n\t\t\t}\n\t\t\tif (!uri) {\n\t\t\t\turi = URI.parse(href);\n\t\t\t}\n\t\t\t// this URI will end up as \"src\"-attribute of a dom node\n\t\t\t// and because of that special rewriting needs to be done\n\t\t\t// so that the URI uses a protocol that's understood by\n\t\t\t// browsers (like http or https)\n\t\t\treturn FileAccess.uriToBrowserUri(uri).toString(true);\n\t\t}\n\t\tif (!uri) {\n\t\t\treturn href;\n\t\t}\n\t\tif (URI.parse(href).toString() === uri.toString()) {\n\t\t\treturn href; // no transformation performed\n\t\t}\n\t\tif (uri.query) {\n\t\t\turi = uri.with({ query: _uriMassage(uri.query) });\n\t\t}\n\t\treturn uri.toString();\n\t};\n\n\tconst renderer = new marked.Renderer();\n\trenderer.image = defaultMarkedRenderers.image;\n\trenderer.link = defaultMarkedRenderers.link;\n\trenderer.paragraph = defaultMarkedRenderers.paragraph;\n\n\t// Will collect [id, renderedElement] tuples\n\tconst codeBlocks: Promise<[string, HTMLElement]>[] = [];\n\tconst syncCodeBlocks: [string, HTMLElement][] = [];\n\n\tif (options.codeBlockRendererSync) {\n\t\trenderer.code = (code, lang) => {\n\t\t\tconst id = defaultGenerator.nextId();\n\t\t\tconst value = options.codeBlockRendererSync!(postProcessCodeBlockLanguageId(lang), code);\n\t\t\tsyncCodeBlocks.push([id, value]);\n\t\t\treturn `<div class=\"code\" data-code=\"${id}\">${escape(code)}</div>`;\n\t\t};\n\t} else if (options.codeBlockRenderer) {\n\t\trenderer.code = (code, lang) => {\n\t\t\tconst id = defaultGenerator.nextId();\n\t\t\tconst value = options.codeBlockRenderer!(postProcessCodeBlockLanguageId(lang), code);\n\t\t\tcodeBlocks.push(value.then(element => [id, element]));\n\t\t\treturn `<div class=\"code\" data-code=\"${id}\">${escape(code)}</div>`;\n\t\t};\n\t}\n\n\tif (options.actionHandler) {\n\t\tconst _activateLink = function (event: StandardMouseEvent | StandardKeyboardEvent): void {\n\t\t\tlet target: HTMLElement | null = event.target;\n\t\t\tif (target.tagName !== 'A') {\n\t\t\t\ttarget = target.parentElement;\n\t\t\t\tif (!target || target.tagName !== 'A') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tlet href = target.dataset['href'];\n\t\t\t\tif (href) {\n\t\t\t\t\tif (markdown.baseUri) {\n\t\t\t\t\t\thref = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n\t\t\t\t\t}\n\t\t\t\t\toptions.actionHandler!.callback(href, event);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tonUnexpectedError(err);\n\t\t\t} finally {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t};\n\t\tconst onClick = options.actionHandler.disposables.add(new DomEmitter(element, 'click'));\n\t\tconst onAuxClick = options.actionHandler.disposables.add(new DomEmitter(element, 'auxclick'));\n\t\toptions.actionHandler.disposables.add(Event.any(onClick.event, onAuxClick.event)(e => {\n\t\t\tconst mouseEvent = new StandardMouseEvent(DOM.getWindow(element), e);\n\t\t\tif (!mouseEvent.leftButton && !mouseEvent.middleButton) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t_activateLink(mouseEvent);\n\t\t}));\n\t\toptions.actionHandler.disposables.add(DOM.addDisposableListener(element, 'keydown', (e) => {\n\t\t\tconst keyboardEvent = new StandardKeyboardEvent(e);\n\t\t\tif (!keyboardEvent.equals(KeyCode.Space) && !keyboardEvent.equals(KeyCode.Enter)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t_activateLink(keyboardEvent);\n\t\t}));\n\t}\n\n\tif (!markdown.supportHtml) {\n\t\t// TODO: Can we deprecated this in favor of 'supportHtml'?\n\n\t\t// Use our own sanitizer so that we can let through only spans.\n\t\t// Otherwise, we'd be letting all html be rendered.\n\t\t// If we want to allow markdown permitted tags, then we can delete sanitizer and sanitize.\n\t\t// We always pass the output through dompurify after this so that we don't rely on\n\t\t// marked for sanitization.\n\t\tmarkedOptions.sanitizer = (html: string): string => {\n\t\t\tconst match = markdown.isTrusted ? html.match(/^(<span[^>]+>)|(<\\/\\s*span>)$/) : undefined;\n\t\t\treturn match ? html : '';\n\t\t};\n\t\tmarkedOptions.sanitize = true;\n\t\tmarkedOptions.silent = true;\n\t}\n\n\tmarkedOptions.renderer = renderer;\n\n\t// values that are too long will freeze the UI\n\tlet value = markdown.value ?? '';\n\tif (value.length > 100_000) {\n\t\tvalue = `${value.substr(0, 100_000)}…`;\n\t}\n\t// escape theme icons\n\tif (markdown.supportThemeIcons) {\n\t\tvalue = markdownEscapeEscapedIcons(value);\n\t}\n\n\tlet renderedMarkdown: string;\n\tif (options.fillInIncompleteTokens) {\n\t\t// The defaults are applied by parse but not lexer()/parser(), and they need to be present\n\t\tconst opts = {\n\t\t\t...marked.defaults,\n\t\t\t...markedOptions\n\t\t};\n\t\tconst tokens = marked.lexer(value, opts);\n\t\tconst newTokens = fillInIncompleteTokens(tokens);\n\t\trenderedMarkdown = marked.parser(newTokens, opts);\n\t} else {\n\t\trenderedMarkdown = marked.parse(value, markedOptions);\n\t}\n\n\t// Rewrite theme icons\n\tif (markdown.supportThemeIcons) {\n\t\tconst elements = renderLabelWithIcons(renderedMarkdown);\n\t\trenderedMarkdown = elements.map(e => typeof e === 'string' ? e : e.outerHTML).join('');\n\t}\n\n\tconst htmlParser = new DOMParser();\n\tconst markdownHtmlDoc = htmlParser.parseFromString(sanitizeRenderedMarkdown(markdown, renderedMarkdown) as unknown as string, 'text/html');\n\n\tmarkdownHtmlDoc.body.querySelectorAll('img')\n\t\t.forEach(img => {\n\t\t\tconst src = img.getAttribute('src'); // Get the raw 'src' attribute value as text, not the resolved 'src'\n\t\t\tif (src) {\n\t\t\t\tlet href = src;\n\t\t\t\ttry {\n\t\t\t\t\tif (markdown.baseUri) { // absolute or relative local path, or file: uri\n\t\t\t\t\t\thref = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n\t\t\t\t\t}\n\t\t\t\t} catch (err) { }\n\n\t\t\t\timg.src = _href(href, true);\n\t\t\t}\n\t\t});\n\n\tmarkdownHtmlDoc.body.querySelectorAll('a')\n\t\t.forEach(a => {\n\t\t\tconst href = a.getAttribute('href'); // Get the raw 'href' attribute value as text, not the resolved 'href'\n\t\t\ta.setAttribute('href', ''); // Clear out href. We use the `data-href` for handling clicks instead\n\t\t\tif (\n\t\t\t\t!href\n\t\t\t\t|| /^data:|javascript:/i.test(href)\n\t\t\t\t|| (/^command:/i.test(href) && !markdown.isTrusted)\n\t\t\t\t|| /^command:(\\/\\/\\/)?_workbench\\.downloadResource/i.test(href)\n\t\t\t) {\n\t\t\t\t// drop the link\n\t\t\t\ta.replaceWith(...a.childNodes);\n\t\t\t} else {\n\t\t\t\tlet resolvedHref = _href(href, false);\n\t\t\t\tif (markdown.baseUri) {\n\t\t\t\t\tresolvedHref = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n\t\t\t\t}\n\t\t\t\ta.dataset.href = resolvedHref;\n\t\t\t}\n\t\t});\n\n\telement.innerHTML = sanitizeRenderedMarkdown(markdown, markdownHtmlDoc.body.innerHTML) as unknown as string;\n\n\tif (codeBlocks.length > 0) {\n\t\tPromise.all(codeBlocks).then((tuples) => {\n\t\t\tif (isDisposed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst renderedElements = new Map(tuples);\n\t\t\tconst placeholderElements = element.querySelectorAll<HTMLDivElement>(`div[data-code]`);\n\t\t\tfor (const placeholderElement of placeholderElements) {\n\t\t\t\tconst renderedElement = renderedElements.get(placeholderElement.dataset['code'] ?? '');\n\t\t\t\tif (renderedElement) {\n\t\t\t\t\tDOM.reset(placeholderElement, renderedElement);\n\t\t\t\t}\n\t\t\t}\n\t\t\toptions.asyncRenderCallback?.();\n\t\t});\n\t} else if (syncCodeBlocks.length > 0) {\n\t\tconst renderedElements = new Map(syncCodeBlocks);\n\t\tconst placeholderElements = element.querySelectorAll<HTMLDivElement>(`div[data-code]`);\n\t\tfor (const placeholderElement of placeholderElements) {\n\t\t\tconst renderedElement = renderedElements.get(placeholderElement.dataset['code'] ?? '');\n\t\t\tif (renderedElement) {\n\t\t\t\tDOM.reset(placeholderElement, renderedElement);\n\t\t\t}\n\t\t}\n\t}\n\n\t// signal size changes for image tags\n\tif (options.asyncRenderCallback) {\n\t\tfor (const img of element.getElementsByTagName('img')) {\n\t\t\tconst listener = disposables.add(DOM.addDisposableListener(img, 'load', () => {\n\t\t\t\tlistener.dispose();\n\t\t\t\toptions.asyncRenderCallback!();\n\t\t\t}));\n\t\t}\n\t}\n\n\treturn {\n\t\telement,\n\t\tdispose: () => {\n\t\t\tisDisposed = true;\n\t\t\tdisposables.dispose();\n\t\t}\n\t};\n}\n\nfunction postProcessCodeBlockLanguageId(lang: string | undefined): string {\n\tif (!lang) {\n\t\treturn '';\n\t}\n\n\tconst parts = lang.split(/[\\s+|:|,|\\{|\\?]/, 1);\n\tif (parts.length) {\n\t\treturn parts[0];\n\t}\n\treturn lang;\n}\n\nfunction resolveWithBaseUri(baseUri: URI, href: string): string {\n\tconst hasScheme = /^\\w[\\w\\d+.-]*:/.test(href);\n\tif (hasScheme) {\n\t\treturn href;\n\t}\n\n\tif (baseUri.path.endsWith('/')) {\n\t\treturn resolvePath(baseUri, href).toString();\n\t} else {\n\t\treturn resolvePath(dirname(baseUri), href).toString();\n\t}\n}\n\nfunction sanitizeRenderedMarkdown(\n\toptions: { isTrusted?: boolean | MarkdownStringTrustedOptions },\n\trenderedMarkdown: string,\n): TrustedHTML {\n\tconst { config, allowedSchemes } = getSanitizerOptions(options);\n\tdompurify.addHook('uponSanitizeAttribute', (element, e) => {\n\t\tif (e.attrName === 'style' || e.attrName === 'class') {\n\t\t\tif (element.tagName === 'SPAN') {\n\t\t\t\tif (e.attrName === 'style') {\n\t\t\t\t\te.keepAttr = /^(color\\:(#[0-9a-fA-F]+|var\\(--vscode(-[a-zA-Z]+)+\\));)?(background-color\\:(#[0-9a-fA-F]+|var\\(--vscode(-[a-zA-Z]+)+\\));)?$/.test(e.attrValue);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (e.attrName === 'class') {\n\t\t\t\t\te.keepAttr = /^codicon codicon-[a-z\\-]+( codicon-modifier-[a-z\\-]+)?$/.test(e.attrValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\te.keepAttr = false;\n\t\t\treturn;\n\t\t} else if (element.tagName === 'INPUT' && element.attributes.getNamedItem('type')?.value === 'checkbox') {\n\t\t\tif ((e.attrName === 'type' && e.attrValue === 'checkbox') || e.attrName === 'disabled' || e.attrName === 'checked') {\n\t\t\t\te.keepAttr = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\te.keepAttr = false;\n\t\t}\n\t});\n\n\tdompurify.addHook('uponSanitizeElement', (element, e) => {\n\t\tif (e.tagName === 'input') {\n\t\t\tif (element.attributes.getNamedItem('type')?.value === 'checkbox') {\n\t\t\t\telement.setAttribute('disabled', '');\n\t\t\t} else {\n\t\t\t\telement.parentElement?.removeChild(element);\n\t\t\t}\n\t\t}\n\t});\n\n\n\tconst hook = DOM.hookDomPurifyHrefAndSrcSanitizer(allowedSchemes);\n\n\ttry {\n\t\treturn dompurify.sanitize(renderedMarkdown, { ...config, RETURN_TRUSTED_TYPE: true });\n\t} finally {\n\t\tdompurify.removeHook('uponSanitizeAttribute');\n\t\thook.dispose();\n\t}\n}\n\nexport const allowedMarkdownAttr = [\n\t'align',\n\t'autoplay',\n\t'alt',\n\t'checked',\n\t'class',\n\t'controls',\n\t'data-code',\n\t'data-href',\n\t'disabled',\n\t'draggable',\n\t'height',\n\t'href',\n\t'loop',\n\t'muted',\n\t'playsinline',\n\t'poster',\n\t'src',\n\t'style',\n\t'target',\n\t'title',\n\t'type',\n\t'width',\n\t'start',\n];\n\nfunction getSanitizerOptions(options: { readonly isTrusted?: boolean | MarkdownStringTrustedOptions }): { config: dompurify.Config; allowedSchemes: string[] } {\n\tconst allowedSchemes = [\n\t\tSchemas.http,\n\t\tSchemas.https,\n\t\tSchemas.mailto,\n\t\tSchemas.data,\n\t\tSchemas.file,\n\t\tSchemas.vscodeFileResource,\n\t\tSchemas.vscodeRemote,\n\t\tSchemas.vscodeRemoteResource,\n\t];\n\n\tif (options.isTrusted) {\n\t\tallowedSchemes.push(Schemas.command);\n\t}\n\n\treturn {\n\t\tconfig: {\n\t\t\t// allowedTags should included everything that markdown renders to.\n\t\t\t// Since we have our own sanitize function for marked, it's possible we missed some tag so let dompurify make sure.\n\t\t\t// HTML tags that can result from markdown are from reading https://spec.commonmark.org/0.29/\n\t\t\t// HTML table tags that can result from markdown are from https://github.github.com/gfm/#tables-extension-\n\t\t\tALLOWED_TAGS: [...DOM.basicMarkupHtmlTags],\n\t\t\tALLOWED_ATTR: allowedMarkdownAttr,\n\t\t\tALLOW_UNKNOWN_PROTOCOLS: true,\n\t\t},\n\t\tallowedSchemes\n\t};\n}\n\n/**\n * Strips all markdown from `string`, if it's an IMarkdownString. For example\n * `# Header` would be output as `Header`. If it's not, the string is returned.\n */\nexport function renderStringAsPlaintext(string: IMarkdownString | string) {\n\treturn typeof string === 'string' ? string : renderMarkdownAsPlaintext(string);\n}\n\n/**\n * Strips all markdown from `markdown`. For example `# Header` would be output as `Header`.\n */\nexport function renderMarkdownAsPlaintext(markdown: IMarkdownString) {\n\t// values that are too long will freeze the UI\n\tlet value = markdown.value ?? '';\n\tif (value.length > 100_000) {\n\t\tvalue = `${value.substr(0, 100_000)}…`;\n\t}\n\n\tconst html = marked.parse(value, { renderer: plainTextRenderer.value }).replace(/&(#\\d+|[a-zA-Z]+);/g, m => unescapeInfo.get(m) ?? m);\n\n\treturn sanitizeRenderedMarkdown({ isTrusted: false }, html).toString();\n}\n\nconst unescapeInfo = new Map<string, string>([\n\t['&quot;', '\"'],\n\t['&nbsp;', ' '],\n\t['&amp;', '&'],\n\t['&#39;', '\\''],\n\t['&lt;', '<'],\n\t['&gt;', '>'],\n]);\n\nconst plainTextRenderer = new Lazy<marked.Renderer>(() => {\n\tconst renderer = new marked.Renderer();\n\n\trenderer.code = (code: string): string => {\n\t\treturn code;\n\t};\n\trenderer.blockquote = (quote: string): string => {\n\t\treturn quote;\n\t};\n\trenderer.html = (_html: string): string => {\n\t\treturn '';\n\t};\n\trenderer.heading = (text: string, _level: 1 | 2 | 3 | 4 | 5 | 6, _raw: string): string => {\n\t\treturn text + '\\n';\n\t};\n\trenderer.hr = (): string => {\n\t\treturn '';\n\t};\n\trenderer.list = (body: string, _ordered: boolean): string => {\n\t\treturn body;\n\t};\n\trenderer.listitem = (text: string): string => {\n\t\treturn text + '\\n';\n\t};\n\trenderer.paragraph = (text: string): string => {\n\t\treturn text + '\\n';\n\t};\n\trenderer.table = (header: string, body: string): string => {\n\t\treturn header + body + '\\n';\n\t};\n\trenderer.tablerow = (content: string): string => {\n\t\treturn content;\n\t};\n\trenderer.tablecell = (content: string, _flags: {\n\t\theader: boolean;\n\t\talign: 'center' | 'left' | 'right' | null;\n\t}): string => {\n\t\treturn content + ' ';\n\t};\n\trenderer.strong = (text: string): string => {\n\t\treturn text;\n\t};\n\trenderer.em = (text: string): string => {\n\t\treturn text;\n\t};\n\trenderer.codespan = (code: string): string => {\n\t\treturn code;\n\t};\n\trenderer.br = (): string => {\n\t\treturn '\\n';\n\t};\n\trenderer.del = (text: string): string => {\n\t\treturn text;\n\t};\n\trenderer.image = (_href: string, _title: string, _text: string): string => {\n\t\treturn '';\n\t};\n\trenderer.text = (text: string): string => {\n\t\treturn text;\n\t};\n\trenderer.link = (_href: string, _title: string, text: string): string => {\n\t\treturn text;\n\t};\n\treturn renderer;\n});\n\nfunction mergeRawTokenText(tokens: marked.Token[]): string {\n\tlet mergedTokenText = '';\n\ttokens.forEach(token => {\n\t\tmergedTokenText += token.raw;\n\t});\n\treturn mergedTokenText;\n}\n\nfunction completeSingleLinePattern(token: marked.Tokens.ListItem | marked.Tokens.Paragraph): marked.Token | undefined {\n\tfor (let i = 0; i < token.tokens.length; i++) {\n\t\tconst subtoken = token.tokens[i];\n\t\tif (subtoken.type === 'text') {\n\t\t\tconst lines = subtoken.raw.split('\\n');\n\t\t\tconst lastLine = lines[lines.length - 1];\n\t\t\tif (lastLine.includes('`')) {\n\t\t\t\treturn completeCodespan(token);\n\t\t\t} else if (lastLine.includes('**')) {\n\t\t\t\treturn completeDoublestar(token);\n\t\t\t} else if (lastLine.match(/\\*\\w/)) {\n\t\t\t\treturn completeStar(token);\n\t\t\t} else if (lastLine.match(/(^|\\s)__\\w/)) {\n\t\t\t\treturn completeDoubleUnderscore(token);\n\t\t\t} else if (lastLine.match(/(^|\\s)_\\w/)) {\n\t\t\t\treturn completeUnderscore(token);\n\t\t\t} else if (lastLine.match(/(^|\\s)\\[.*\\]\\(\\w*/)) {\n\t\t\t\tconst nextTwoSubTokens = token.tokens.slice(i + 1);\n\t\t\t\tif (nextTwoSubTokens[0]?.type === 'link' && nextTwoSubTokens[1]?.type === 'text' && nextTwoSubTokens[1].raw.match(/^ *\"[^\"]*$/)) {\n\t\t\t\t\t// A markdown link can look like\n\t\t\t\t\t// [link text](https://microsoft.com \"more text\")\n\t\t\t\t\t// Where \"more text\" is a title for the link or an argument to a vscode command link\n\t\t\t\t\treturn completeLinkTargetArg(token);\n\t\t\t\t}\n\t\t\t\treturn completeLinkTarget(token);\n\t\t\t} else if (hasStartOfLinkTarget(lastLine)) {\n\t\t\t\treturn completeLinkTarget(token);\n\t\t\t} else if (lastLine.match(/(^|\\s)\\[\\w/) && !token.tokens.slice(i + 1).some(t => hasStartOfLinkTarget(t.raw))) {\n\t\t\t\treturn completeLinkText(token);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nfunction hasStartOfLinkTarget(str: string): boolean {\n\treturn !!str.match(/^[^\\[]*\\]\\([^\\)]*$/);\n}\n\n// function completeListItemPattern(token: marked.Tokens.List): marked.Tokens.List | undefined {\n// \t// Patch up this one list item\n// \tconst lastItem = token.items[token.items.length - 1];\n\n// \tconst newList = completeSingleLinePattern(lastItem);\n// \tif (!newList || newList.type !== 'list') {\n// \t\t// Nothing to fix, or not a pattern we were expecting\n// \t\treturn;\n// \t}\n\n// \t// Re-parse the whole list with the last item replaced\n// \tconst completeList = marked.lexer(mergeRawTokenText(token.items.slice(0, token.items.length - 1)) + newList.items[0].raw);\n// \tif (completeList.length === 1 && completeList[0].type === 'list') {\n// \t\treturn completeList[0];\n// \t}\n\n// \t// Not a pattern we were expecting\n// \treturn undefined;\n// }\n\nexport function fillInIncompleteTokens(tokens: marked.TokensList): marked.TokensList {\n\tlet i: number;\n\tlet newTokens: marked.Token[] | undefined;\n\tfor (i = 0; i < tokens.length; i++) {\n\t\tconst token = tokens[i];\n\t\tlet codeblockStart: RegExpMatchArray | null;\n\t\tif (token.type === 'paragraph' && (codeblockStart = token.raw.match(/(\\n|^)(````*)/))) {\n\t\t\tconst codeblockLead = codeblockStart[2];\n\t\t\t// If the code block was complete, it would be in a type='code'\n\t\t\tnewTokens = completeCodeBlock(tokens.slice(i), codeblockLead);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (token.type === 'paragraph' && token.raw.match(/(\\n|^)\\|/)) {\n\t\t\tnewTokens = completeTable(tokens.slice(i));\n\t\t\tbreak;\n\t\t}\n\n\t\t// if (i === tokens.length - 1 && token.type === 'list') {\n\t\t// \tconst newListToken = completeListItemPattern(token);\n\t\t// \tif (newListToken) {\n\t\t// \t\tnewTokens = [newListToken];\n\t\t// \t\tbreak;\n\t\t// \t}\n\t\t// }\n\n\t\tif (i === tokens.length - 1 && token.type === 'paragraph') {\n\t\t\t// Only operates on a single token, because any newline that follows this should break these patterns\n\t\t\tconst newToken = completeSingleLinePattern(token);\n\t\t\tif (newToken) {\n\t\t\t\tnewTokens = [newToken];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (newTokens) {\n\t\tconst newTokensList = [\n\t\t\t...tokens.slice(0, i),\n\t\t\t...newTokens\n\t\t];\n\t\t(newTokensList as marked.TokensList).links = tokens.links;\n\t\treturn newTokensList as marked.TokensList;\n\t}\n\n\treturn tokens;\n}\n\nfunction completeCodeBlock(tokens: marked.Token[], leader: string): marked.Token[] {\n\tconst mergedRawText = mergeRawTokenText(tokens);\n\treturn marked.lexer(mergedRawText + `\\n${leader}`);\n}\n\nfunction completeCodespan(token: marked.Token): marked.Token {\n\treturn completeWithString(token, '`');\n}\n\nfunction completeStar(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '*');\n}\n\nfunction completeUnderscore(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '_');\n}\n\nfunction completeLinkTarget(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, ')');\n}\n\nfunction completeLinkTargetArg(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '\")');\n}\n\nfunction completeLinkText(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '](about:blank)');\n}\n\nfunction completeDoublestar(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '**');\n}\n\nfunction completeDoubleUnderscore(tokens: marked.Token): marked.Token {\n\treturn completeWithString(tokens, '__');\n}\n\nfunction completeWithString(tokens: marked.Token[] | marked.Token, closingString: string): marked.Token {\n\tconst mergedRawText = mergeRawTokenText(Array.isArray(tokens) ? tokens : [tokens]);\n\n\t// If it was completed correctly, this should be a single token.\n\t// Expecting either a Paragraph or a List\n\treturn marked.lexer(mergedRawText + closingString)[0] as marked.Token;\n}\n\nfunction completeTable(tokens: marked.Token[]): marked.Token[] | undefined {\n\tconst mergedRawText = mergeRawTokenText(tokens);\n\tconst lines = mergedRawText.split('\\n');\n\n\tlet numCols: number | undefined; // The number of line1 col headers\n\tlet hasSeparatorRow = false;\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tconst line = lines[i].trim();\n\t\tif (typeof numCols === 'undefined' && line.match(/^\\s*\\|/)) {\n\t\t\tconst line1Matches = line.match(/(\\|[^\\|]+)(?=\\||$)/g);\n\t\t\tif (line1Matches) {\n\t\t\t\tnumCols = line1Matches.length;\n\t\t\t}\n\t\t} else if (typeof numCols === 'number') {\n\t\t\tif (line.match(/^\\s*\\|/)) {\n\t\t\t\tif (i !== lines.length - 1) {\n\t\t\t\t\t// We got the line1 header row, and the line2 separator row, but there are more lines, and it wasn't parsed as a table!\n\t\t\t\t\t// That's strange and means that the table is probably malformed in the source, so I won't try to patch it up.\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// Got a line2 separator row- partial or complete, doesn't matter, we'll replace it with a correct one\n\t\t\t\thasSeparatorRow = true;\n\t\t\t} else {\n\t\t\t\t// The line after the header row isn't a valid separator row, so the table is malformed, don't fix it up\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (typeof numCols === 'number' && numCols > 0) {\n\t\tconst prefixText = hasSeparatorRow ? lines.slice(0, -1).join('\\n') : mergedRawText;\n\t\tconst line1EndsInPipe = !!prefixText.match(/\\|\\s*$/);\n\t\tconst newRawText = prefixText + (line1EndsInPipe ? '' : '|') + `\\n|${' --- |'.repeat(numCols)}`;\n\t\treturn marked.lexer(newRawText);\n\t}\n\n\treturn undefined;\n}\n"]}