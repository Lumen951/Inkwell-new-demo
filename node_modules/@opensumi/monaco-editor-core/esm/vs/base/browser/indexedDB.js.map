{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/base/browser/indexedDB.ts","vs/base/browser/indexedDB.ts"],"names":[],"mappings":"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","file":"indexedDB.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { toErrorMessage } from '../common/errorMessage';\nimport { ErrorNoTelemetry, getErrorMessage } from '../common/errors';\nimport { mark } from '../common/performance';\n\nclass MissingStoresError extends Error {\n\tconstructor(readonly db: IDBDatabase) {\n\t\tsuper('Missing stores');\n\t}\n}\n\nexport class DBClosedError extends Error {\n\treadonly code = 'DBClosed';\n\tconstructor(dbName: string) {\n\t\tsuper(`IndexedDB database '${dbName}' is closed.`);\n\t}\n}\n\nexport class IndexedDB {\n\n\tstatic async create(name: string, version: number | undefined, stores: string[]): Promise<IndexedDB> {\n\t\tconst database = await IndexedDB.openDatabase(name, version, stores);\n\t\treturn new IndexedDB(database, name);\n\t}\n\n\tprivate static async openDatabase(name: string, version: number | undefined, stores: string[]): Promise<IDBDatabase> {\n\t\tmark(`code/willOpenDatabase/${name}`);\n\t\ttry {\n\t\t\treturn await IndexedDB.doOpenDatabase(name, version, stores);\n\t\t} catch (err) {\n\t\t\tif (err instanceof MissingStoresError) {\n\t\t\t\tconsole.info(`Attempting to recreate the IndexedDB once.`, name);\n\n\t\t\t\ttry {\n\t\t\t\t\t// Try to delete the db\n\t\t\t\t\tawait IndexedDB.deleteDatabase(err.db);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error(`Error while deleting the IndexedDB`, getErrorMessage(error));\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\treturn await IndexedDB.doOpenDatabase(name, version, stores);\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tmark(`code/didOpenDatabase/${name}`);\n\t\t}\n\t}\n\n\tprivate static doOpenDatabase(name: string, version: number | undefined, stores: string[]): Promise<IDBDatabase> {\n\t\treturn new Promise((c, e) => {\n\t\t\tconst request = indexedDB.open(name, version);\n\t\t\trequest.onerror = () => e(request.error);\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tconst db = request.result;\n\t\t\t\tfor (const store of stores) {\n\t\t\t\t\tif (!db.objectStoreNames.contains(store)) {\n\t\t\t\t\t\tconsole.error(`Error while opening IndexedDB. Could not find '${store}'' object store`);\n\t\t\t\t\t\te(new MissingStoresError(db));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc(db);\n\t\t\t};\n\t\t\trequest.onupgradeneeded = () => {\n\t\t\t\tconst db = request.result;\n\t\t\t\tfor (const store of stores) {\n\t\t\t\t\tif (!db.objectStoreNames.contains(store)) {\n\t\t\t\t\t\tdb.createObjectStore(store);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\tprivate static deleteDatabase(database: IDBDatabase): Promise<void> {\n\t\treturn new Promise((c, e) => {\n\t\t\t// Close any opened connections\n\t\t\tdatabase.close();\n\n\t\t\t// Delete the db\n\t\t\tconst deleteRequest = indexedDB.deleteDatabase(database.name);\n\t\t\tdeleteRequest.onerror = (err) => e(deleteRequest.error);\n\t\t\tdeleteRequest.onsuccess = () => c();\n\t\t});\n\t}\n\n\tprivate database: IDBDatabase | null = null;\n\tprivate readonly pendingTransactions: IDBTransaction[] = [];\n\n\tconstructor(database: IDBDatabase, private readonly name: string) {\n\t\tthis.database = database;\n\t}\n\n\thasPendingTransactions(): boolean {\n\t\treturn this.pendingTransactions.length > 0;\n\t}\n\n\tclose(): void {\n\t\tif (this.pendingTransactions.length) {\n\t\t\tthis.pendingTransactions.splice(0, this.pendingTransactions.length).forEach(transaction => transaction.abort());\n\t\t}\n\t\tthis.database?.close();\n\t\tthis.database = null;\n\t}\n\n\trunInTransaction<T>(store: string, transactionMode: IDBTransactionMode, dbRequestFn: (store: IDBObjectStore) => IDBRequest<T>[]): Promise<T[]>;\n\trunInTransaction<T>(store: string, transactionMode: IDBTransactionMode, dbRequestFn: (store: IDBObjectStore) => IDBRequest<T>): Promise<T>;\n\tasync runInTransaction<T>(store: string, transactionMode: IDBTransactionMode, dbRequestFn: (store: IDBObjectStore) => IDBRequest<T> | IDBRequest<T>[]): Promise<T | T[]> {\n\t\tif (!this.database) {\n\t\t\tthrow new DBClosedError(this.name);\n\t\t}\n\t\tconst transaction = this.database.transaction(store, transactionMode);\n\t\tthis.pendingTransactions.push(transaction);\n\t\treturn new Promise<T | T[]>((c, e) => {\n\t\t\ttransaction.oncomplete = () => {\n\t\t\t\tif (Array.isArray(request)) {\n\t\t\t\t\tc(request.map(r => r.result));\n\t\t\t\t} else {\n\t\t\t\t\tc(request.result);\n\t\t\t\t}\n\t\t\t};\n\t\t\ttransaction.onerror = () => e(transaction.error ? ErrorNoTelemetry.fromError(transaction.error) : new ErrorNoTelemetry('unknown error'));\n\t\t\ttransaction.onabort = () => e(transaction.error ? ErrorNoTelemetry.fromError(transaction.error) : new ErrorNoTelemetry('unknown error'));\n\t\t\tconst request = dbRequestFn(transaction.objectStore(store));\n\t\t}).finally(() => this.pendingTransactions.splice(this.pendingTransactions.indexOf(transaction), 1));\n\t}\n\n\tasync getKeyValues<V>(store: string, isValid: (value: unknown) => value is V): Promise<Map<string, V>> {\n\t\tif (!this.database) {\n\t\t\tthrow new DBClosedError(this.name);\n\t\t}\n\t\tconst transaction = this.database.transaction(store, 'readonly');\n\t\tthis.pendingTransactions.push(transaction);\n\t\treturn new Promise<Map<string, V>>(resolve => {\n\t\t\tconst items = new Map<string, V>();\n\n\t\t\tconst objectStore = transaction.objectStore(store);\n\n\t\t\t// Open a IndexedDB Cursor to iterate over key/values\n\t\t\tconst cursor = objectStore.openCursor();\n\t\t\tif (!cursor) {\n\t\t\t\treturn resolve(items); // this means the `ItemTable` was empty\n\t\t\t}\n\n\t\t\t// Iterate over rows of `ItemTable` until the end\n\t\t\tcursor.onsuccess = () => {\n\t\t\t\tif (cursor.result) {\n\n\t\t\t\t\t// Keep cursor key/value in our map\n\t\t\t\t\tif (isValid(cursor.result.value)) {\n\t\t\t\t\t\titems.set(cursor.result.key.toString(), cursor.result.value);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Advance cursor to next row\n\t\t\t\t\tcursor.result.continue();\n\t\t\t\t} else {\n\t\t\t\t\tresolve(items); // reached end of table\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Error handlers\n\t\t\tconst onError = (error: Error | null) => {\n\t\t\t\tconsole.error(`IndexedDB getKeyValues(): ${toErrorMessage(error, true)}`);\n\n\t\t\t\tresolve(items);\n\t\t\t};\n\t\t\tcursor.onerror = () => onError(cursor.error);\n\t\t\ttransaction.onerror = () => onError(transaction.error);\n\t\t}).finally(() => this.pendingTransactions.splice(this.pendingTransactions.indexOf(transaction), 1));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { toErrorMessage } from '../common/errorMessage';\nimport { ErrorNoTelemetry, getErrorMessage } from '../common/errors';\nimport { mark } from '../common/performance';\n\nclass MissingStoresError extends Error {\n\tconstructor(readonly db: IDBDatabase) {\n\t\tsuper('Missing stores');\n\t}\n}\n\nexport class DBClosedError extends Error {\n\treadonly code = 'DBClosed';\n\tconstructor(dbName: string) {\n\t\tsuper(`IndexedDB database '${dbName}' is closed.`);\n\t}\n}\n\nexport class IndexedDB {\n\n\tstatic async create(name: string, version: number | undefined, stores: string[]): Promise<IndexedDB> {\n\t\tconst database = await IndexedDB.openDatabase(name, version, stores);\n\t\treturn new IndexedDB(database, name);\n\t}\n\n\tprivate static async openDatabase(name: string, version: number | undefined, stores: string[]): Promise<IDBDatabase> {\n\t\tmark(`code/willOpenDatabase/${name}`);\n\t\ttry {\n\t\t\treturn await IndexedDB.doOpenDatabase(name, version, stores);\n\t\t} catch (err) {\n\t\t\tif (err instanceof MissingStoresError) {\n\t\t\t\tconsole.info(`Attempting to recreate the IndexedDB once.`, name);\n\n\t\t\t\ttry {\n\t\t\t\t\t// Try to delete the db\n\t\t\t\t\tawait IndexedDB.deleteDatabase(err.db);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error(`Error while deleting the IndexedDB`, getErrorMessage(error));\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\treturn await IndexedDB.doOpenDatabase(name, version, stores);\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tmark(`code/didOpenDatabase/${name}`);\n\t\t}\n\t}\n\n\tprivate static doOpenDatabase(name: string, version: number | undefined, stores: string[]): Promise<IDBDatabase> {\n\t\treturn new Promise((c, e) => {\n\t\t\tconst request = indexedDB.open(name, version);\n\t\t\trequest.onerror = () => e(request.error);\n\t\t\trequest.onsuccess = () => {\n\t\t\t\tconst db = request.result;\n\t\t\t\tfor (const store of stores) {\n\t\t\t\t\tif (!db.objectStoreNames.contains(store)) {\n\t\t\t\t\t\tconsole.error(`Error while opening IndexedDB. Could not find '${store}'' object store`);\n\t\t\t\t\t\te(new MissingStoresError(db));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc(db);\n\t\t\t};\n\t\t\trequest.onupgradeneeded = () => {\n\t\t\t\tconst db = request.result;\n\t\t\t\tfor (const store of stores) {\n\t\t\t\t\tif (!db.objectStoreNames.contains(store)) {\n\t\t\t\t\t\tdb.createObjectStore(store);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\tprivate static deleteDatabase(database: IDBDatabase): Promise<void> {\n\t\treturn new Promise((c, e) => {\n\t\t\t// Close any opened connections\n\t\t\tdatabase.close();\n\n\t\t\t// Delete the db\n\t\t\tconst deleteRequest = indexedDB.deleteDatabase(database.name);\n\t\t\tdeleteRequest.onerror = (err) => e(deleteRequest.error);\n\t\t\tdeleteRequest.onsuccess = () => c();\n\t\t});\n\t}\n\n\tprivate database: IDBDatabase | null = null;\n\tprivate readonly pendingTransactions: IDBTransaction[] = [];\n\n\tconstructor(database: IDBDatabase, private readonly name: string) {\n\t\tthis.database = database;\n\t}\n\n\thasPendingTransactions(): boolean {\n\t\treturn this.pendingTransactions.length > 0;\n\t}\n\n\tclose(): void {\n\t\tif (this.pendingTransactions.length) {\n\t\t\tthis.pendingTransactions.splice(0, this.pendingTransactions.length).forEach(transaction => transaction.abort());\n\t\t}\n\t\tthis.database?.close();\n\t\tthis.database = null;\n\t}\n\n\trunInTransaction<T>(store: string, transactionMode: IDBTransactionMode, dbRequestFn: (store: IDBObjectStore) => IDBRequest<T>[]): Promise<T[]>;\n\trunInTransaction<T>(store: string, transactionMode: IDBTransactionMode, dbRequestFn: (store: IDBObjectStore) => IDBRequest<T>): Promise<T>;\n\tasync runInTransaction<T>(store: string, transactionMode: IDBTransactionMode, dbRequestFn: (store: IDBObjectStore) => IDBRequest<T> | IDBRequest<T>[]): Promise<T | T[]> {\n\t\tif (!this.database) {\n\t\t\tthrow new DBClosedError(this.name);\n\t\t}\n\t\tconst transaction = this.database.transaction(store, transactionMode);\n\t\tthis.pendingTransactions.push(transaction);\n\t\treturn new Promise<T | T[]>((c, e) => {\n\t\t\ttransaction.oncomplete = () => {\n\t\t\t\tif (Array.isArray(request)) {\n\t\t\t\t\tc(request.map(r => r.result));\n\t\t\t\t} else {\n\t\t\t\t\tc(request.result);\n\t\t\t\t}\n\t\t\t};\n\t\t\ttransaction.onerror = () => e(transaction.error ? ErrorNoTelemetry.fromError(transaction.error) : new ErrorNoTelemetry('unknown error'));\n\t\t\ttransaction.onabort = () => e(transaction.error ? ErrorNoTelemetry.fromError(transaction.error) : new ErrorNoTelemetry('unknown error'));\n\t\t\tconst request = dbRequestFn(transaction.objectStore(store));\n\t\t}).finally(() => this.pendingTransactions.splice(this.pendingTransactions.indexOf(transaction), 1));\n\t}\n\n\tasync getKeyValues<V>(store: string, isValid: (value: unknown) => value is V): Promise<Map<string, V>> {\n\t\tif (!this.database) {\n\t\t\tthrow new DBClosedError(this.name);\n\t\t}\n\t\tconst transaction = this.database.transaction(store, 'readonly');\n\t\tthis.pendingTransactions.push(transaction);\n\t\treturn new Promise<Map<string, V>>(resolve => {\n\t\t\tconst items = new Map<string, V>();\n\n\t\t\tconst objectStore = transaction.objectStore(store);\n\n\t\t\t// Open a IndexedDB Cursor to iterate over key/values\n\t\t\tconst cursor = objectStore.openCursor();\n\t\t\tif (!cursor) {\n\t\t\t\treturn resolve(items); // this means the `ItemTable` was empty\n\t\t\t}\n\n\t\t\t// Iterate over rows of `ItemTable` until the end\n\t\t\tcursor.onsuccess = () => {\n\t\t\t\tif (cursor.result) {\n\n\t\t\t\t\t// Keep cursor key/value in our map\n\t\t\t\t\tif (isValid(cursor.result.value)) {\n\t\t\t\t\t\titems.set(cursor.result.key.toString(), cursor.result.value);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Advance cursor to next row\n\t\t\t\t\tcursor.result.continue();\n\t\t\t\t} else {\n\t\t\t\t\tresolve(items); // reached end of table\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Error handlers\n\t\t\tconst onError = (error: Error | null) => {\n\t\t\t\tconsole.error(`IndexedDB getKeyValues(): ${toErrorMessage(error, true)}`);\n\n\t\t\t\tresolve(items);\n\t\t\t};\n\t\t\tcursor.onerror = () => onError(cursor.error);\n\t\t\ttransaction.onerror = () => onError(transaction.error);\n\t\t}).finally(() => this.pendingTransactions.splice(this.pendingTransactions.indexOf(transaction), 1));\n\t}\n}\n"]}