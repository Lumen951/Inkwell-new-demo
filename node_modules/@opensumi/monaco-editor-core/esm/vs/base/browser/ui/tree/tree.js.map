{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/base/browser/ui/tree/tree.ts","vs/base/browser/ui/tree/tree.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;;AAQhG,IAAkB,cAgBjB;AAhBD,WAAkB,cAAc;IAE/B;;OAEG;IACH,uDAAM,CAAA;IAEN;;OAEG;IACH,yDAAO,CAAA;IAEP;;OAEG;IACH,yDAAO,CAAA;AACR,CAAC,EAhBiB,cAAc,8BAAd,cAAc,QAgB/B;AAuDD,IAAY,8BAaX;AAbD,WAAY,8BAA8B;IACzC,2FAAQ,CAAA;IACR,6FAAS,CAAA;IAET;;OAEG;IACH,+GAAkB,CAAA;IAElB;;OAEG;IACH,iHAAmB,CAAA;AACpB,CAAC,EAbW,8BAA8B,8CAA9B,8BAA8B,QAazC;AAqED,IAAY,oBAKX;AALD,WAAY,oBAAoB;IAC/B,qEAAO,CAAA;IACP,qEAAO,CAAA;IACP,qEAAO,CAAA;IACP,mEAAM,CAAA;AACP,CAAC,EALW,oBAAoB,oCAApB,oBAAoB,QAK/B;AAkCD,IAAkB,kBAGjB;AAHD,WAAkB,kBAAkB;IACnC,2DAAI,CAAA;IACJ,uDAAE,CAAA;AACH,CAAC,EAHiB,kBAAkB,kCAAlB,kBAAkB,QAGnC;AAOY,QAAA,qBAAqB,GAAG;IACpC,cAAc,KAA4B,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,+BAAuB,EAAE,CAAC,CAAC,CAAC;IACnG,gBAAgB,CAAC,UAAU,GAAG,KAAK,IAA2B,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,iCAAyB,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC;IACrI,kBAAkB,KAA4B,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,+BAAuB,EAAE,MAAM,EAAE,EAAE,IAAI,qCAA6B,EAAE,QAAQ,qDAAiC,EAAE,EAAE,CAAC,CAAC,CAAC;IACjM,oBAAoB,CAAC,UAAU,GAAG,KAAK,IAA2B,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,iCAAyB,EAAE,MAAM,EAAE,EAAE,IAAI,qCAA6B,EAAE,QAAQ,qDAAiC,EAAE,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC;CACnO,CAAC;AAMF,MAAa,SAAU,SAAQ,KAAK;IAEnC,YAAY,IAAY,EAAE,OAAe;QACxC,KAAK,CAAC,cAAc,IAAI,KAAK,OAAO,EAAE,CAAC,CAAC;IACzC,CAAC;CACD;AALD,8BAKC;AAED,MAAa,UAAU;IAEtB,YAAoB,EAAe;QAAf,OAAE,GAAF,EAAE,CAAa;QAE3B,SAAI,GAAG,IAAI,OAAO,EAAQ,CAAC;IAFI,CAAC;IAIxC,GAAG,CAAC,GAAM;QACT,IAAI,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAEhC,IAAI,CAAC,MAAM,EAAE,CAAC;YACb,MAAM,GAAG,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;YACtB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;QAC5B,CAAC;QAED,OAAO,MAAM,CAAC;IACf,CAAC;CACD;AAhBD,gCAgBC","file":"tree.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDragAndDropData } from '../../dnd';\nimport { IMouseEvent } from '../../mouseEvent';\nimport { IListDragAndDrop, IListDragOverReaction, IListRenderer, ListDragOverEffectPosition, ListDragOverEffectType } from '../list/list';\nimport { ListViewTargetSector } from '../list/listView';\nimport { Event } from '../../../common/event';\n\nexport const enum TreeVisibility {\n\n\t/**\n\t * The tree node should be hidden.\n\t */\n\tHidden,\n\n\t/**\n\t * The tree node should be visible.\n\t */\n\tVisible,\n\n\t/**\n\t * The tree node should be visible if any of its descendants is visible.\n\t */\n\tRecurse\n}\n\n/**\n * A composed filter result containing the visibility result as well as\n * metadata.\n */\nexport interface ITreeFilterDataResult<TFilterData> {\n\n\t/**\n\t * Whether the node should be visible.\n\t */\n\tvisibility: boolean | TreeVisibility;\n\n\t/**\n\t * Metadata about the element's visibility which gets forwarded to the\n\t * renderer once the element gets rendered.\n\t */\n\tdata: TFilterData;\n}\n\n/**\n * The result of a filter call can be a boolean value indicating whether\n * the element should be visible or not, a value of type `TreeVisibility` or\n * an object composed of the visibility result as well as additional metadata\n * which gets forwarded to the renderer once the element gets rendered.\n */\nexport type TreeFilterResult<TFilterData> = boolean | TreeVisibility | ITreeFilterDataResult<TFilterData>;\n\n/**\n * A tree filter is responsible for controlling the visibility of\n * elements in a tree.\n */\nexport interface ITreeFilter<T, TFilterData = void> {\n\n\t/**\n\t * Returns whether this elements should be visible and, if affirmative,\n\t * additional metadata which gets forwarded to the renderer once the element\n\t * gets rendered.\n\t *\n\t * @param element The tree element.\n\t */\n\tfilter(element: T, parentVisibility: TreeVisibility): TreeFilterResult<TFilterData>;\n}\n\nexport interface ITreeSorter<T> {\n\tcompare(element: T, otherElement: T): number;\n}\n\nexport interface ITreeElement<T> {\n\treadonly element: T;\n\treadonly children?: Iterable<ITreeElement<T>>;\n\treadonly collapsible?: boolean;\n\treadonly collapsed?: boolean;\n}\n\nexport enum ObjectTreeElementCollapseState {\n\tExpanded,\n\tCollapsed,\n\n\t/**\n\t * If the element is already in the tree, preserve its current state. Else, expand it.\n\t */\n\tPreserveOrExpanded,\n\n\t/**\n\t * If the element is already in the tree, preserve its current state. Else, collapse it.\n\t */\n\tPreserveOrCollapsed,\n}\n\nexport interface IObjectTreeElement<T> {\n\treadonly element: T;\n\treadonly children?: Iterable<IObjectTreeElement<T>>;\n\treadonly collapsible?: boolean;\n\treadonly collapsed?: boolean | ObjectTreeElementCollapseState;\n}\n\nexport interface ITreeNode<T, TFilterData = void> {\n\treadonly element: T;\n\treadonly children: ITreeNode<T, TFilterData>[];\n\treadonly depth: number;\n\treadonly visibleChildrenCount: number;\n\treadonly visibleChildIndex: number;\n\treadonly collapsible: boolean;\n\treadonly collapsed: boolean;\n\treadonly visible: boolean;\n\treadonly filterData: TFilterData | undefined;\n}\n\nexport interface ICollapseStateChangeEvent<T, TFilterData> {\n\tnode: ITreeNode<T, TFilterData>;\n\tdeep: boolean;\n}\n\nexport interface ITreeModelSpliceEvent<T, TFilterData> {\n\tinsertedNodes: ITreeNode<T, TFilterData>[];\n\tdeletedNodes: ITreeNode<T, TFilterData>[];\n}\n\nexport interface ITreeModel<T, TFilterData, TRef> {\n\treadonly rootRef: TRef;\n\n\treadonly onDidSplice: Event<ITreeModelSpliceEvent<T, TFilterData>>;\n\treadonly onDidChangeCollapseState: Event<ICollapseStateChangeEvent<T, TFilterData>>;\n\treadonly onDidChangeRenderNodeCount: Event<ITreeNode<T, TFilterData>>;\n\n\thas(location: TRef): boolean;\n\n\tgetListIndex(location: TRef): number;\n\tgetListRenderCount(location: TRef): number;\n\tgetNode(location?: TRef): ITreeNode<T, any>;\n\tgetNodeLocation(node: ITreeNode<T, any>): TRef;\n\tgetParentNodeLocation(location: TRef): TRef | undefined;\n\n\tgetFirstElementChild(location: TRef): T | undefined;\n\tgetLastElementAncestor(location?: TRef): T | undefined;\n\n\tisCollapsible(location: TRef): boolean;\n\tsetCollapsible(location: TRef, collapsible?: boolean): boolean;\n\tisCollapsed(location: TRef): boolean;\n\tsetCollapsed(location: TRef, collapsed?: boolean, recursive?: boolean): boolean;\n\texpandTo(location: TRef): void;\n\n\trerender(location: TRef): void;\n\trefilter(): void;\n}\n\nexport interface ITreeRenderer<T, TFilterData = void, TTemplateData = void> extends IListRenderer<ITreeNode<T, TFilterData>, TTemplateData> {\n\trenderTwistie?(element: T, twistieElement: HTMLElement): boolean;\n\tonDidChangeTwistieState?: Event<T>;\n}\n\nexport interface ITreeEvent<T> {\n\treadonly elements: readonly T[];\n\treadonly browserEvent?: UIEvent;\n}\n\nexport enum TreeMouseEventTarget {\n\tUnknown,\n\tTwistie,\n\tElement,\n\tFilter\n}\n\nexport interface ITreeMouseEvent<T> {\n\treadonly browserEvent: MouseEvent;\n\treadonly element: T | null;\n\treadonly target: TreeMouseEventTarget;\n}\n\nexport interface ITreeContextMenuEvent<T> {\n\treadonly browserEvent: UIEvent;\n\treadonly element: T | null;\n\treadonly anchor: HTMLElement | IMouseEvent;\n\treadonly isStickyScroll: boolean;\n}\n\nexport interface ITreeNavigator<T> {\n\tcurrent(): T | null;\n\tprevious(): T | null;\n\tfirst(): T | null;\n\tlast(): T | null;\n\tnext(): T | null;\n}\n\nexport interface IDataSource<TInput, T> {\n\thasChildren?(element: TInput | T): boolean;\n\tgetChildren(element: TInput | T): Iterable<T>;\n}\n\nexport interface IAsyncDataSource<TInput, T> {\n\thasChildren(element: TInput | T): boolean;\n\tgetChildren(element: TInput | T): Iterable<T> | Promise<Iterable<T>>;\n\tgetParent?(element: T): TInput | T;\n}\n\nexport const enum TreeDragOverBubble {\n\tDown,\n\tUp\n}\n\nexport interface ITreeDragOverReaction extends IListDragOverReaction {\n\tbubble?: TreeDragOverBubble;\n\tautoExpand?: boolean;\n}\n\nexport const TreeDragOverReactions = {\n\tacceptBubbleUp(): ITreeDragOverReaction { return { accept: true, bubble: TreeDragOverBubble.Up }; },\n\tacceptBubbleDown(autoExpand = false): ITreeDragOverReaction { return { accept: true, bubble: TreeDragOverBubble.Down, autoExpand }; },\n\tacceptCopyBubbleUp(): ITreeDragOverReaction { return { accept: true, bubble: TreeDragOverBubble.Up, effect: { type: ListDragOverEffectType.Copy, position: ListDragOverEffectPosition.Over } }; },\n\tacceptCopyBubbleDown(autoExpand = false): ITreeDragOverReaction { return { accept: true, bubble: TreeDragOverBubble.Down, effect: { type: ListDragOverEffectType.Copy, position: ListDragOverEffectPosition.Over }, autoExpand }; }\n};\n\nexport interface ITreeDragAndDrop<T> extends IListDragAndDrop<T> {\n\tonDragOver(data: IDragAndDropData, targetElement: T | undefined, targetIndex: number | undefined, targetSector: ListViewTargetSector | undefined, originalEvent: DragEvent): boolean | ITreeDragOverReaction;\n}\n\nexport class TreeError extends Error {\n\n\tconstructor(user: string, message: string) {\n\t\tsuper(`TreeError [${user}] ${message}`);\n\t}\n}\n\nexport class WeakMapper<K extends object, V> {\n\n\tconstructor(private fn: (k: K) => V) { }\n\n\tprivate _map = new WeakMap<K, V>();\n\n\tmap(key: K): V {\n\t\tlet result = this._map.get(key);\n\n\t\tif (!result) {\n\t\t\tresult = this.fn(key);\n\t\t\tthis._map.set(key, result);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDragAndDropData } from '../../dnd';\nimport { IMouseEvent } from '../../mouseEvent';\nimport { IListDragAndDrop, IListDragOverReaction, IListRenderer, ListDragOverEffectPosition, ListDragOverEffectType } from '../list/list';\nimport { ListViewTargetSector } from '../list/listView';\nimport { Event } from '../../../common/event';\n\nexport const enum TreeVisibility {\n\n\t/**\n\t * The tree node should be hidden.\n\t */\n\tHidden,\n\n\t/**\n\t * The tree node should be visible.\n\t */\n\tVisible,\n\n\t/**\n\t * The tree node should be visible if any of its descendants is visible.\n\t */\n\tRecurse\n}\n\n/**\n * A composed filter result containing the visibility result as well as\n * metadata.\n */\nexport interface ITreeFilterDataResult<TFilterData> {\n\n\t/**\n\t * Whether the node should be visible.\n\t */\n\tvisibility: boolean | TreeVisibility;\n\n\t/**\n\t * Metadata about the element's visibility which gets forwarded to the\n\t * renderer once the element gets rendered.\n\t */\n\tdata: TFilterData;\n}\n\n/**\n * The result of a filter call can be a boolean value indicating whether\n * the element should be visible or not, a value of type `TreeVisibility` or\n * an object composed of the visibility result as well as additional metadata\n * which gets forwarded to the renderer once the element gets rendered.\n */\nexport type TreeFilterResult<TFilterData> = boolean | TreeVisibility | ITreeFilterDataResult<TFilterData>;\n\n/**\n * A tree filter is responsible for controlling the visibility of\n * elements in a tree.\n */\nexport interface ITreeFilter<T, TFilterData = void> {\n\n\t/**\n\t * Returns whether this elements should be visible and, if affirmative,\n\t * additional metadata which gets forwarded to the renderer once the element\n\t * gets rendered.\n\t *\n\t * @param element The tree element.\n\t */\n\tfilter(element: T, parentVisibility: TreeVisibility): TreeFilterResult<TFilterData>;\n}\n\nexport interface ITreeSorter<T> {\n\tcompare(element: T, otherElement: T): number;\n}\n\nexport interface ITreeElement<T> {\n\treadonly element: T;\n\treadonly children?: Iterable<ITreeElement<T>>;\n\treadonly collapsible?: boolean;\n\treadonly collapsed?: boolean;\n}\n\nexport enum ObjectTreeElementCollapseState {\n\tExpanded,\n\tCollapsed,\n\n\t/**\n\t * If the element is already in the tree, preserve its current state. Else, expand it.\n\t */\n\tPreserveOrExpanded,\n\n\t/**\n\t * If the element is already in the tree, preserve its current state. Else, collapse it.\n\t */\n\tPreserveOrCollapsed,\n}\n\nexport interface IObjectTreeElement<T> {\n\treadonly element: T;\n\treadonly children?: Iterable<IObjectTreeElement<T>>;\n\treadonly collapsible?: boolean;\n\treadonly collapsed?: boolean | ObjectTreeElementCollapseState;\n}\n\nexport interface ITreeNode<T, TFilterData = void> {\n\treadonly element: T;\n\treadonly children: ITreeNode<T, TFilterData>[];\n\treadonly depth: number;\n\treadonly visibleChildrenCount: number;\n\treadonly visibleChildIndex: number;\n\treadonly collapsible: boolean;\n\treadonly collapsed: boolean;\n\treadonly visible: boolean;\n\treadonly filterData: TFilterData | undefined;\n}\n\nexport interface ICollapseStateChangeEvent<T, TFilterData> {\n\tnode: ITreeNode<T, TFilterData>;\n\tdeep: boolean;\n}\n\nexport interface ITreeModelSpliceEvent<T, TFilterData> {\n\tinsertedNodes: ITreeNode<T, TFilterData>[];\n\tdeletedNodes: ITreeNode<T, TFilterData>[];\n}\n\nexport interface ITreeModel<T, TFilterData, TRef> {\n\treadonly rootRef: TRef;\n\n\treadonly onDidSplice: Event<ITreeModelSpliceEvent<T, TFilterData>>;\n\treadonly onDidChangeCollapseState: Event<ICollapseStateChangeEvent<T, TFilterData>>;\n\treadonly onDidChangeRenderNodeCount: Event<ITreeNode<T, TFilterData>>;\n\n\thas(location: TRef): boolean;\n\n\tgetListIndex(location: TRef): number;\n\tgetListRenderCount(location: TRef): number;\n\tgetNode(location?: TRef): ITreeNode<T, any>;\n\tgetNodeLocation(node: ITreeNode<T, any>): TRef;\n\tgetParentNodeLocation(location: TRef): TRef | undefined;\n\n\tgetFirstElementChild(location: TRef): T | undefined;\n\tgetLastElementAncestor(location?: TRef): T | undefined;\n\n\tisCollapsible(location: TRef): boolean;\n\tsetCollapsible(location: TRef, collapsible?: boolean): boolean;\n\tisCollapsed(location: TRef): boolean;\n\tsetCollapsed(location: TRef, collapsed?: boolean, recursive?: boolean): boolean;\n\texpandTo(location: TRef): void;\n\n\trerender(location: TRef): void;\n\trefilter(): void;\n}\n\nexport interface ITreeRenderer<T, TFilterData = void, TTemplateData = void> extends IListRenderer<ITreeNode<T, TFilterData>, TTemplateData> {\n\trenderTwistie?(element: T, twistieElement: HTMLElement): boolean;\n\tonDidChangeTwistieState?: Event<T>;\n}\n\nexport interface ITreeEvent<T> {\n\treadonly elements: readonly T[];\n\treadonly browserEvent?: UIEvent;\n}\n\nexport enum TreeMouseEventTarget {\n\tUnknown,\n\tTwistie,\n\tElement,\n\tFilter\n}\n\nexport interface ITreeMouseEvent<T> {\n\treadonly browserEvent: MouseEvent;\n\treadonly element: T | null;\n\treadonly target: TreeMouseEventTarget;\n}\n\nexport interface ITreeContextMenuEvent<T> {\n\treadonly browserEvent: UIEvent;\n\treadonly element: T | null;\n\treadonly anchor: HTMLElement | IMouseEvent;\n\treadonly isStickyScroll: boolean;\n}\n\nexport interface ITreeNavigator<T> {\n\tcurrent(): T | null;\n\tprevious(): T | null;\n\tfirst(): T | null;\n\tlast(): T | null;\n\tnext(): T | null;\n}\n\nexport interface IDataSource<TInput, T> {\n\thasChildren?(element: TInput | T): boolean;\n\tgetChildren(element: TInput | T): Iterable<T>;\n}\n\nexport interface IAsyncDataSource<TInput, T> {\n\thasChildren(element: TInput | T): boolean;\n\tgetChildren(element: TInput | T): Iterable<T> | Promise<Iterable<T>>;\n\tgetParent?(element: T): TInput | T;\n}\n\nexport const enum TreeDragOverBubble {\n\tDown,\n\tUp\n}\n\nexport interface ITreeDragOverReaction extends IListDragOverReaction {\n\tbubble?: TreeDragOverBubble;\n\tautoExpand?: boolean;\n}\n\nexport const TreeDragOverReactions = {\n\tacceptBubbleUp(): ITreeDragOverReaction { return { accept: true, bubble: TreeDragOverBubble.Up }; },\n\tacceptBubbleDown(autoExpand = false): ITreeDragOverReaction { return { accept: true, bubble: TreeDragOverBubble.Down, autoExpand }; },\n\tacceptCopyBubbleUp(): ITreeDragOverReaction { return { accept: true, bubble: TreeDragOverBubble.Up, effect: { type: ListDragOverEffectType.Copy, position: ListDragOverEffectPosition.Over } }; },\n\tacceptCopyBubbleDown(autoExpand = false): ITreeDragOverReaction { return { accept: true, bubble: TreeDragOverBubble.Down, effect: { type: ListDragOverEffectType.Copy, position: ListDragOverEffectPosition.Over }, autoExpand }; }\n};\n\nexport interface ITreeDragAndDrop<T> extends IListDragAndDrop<T> {\n\tonDragOver(data: IDragAndDropData, targetElement: T | undefined, targetIndex: number | undefined, targetSector: ListViewTargetSector | undefined, originalEvent: DragEvent): boolean | ITreeDragOverReaction;\n}\n\nexport class TreeError extends Error {\n\n\tconstructor(user: string, message: string) {\n\t\tsuper(`TreeError [${user}] ${message}`);\n\t}\n}\n\nexport class WeakMapper<K extends object, V> {\n\n\tconstructor(private fn: (k: K) => V) { }\n\n\tprivate _map = new WeakMap<K, V>();\n\n\tmap(key: K): V {\n\t\tlet result = this._map.get(key);\n\n\t\tif (!result) {\n\t\t\tresult = this.fn(key);\n\t\t\tthis._map.set(key, result);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n"]}