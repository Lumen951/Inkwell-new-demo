{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/base/browser/ui/tree/asyncDataTree.ts","vs/base/browser/ui/tree/asyncDataTree.ts"],"names":[],"mappings":"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","file":"asyncDataTree.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDragAndDropData } from '../../dnd';\nimport { IIdentityProvider, IListDragAndDrop, IListDragOverReaction, IListVirtualDelegate } from '../list/list';\nimport { ElementsDragAndDropData, ListViewTargetSector } from '../list/listView';\nimport { IListStyles } from '../list/listWidget';\nimport { ComposedTreeDelegate, TreeFindMode as TreeFindMode, IAbstractTreeOptions, IAbstractTreeOptionsUpdate, TreeFindMatchType, AbstractTreePart } from './abstractTree';\nimport { ICompressedTreeElement, ICompressedTreeNode } from './compressedObjectTreeModel';\nimport { getVisibleState, isFilterResult } from './indexTreeModel';\nimport { CompressibleObjectTree, ICompressibleKeyboardNavigationLabelProvider, ICompressibleObjectTreeOptions, ICompressibleTreeRenderer, IObjectTreeOptions, IObjectTreeSetChildrenOptions, ObjectTree } from './objectTree';\nimport { IAsyncDataSource, ICollapseStateChangeEvent, IObjectTreeElement, ITreeContextMenuEvent, ITreeDragAndDrop, ITreeEvent, ITreeFilter, ITreeMouseEvent, ITreeNode, ITreeRenderer, ITreeSorter, ObjectTreeElementCollapseState, TreeError, TreeFilterResult, TreeVisibility, WeakMapper } from './tree';\nimport { CancelablePromise, createCancelablePromise, Promises, timeout } from '../../../common/async';\nimport { Codicon } from '../../../common/codicons';\nimport { ThemeIcon } from '../../../common/themables';\nimport { isCancellationError, onUnexpectedError } from '../../../common/errors';\nimport { Emitter, Event } from '../../../common/event';\nimport { Iterable } from '../../../common/iterator';\nimport { DisposableStore, dispose, IDisposable } from '../../../common/lifecycle';\nimport { ScrollEvent } from '../../../common/scrollable';\nimport { isIterable } from '../../../common/types';\n\ninterface IAsyncDataTreeNode<TInput, T> {\n\telement: TInput | T;\n\treadonly parent: IAsyncDataTreeNode<TInput, T> | null;\n\treadonly children: IAsyncDataTreeNode<TInput, T>[];\n\treadonly id?: string | null;\n\trefreshPromise: Promise<void> | undefined;\n\thasChildren: boolean;\n\tstale: boolean;\n\tslow: boolean;\n\treadonly defaultCollapseState: undefined | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded;\n\tforceExpanded: boolean;\n}\n\ninterface IAsyncDataTreeNodeRequiredProps<TInput, T> extends Partial<IAsyncDataTreeNode<TInput, T>> {\n\treadonly element: TInput | T;\n\treadonly parent: IAsyncDataTreeNode<TInput, T> | null;\n\treadonly hasChildren: boolean;\n\treadonly defaultCollapseState: undefined | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded;\n}\n\nfunction createAsyncDataTreeNode<TInput, T>(props: IAsyncDataTreeNodeRequiredProps<TInput, T>): IAsyncDataTreeNode<TInput, T> {\n\treturn {\n\t\t...props,\n\t\tchildren: [],\n\t\trefreshPromise: undefined,\n\t\tstale: true,\n\t\tslow: false,\n\t\tforceExpanded: false\n\t};\n}\n\nfunction isAncestor<TInput, T>(ancestor: IAsyncDataTreeNode<TInput, T>, descendant: IAsyncDataTreeNode<TInput, T>): boolean {\n\tif (!descendant.parent) {\n\t\treturn false;\n\t} else if (descendant.parent === ancestor) {\n\t\treturn true;\n\t} else {\n\t\treturn isAncestor(ancestor, descendant.parent);\n\t}\n}\n\nfunction intersects<TInput, T>(node: IAsyncDataTreeNode<TInput, T>, other: IAsyncDataTreeNode<TInput, T>): boolean {\n\treturn node === other || isAncestor(node, other) || isAncestor(other, node);\n}\n\ninterface IDataTreeListTemplateData<T> {\n\ttemplateData: T;\n}\n\ntype AsyncDataTreeNodeMapper<TInput, T, TFilterData> = WeakMapper<ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>, ITreeNode<TInput | T, TFilterData>>;\n\nclass AsyncDataTreeNodeWrapper<TInput, T, TFilterData> implements ITreeNode<TInput | T, TFilterData> {\n\n\tget element(): T { return this.node.element!.element as T; }\n\tget children(): ITreeNode<T, TFilterData>[] { return this.node.children.map(node => new AsyncDataTreeNodeWrapper(node)); }\n\tget depth(): number { return this.node.depth; }\n\tget visibleChildrenCount(): number { return this.node.visibleChildrenCount; }\n\tget visibleChildIndex(): number { return this.node.visibleChildIndex; }\n\tget collapsible(): boolean { return this.node.collapsible; }\n\tget collapsed(): boolean { return this.node.collapsed; }\n\tget visible(): boolean { return this.node.visible; }\n\tget filterData(): TFilterData | undefined { return this.node.filterData; }\n\n\tconstructor(private node: ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>) { }\n}\n\nclass AsyncDataTreeRenderer<TInput, T, TFilterData, TTemplateData> implements ITreeRenderer<IAsyncDataTreeNode<TInput, T>, TFilterData, IDataTreeListTemplateData<TTemplateData>> {\n\n\treadonly templateId: string;\n\tprivate renderedNodes = new Map<IAsyncDataTreeNode<TInput, T>, IDataTreeListTemplateData<TTemplateData>>();\n\n\tconstructor(\n\t\tprotected renderer: ITreeRenderer<T, TFilterData, TTemplateData>,\n\t\tprotected nodeMapper: AsyncDataTreeNodeMapper<TInput, T, TFilterData>,\n\t\treadonly onDidChangeTwistieState: Event<IAsyncDataTreeNode<TInput, T>>\n\t) {\n\t\tthis.templateId = renderer.templateId;\n\t}\n\n\trenderTemplate(container: HTMLElement): IDataTreeListTemplateData<TTemplateData> {\n\t\tconst templateData = this.renderer.renderTemplate(container);\n\t\treturn { templateData };\n\t}\n\n\trenderElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.renderElement(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\trenderTwistie(element: IAsyncDataTreeNode<TInput, T>, twistieElement: HTMLElement): boolean {\n\t\tif (element.slow) {\n\t\t\ttwistieElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn true;\n\t\t} else {\n\t\t\ttwistieElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tdisposeElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.disposeElement?.(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\tdisposeTemplate(templateData: IDataTreeListTemplateData<TTemplateData>): void {\n\t\tthis.renderer.disposeTemplate(templateData.templateData);\n\t}\n\n\tdispose(): void {\n\t\tthis.renderedNodes.clear();\n\t}\n}\n\nfunction asTreeEvent<TInput, T>(e: ITreeEvent<IAsyncDataTreeNode<TInput, T> | null>): ITreeEvent<T> {\n\treturn {\n\t\tbrowserEvent: e.browserEvent,\n\t\telements: e.elements.map(e => e!.element as T)\n\t};\n}\n\nfunction asTreeMouseEvent<TInput, T>(e: ITreeMouseEvent<IAsyncDataTreeNode<TInput, T> | null>): ITreeMouseEvent<T> {\n\treturn {\n\t\tbrowserEvent: e.browserEvent,\n\t\telement: e.element && e.element.element as T,\n\t\ttarget: e.target\n\t};\n}\n\nfunction asTreeContextMenuEvent<TInput, T>(e: ITreeContextMenuEvent<IAsyncDataTreeNode<TInput, T> | null>): ITreeContextMenuEvent<T> {\n\treturn {\n\t\tbrowserEvent: e.browserEvent,\n\t\telement: e.element && e.element.element as T,\n\t\tanchor: e.anchor,\n\t\tisStickyScroll: e.isStickyScroll\n\t};\n}\n\nclass AsyncDataTreeElementsDragAndDropData<TInput, T, TContext> extends ElementsDragAndDropData<T, TContext> {\n\n\toverride set context(context: TContext | undefined) {\n\t\tthis.data.context = context;\n\t}\n\n\toverride get context(): TContext | undefined {\n\t\treturn this.data.context;\n\t}\n\n\tconstructor(private data: ElementsDragAndDropData<IAsyncDataTreeNode<TInput, T>, TContext>) {\n\t\tsuper(data.elements.map(node => node.element as T));\n\t}\n}\n\nfunction asAsyncDataTreeDragAndDropData<TInput, T>(data: IDragAndDropData): IDragAndDropData {\n\tif (data instanceof ElementsDragAndDropData) {\n\t\treturn new AsyncDataTreeElementsDragAndDropData(data);\n\t}\n\n\treturn data;\n}\n\nclass AsyncDataTreeNodeListDragAndDrop<TInput, T> implements IListDragAndDrop<IAsyncDataTreeNode<TInput, T>> {\n\n\tconstructor(private dnd: ITreeDragAndDrop<T>) { }\n\n\tgetDragURI(node: IAsyncDataTreeNode<TInput, T>): string | null {\n\t\treturn this.dnd.getDragURI(node.element as T);\n\t}\n\n\tgetDragLabel(nodes: IAsyncDataTreeNode<TInput, T>[], originalEvent: DragEvent): string | undefined {\n\t\tif (this.dnd.getDragLabel) {\n\t\t\treturn this.dnd.getDragLabel(nodes.map(node => node.element as T), originalEvent);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tonDragStart(data: IDragAndDropData, originalEvent: DragEvent): void {\n\t\tthis.dnd.onDragStart?.(asAsyncDataTreeDragAndDropData(data), originalEvent);\n\t}\n\n\tonDragOver(data: IDragAndDropData, targetNode: IAsyncDataTreeNode<TInput, T> | undefined, targetIndex: number | undefined, targetSector: ListViewTargetSector | undefined, originalEvent: DragEvent, raw = true): boolean | IListDragOverReaction {\n\t\treturn this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element as T, targetIndex, targetSector, originalEvent);\n\t}\n\n\tdrop(data: IDragAndDropData, targetNode: IAsyncDataTreeNode<TInput, T> | undefined, targetIndex: number | undefined, targetSector: ListViewTargetSector | undefined, originalEvent: DragEvent): void {\n\t\tthis.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element as T, targetIndex, targetSector, originalEvent);\n\t}\n\n\tonDragEnd(originalEvent: DragEvent): void {\n\t\tthis.dnd.onDragEnd?.(originalEvent);\n\t}\n\n\tdispose(): void {\n\t\tthis.dnd.dispose();\n\t}\n}\n\nfunction asObjectTreeOptions<TInput, T, TFilterData>(options?: IAsyncDataTreeOptions<T, TFilterData>): IObjectTreeOptions<IAsyncDataTreeNode<TInput, T>, TFilterData> | undefined {\n\treturn options && {\n\t\t...options,\n\t\tcollapseByDefault: true,\n\t\tidentityProvider: options.identityProvider && {\n\t\t\tgetId(el) {\n\t\t\t\treturn options.identityProvider!.getId(el.element as T);\n\t\t\t}\n\t\t},\n\t\tdnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd),\n\t\tmultipleSelectionController: options.multipleSelectionController && {\n\t\t\tisSelectionSingleChangeEvent(e) {\n\t\t\t\treturn options.multipleSelectionController!.isSelectionSingleChangeEvent({ ...e, element: e.element } as any);\n\t\t\t},\n\t\t\tisSelectionRangeChangeEvent(e) {\n\t\t\t\treturn options.multipleSelectionController!.isSelectionRangeChangeEvent({ ...e, element: e.element } as any);\n\t\t\t}\n\t\t},\n\t\taccessibilityProvider: options.accessibilityProvider && {\n\t\t\t...options.accessibilityProvider,\n\t\t\tgetPosInSet: undefined,\n\t\t\tgetSetSize: undefined,\n\t\t\tgetRole: options.accessibilityProvider.getRole ? (el) => {\n\t\t\t\treturn options.accessibilityProvider!.getRole!(el.element as T);\n\t\t\t} : () => 'treeitem',\n\t\t\tisChecked: options.accessibilityProvider.isChecked ? (e) => {\n\t\t\t\treturn !!(options.accessibilityProvider?.isChecked!(e.element as T));\n\t\t\t} : undefined,\n\t\t\tgetAriaLabel(e) {\n\t\t\t\treturn options.accessibilityProvider!.getAriaLabel(e.element as T);\n\t\t\t},\n\t\t\tgetWidgetAriaLabel() {\n\t\t\t\treturn options.accessibilityProvider!.getWidgetAriaLabel();\n\t\t\t},\n\t\t\tgetWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider!.getWidgetRole!() : () => 'tree',\n\t\t\tgetAriaLevel: options.accessibilityProvider.getAriaLevel && (node => {\n\t\t\t\treturn options.accessibilityProvider!.getAriaLevel!(node.element as T);\n\t\t\t}),\n\t\t\tgetActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n\t\t\t\treturn options.accessibilityProvider!.getActiveDescendantId!(node.element as T);\n\t\t\t})\n\t\t},\n\t\tfilter: options.filter && {\n\t\t\tfilter(e, parentVisibility) {\n\t\t\t\treturn options.filter!.filter(e.element as T, parentVisibility);\n\t\t\t}\n\t\t},\n\t\tkeyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {\n\t\t\t...options.keyboardNavigationLabelProvider,\n\t\t\tgetKeyboardNavigationLabel(e) {\n\t\t\t\treturn options.keyboardNavigationLabelProvider!.getKeyboardNavigationLabel(e.element as T);\n\t\t\t}\n\t\t},\n\t\tsorter: undefined,\n\t\texpandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : (\n\t\t\ttypeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : (\n\t\t\t\te => (options.expandOnlyOnTwistieClick as ((e: T) => boolean))(e.element as T)\n\t\t\t)\n\t\t),\n\t\tdefaultFindVisibility: e => {\n\t\t\tif (e.hasChildren && e.stale) {\n\t\t\t\treturn TreeVisibility.Visible;\n\t\t\t} else if (typeof options.defaultFindVisibility === 'number') {\n\t\t\t\treturn options.defaultFindVisibility;\n\t\t\t} else if (typeof options.defaultFindVisibility === 'undefined') {\n\t\t\t\treturn TreeVisibility.Recurse;\n\t\t\t} else {\n\t\t\t\treturn (options.defaultFindVisibility as ((e: T) => TreeVisibility))(e.element as T);\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport interface IAsyncDataTreeOptionsUpdate extends IAbstractTreeOptionsUpdate { }\nexport interface IAsyncDataTreeUpdateChildrenOptions<T> extends IObjectTreeSetChildrenOptions<T> { }\n\nexport interface IAsyncDataTreeOptions<T, TFilterData = void> extends IAsyncDataTreeOptionsUpdate, Pick<IAbstractTreeOptions<T, TFilterData>, Exclude<keyof IAbstractTreeOptions<T, TFilterData>, 'collapseByDefault'>> {\n\treadonly collapseByDefault?: { (e: T): boolean };\n\treadonly identityProvider?: IIdentityProvider<T>;\n\treadonly sorter?: ITreeSorter<T>;\n\treadonly autoExpandSingleChildren?: boolean;\n}\n\nexport interface IAsyncDataTreeViewState {\n\treadonly focus?: string[];\n\treadonly selection?: string[];\n\treadonly expanded?: string[];\n\treadonly scrollTop?: number;\n}\n\ninterface IAsyncDataTreeViewStateContext<TInput, T> {\n\treadonly viewState: IAsyncDataTreeViewState;\n\treadonly selection: IAsyncDataTreeNode<TInput, T>[];\n\treadonly focus: IAsyncDataTreeNode<TInput, T>[];\n}\n\nfunction dfs<TInput, T>(node: IAsyncDataTreeNode<TInput, T>, fn: (node: IAsyncDataTreeNode<TInput, T>) => void): void {\n\tfn(node);\n\tnode.children.forEach(child => dfs(child, fn));\n}\n\nexport class AsyncDataTree<TInput, T, TFilterData = void> implements IDisposable {\n\n\tprotected readonly tree: ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData>;\n\tprotected readonly root: IAsyncDataTreeNode<TInput, T>;\n\tprivate readonly nodes = new Map<null | T, IAsyncDataTreeNode<TInput, T>>();\n\tprivate readonly sorter?: ITreeSorter<T>;\n\tprivate readonly getDefaultCollapseState: { (e: T): undefined | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded };\n\n\tprivate readonly subTreeRefreshPromises = new Map<IAsyncDataTreeNode<TInput, T>, Promise<void>>();\n\tprivate readonly refreshPromises = new Map<IAsyncDataTreeNode<TInput, T>, CancelablePromise<Iterable<T>>>();\n\n\tprotected readonly identityProvider?: IIdentityProvider<T>;\n\tprivate readonly autoExpandSingleChildren: boolean;\n\n\tprivate readonly _onDidRender = new Emitter<void>();\n\tprotected readonly _onDidChangeNodeSlowState = new Emitter<IAsyncDataTreeNode<TInput, T>>();\n\n\tprotected readonly nodeMapper: AsyncDataTreeNodeMapper<TInput, T, TFilterData> = new WeakMapper(node => new AsyncDataTreeNodeWrapper(node));\n\n\tprotected readonly disposables = new DisposableStore();\n\n\tget onDidScroll(): Event<ScrollEvent> { return this.tree.onDidScroll; }\n\n\tget onDidChangeFocus(): Event<ITreeEvent<T>> { return Event.map(this.tree.onDidChangeFocus, asTreeEvent); }\n\tget onDidChangeSelection(): Event<ITreeEvent<T>> { return Event.map(this.tree.onDidChangeSelection, asTreeEvent); }\n\n\tget onKeyDown(): Event<KeyboardEvent> { return this.tree.onKeyDown; }\n\tget onMouseClick(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onMouseClick, asTreeMouseEvent); }\n\tget onMouseDblClick(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent); }\n\tget onContextMenu(): Event<ITreeContextMenuEvent<T>> { return Event.map(this.tree.onContextMenu, asTreeContextMenuEvent); }\n\tget onTap(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onTap, asTreeMouseEvent); }\n\tget onPointer(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onPointer, asTreeMouseEvent); }\n\tget onDidFocus(): Event<void> { return this.tree.onDidFocus; }\n\tget onDidBlur(): Event<void> { return this.tree.onDidBlur; }\n\n\t/**\n\t * To be used internally only!\n\t * @deprecated\n\t */\n\tget onDidChangeModel(): Event<void> { return this.tree.onDidChangeModel; }\n\tget onDidChangeCollapseState(): Event<ICollapseStateChangeEvent<IAsyncDataTreeNode<TInput, T> | null, TFilterData>> { return this.tree.onDidChangeCollapseState; }\n\n\tget onDidUpdateOptions(): Event<IAsyncDataTreeOptionsUpdate> { return this.tree.onDidUpdateOptions; }\n\n\tget onDidChangeFindOpenState(): Event<boolean> { return this.tree.onDidChangeFindOpenState; }\n\tget onDidChangeStickyScrollFocused(): Event<boolean> { return this.tree.onDidChangeStickyScrollFocused; }\n\n\tget findMode(): TreeFindMode { return this.tree.findMode; }\n\tset findMode(mode: TreeFindMode) { this.tree.findMode = mode; }\n\treadonly onDidChangeFindMode: Event<TreeFindMode>;\n\n\tget findMatchType(): TreeFindMatchType { return this.tree.findMatchType; }\n\tset findMatchType(matchType: TreeFindMatchType) { this.tree.findMatchType = matchType; }\n\treadonly onDidChangeFindMatchType: Event<TreeFindMatchType>;\n\n\tget expandOnlyOnTwistieClick(): boolean | ((e: T) => boolean) {\n\t\tif (typeof this.tree.expandOnlyOnTwistieClick === 'boolean') {\n\t\t\treturn this.tree.expandOnlyOnTwistieClick;\n\t\t}\n\n\t\tconst fn = this.tree.expandOnlyOnTwistieClick;\n\t\treturn element => fn(this.nodes.get((element === this.root.element ? null : element) as T) || null);\n\t}\n\n\tget onDidDispose(): Event<void> { return this.tree.onDidDispose; }\n\n\tconstructor(\n\t\tprotected user: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ITreeRenderer<T, TFilterData, any>[],\n\t\tprivate dataSource: IAsyncDataSource<TInput, T>,\n\t\toptions: IAsyncDataTreeOptions<T, TFilterData> = {}\n\t) {\n\t\tthis.identityProvider = options.identityProvider;\n\t\tthis.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n\t\tthis.sorter = options.sorter;\n\t\tthis.getDefaultCollapseState = e => options.collapseByDefault ? (options.collapseByDefault(e) ? ObjectTreeElementCollapseState.PreserveOrCollapsed : ObjectTreeElementCollapseState.PreserveOrExpanded) : undefined;\n\n\t\tthis.tree = this.createTree(user, container, delegate, renderers, options);\n\t\tthis.onDidChangeFindMode = this.tree.onDidChangeFindMode;\n\t\tthis.onDidChangeFindMatchType = this.tree.onDidChangeFindMatchType;\n\n\t\tthis.root = createAsyncDataTreeNode({\n\t\t\telement: undefined!,\n\t\t\tparent: null,\n\t\t\thasChildren: true,\n\t\t\tdefaultCollapseState: undefined\n\t\t});\n\n\t\tif (this.identityProvider) {\n\t\t\tthis.root = {\n\t\t\t\t...this.root,\n\t\t\t\tid: null\n\t\t\t};\n\t\t}\n\n\t\tthis.nodes.set(null, this.root);\n\n\t\tthis.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\n\t}\n\n\tprotected createTree(\n\t\tuser: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ITreeRenderer<T, TFilterData, any>[],\n\t\toptions: IAsyncDataTreeOptions<T, TFilterData>\n\t): ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData> {\n\t\tconst objectTreeDelegate = new ComposedTreeDelegate<TInput | T, IAsyncDataTreeNode<TInput, T>>(delegate);\n\t\tconst objectTreeRenderers = renderers.map(r => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));\n\t\tconst objectTreeOptions = asObjectTreeOptions<TInput, T, TFilterData>(options) || {};\n\n\t\treturn new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n\t}\n\n\tupdateOptions(options: IAsyncDataTreeOptionsUpdate = {}): void {\n\t\tthis.tree.updateOptions(options);\n\t}\n\n\tget options(): IAsyncDataTreeOptions<T, TFilterData> {\n\t\treturn this.tree.options as IAsyncDataTreeOptions<T, TFilterData>;\n\t}\n\n\t// Widget\n\n\tgetHTMLElement(): HTMLElement {\n\t\treturn this.tree.getHTMLElement();\n\t}\n\n\tget contentHeight(): number {\n\t\treturn this.tree.contentHeight;\n\t}\n\n\tget contentWidth(): number {\n\t\treturn this.tree.contentWidth;\n\t}\n\n\tget onDidChangeContentHeight(): Event<number> {\n\t\treturn this.tree.onDidChangeContentHeight;\n\t}\n\n\tget onDidChangeContentWidth(): Event<number> {\n\t\treturn this.tree.onDidChangeContentWidth;\n\t}\n\n\tget scrollTop(): number {\n\t\treturn this.tree.scrollTop;\n\t}\n\n\tset scrollTop(scrollTop: number) {\n\t\tthis.tree.scrollTop = scrollTop;\n\t}\n\n\tget scrollLeft(): number {\n\t\treturn this.tree.scrollLeft;\n\t}\n\n\tset scrollLeft(scrollLeft: number) {\n\t\tthis.tree.scrollLeft = scrollLeft;\n\t}\n\n\tget scrollHeight(): number {\n\t\treturn this.tree.scrollHeight;\n\t}\n\n\tget renderHeight(): number {\n\t\treturn this.tree.renderHeight;\n\t}\n\n\tget lastVisibleElement(): T {\n\t\treturn this.tree.lastVisibleElement!.element as T;\n\t}\n\n\tget ariaLabel(): string {\n\t\treturn this.tree.ariaLabel;\n\t}\n\n\tset ariaLabel(value: string) {\n\t\tthis.tree.ariaLabel = value;\n\t}\n\n\tdomFocus(): void {\n\t\tthis.tree.domFocus();\n\t}\n\n\tlayout(height?: number, width?: number): void {\n\t\tthis.tree.layout(height, width);\n\t}\n\n\tstyle(styles: IListStyles): void {\n\t\tthis.tree.style(styles);\n\t}\n\n\t// Model\n\n\tgetInput(): TInput | undefined {\n\t\treturn this.root.element as TInput;\n\t}\n\n\tasync setInput(input: TInput, viewState?: IAsyncDataTreeViewState): Promise<void> {\n\t\tthis.refreshPromises.forEach(promise => promise.cancel());\n\t\tthis.refreshPromises.clear();\n\n\t\tthis.root.element = input!;\n\n\t\tconst viewStateContext = viewState && { viewState, focus: [], selection: [] } as IAsyncDataTreeViewStateContext<TInput, T>;\n\n\t\tawait this._updateChildren(input, true, false, viewStateContext);\n\n\t\tif (viewStateContext) {\n\t\t\tthis.tree.setFocus(viewStateContext.focus);\n\t\t\tthis.tree.setSelection(viewStateContext.selection);\n\t\t}\n\n\t\tif (viewState && typeof viewState.scrollTop === 'number') {\n\t\t\tthis.scrollTop = viewState.scrollTop;\n\t\t}\n\t}\n\n\tasync updateChildren(element: TInput | T = this.root.element, recursive = true, rerender = false, options?: IAsyncDataTreeUpdateChildrenOptions<T>): Promise<void> {\n\t\tawait this._updateChildren(element, recursive, rerender, undefined, options);\n\t}\n\n\tprivate async _updateChildren(element: TInput | T = this.root.element, recursive = true, rerender = false, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): Promise<void> {\n\t\tif (typeof this.root.element === 'undefined') {\n\t\t\tthrow new TreeError(this.user, 'Tree input not set');\n\t\t}\n\n\t\tif (this.root.refreshPromise) {\n\t\t\tawait this.root.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\tconst node = this.getDataNode(element);\n\t\tawait this.refreshAndRenderNode(node, recursive, viewStateContext, options);\n\n\t\tif (rerender) {\n\t\t\ttry {\n\t\t\t\tthis.tree.rerender(node);\n\t\t\t} catch {\n\t\t\t\t// missing nodes are fine, this could've resulted from\n\t\t\t\t// parallel refresh calls, removing `node` altogether\n\t\t\t}\n\t\t}\n\t}\n\n\tresort(element: TInput | T = this.root.element, recursive = true): void {\n\t\tthis.tree.resort(this.getDataNode(element), recursive);\n\t}\n\n\thasElement(element: TInput | T): boolean {\n\t\treturn this.tree.hasElement(this.getDataNode(element));\n\t}\n\n\thasNode(element: TInput | T): boolean {\n\t\treturn element === this.root.element || this.nodes.has(element as T);\n\t}\n\n\t// View\n\n\trerender(element?: T): void {\n\t\tif (element === undefined || element === this.root.element) {\n\t\t\tthis.tree.rerender();\n\t\t\treturn;\n\t\t}\n\n\t\tconst node = this.getDataNode(element);\n\t\tthis.tree.rerender(node);\n\t}\n\n\tupdateElementHeight(element: T, height: number | undefined): void {\n\t\tconst node = this.getDataNode(element);\n\t\tthis.tree.updateElementHeight(node, height);\n\t}\n\n\tupdateWidth(element: T): void {\n\t\tconst node = this.getDataNode(element);\n\t\tthis.tree.updateWidth(node);\n\t}\n\n\t// Tree\n\n\tgetNode(element: TInput | T = this.root.element): ITreeNode<TInput | T, TFilterData> {\n\t\tconst dataNode = this.getDataNode(element);\n\t\tconst node = this.tree.getNode(dataNode === this.root ? null : dataNode);\n\t\treturn this.nodeMapper.map(node);\n\t}\n\n\tcollapse(element: T, recursive: boolean = false): boolean {\n\t\tconst node = this.getDataNode(element);\n\t\treturn this.tree.collapse(node === this.root ? null : node, recursive);\n\t}\n\n\tasync expand(element: T, recursive: boolean = false): Promise<boolean> {\n\t\tif (typeof this.root.element === 'undefined') {\n\t\t\tthrow new TreeError(this.user, 'Tree input not set');\n\t\t}\n\n\t\tif (this.root.refreshPromise) {\n\t\t\tawait this.root.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\tconst node = this.getDataNode(element);\n\n\t\tif (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (node.refreshPromise) {\n\t\t\tawait this.root.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\tif (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst result = this.tree.expand(node === this.root ? null : node, recursive);\n\n\t\tif (node.refreshPromise) {\n\t\t\tawait this.root.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\ttoggleCollapsed(element: T, recursive: boolean = false): boolean {\n\t\treturn this.tree.toggleCollapsed(this.getDataNode(element), recursive);\n\t}\n\n\texpandAll(): void {\n\t\tthis.tree.expandAll();\n\t}\n\n\tasync expandTo(element: T): Promise<void> {\n\t\tif (!this.dataSource.getParent) {\n\t\t\tthrow new Error('Can\\'t expand to element without getParent method');\n\t\t}\n\n\t\tconst elements: T[] = [];\n\n\t\twhile (!this.hasNode(element)) {\n\t\t\telement = this.dataSource.getParent(element) as T;\n\n\t\t\tif (element !== this.root.element) {\n\t\t\t\telements.push(element);\n\t\t\t}\n\t\t}\n\n\t\tfor (const element of Iterable.reverse(elements)) {\n\t\t\tawait this.expand(element);\n\t\t}\n\n\t\tthis.tree.expandTo(this.getDataNode(element));\n\t}\n\n\tcollapseAll(): void {\n\t\tthis.tree.collapseAll();\n\t}\n\n\tisCollapsible(element: T): boolean {\n\t\treturn this.tree.isCollapsible(this.getDataNode(element));\n\t}\n\n\tisCollapsed(element: TInput | T): boolean {\n\t\treturn this.tree.isCollapsed(this.getDataNode(element));\n\t}\n\n\ttriggerTypeNavigation(): void {\n\t\tthis.tree.triggerTypeNavigation();\n\t}\n\n\topenFind(): void {\n\t\tthis.tree.openFind();\n\t}\n\n\tcloseFind(): void {\n\t\tthis.tree.closeFind();\n\t}\n\n\trefilter(): void {\n\t\tthis.tree.refilter();\n\t}\n\n\tsetAnchor(element: T | undefined): void {\n\t\tthis.tree.setAnchor(typeof element === 'undefined' ? undefined : this.getDataNode(element));\n\t}\n\n\tgetAnchor(): T | undefined {\n\t\tconst node = this.tree.getAnchor();\n\t\treturn node?.element as T;\n\t}\n\n\tsetSelection(elements: T[], browserEvent?: UIEvent): void {\n\t\tconst nodes = elements.map(e => this.getDataNode(e));\n\t\tthis.tree.setSelection(nodes, browserEvent);\n\t}\n\n\tgetSelection(): T[] {\n\t\tconst nodes = this.tree.getSelection();\n\t\treturn nodes.map(n => n!.element as T);\n\t}\n\n\tsetFocus(elements: T[], browserEvent?: UIEvent): void {\n\t\tconst nodes = elements.map(e => this.getDataNode(e));\n\t\tthis.tree.setFocus(nodes, browserEvent);\n\t}\n\n\tfocusNext(n = 1, loop = false, browserEvent?: UIEvent): void {\n\t\tthis.tree.focusNext(n, loop, browserEvent);\n\t}\n\n\tfocusPrevious(n = 1, loop = false, browserEvent?: UIEvent): void {\n\t\tthis.tree.focusPrevious(n, loop, browserEvent);\n\t}\n\n\tfocusNextPage(browserEvent?: UIEvent): Promise<void> {\n\t\treturn this.tree.focusNextPage(browserEvent);\n\t}\n\n\tfocusPreviousPage(browserEvent?: UIEvent): Promise<void> {\n\t\treturn this.tree.focusPreviousPage(browserEvent);\n\t}\n\n\tfocusLast(browserEvent?: UIEvent): void {\n\t\tthis.tree.focusLast(browserEvent);\n\t}\n\n\tfocusFirst(browserEvent?: UIEvent): void {\n\t\tthis.tree.focusFirst(browserEvent);\n\t}\n\n\tgetFocus(): T[] {\n\t\tconst nodes = this.tree.getFocus();\n\t\treturn nodes.map(n => n!.element as T);\n\t}\n\n\tgetStickyScrollFocus(): T[] {\n\t\tconst nodes = this.tree.getStickyScrollFocus();\n\t\treturn nodes.map(n => n!.element as T);\n\t}\n\n\tgetFocusedPart(): AbstractTreePart {\n\t\treturn this.tree.getFocusedPart();\n\t}\n\n\treveal(element: T, relativeTop?: number): void {\n\t\tthis.tree.reveal(this.getDataNode(element), relativeTop);\n\t}\n\n\tgetRelativeTop(element: T): number | null {\n\t\treturn this.tree.getRelativeTop(this.getDataNode(element));\n\t}\n\n\t// Tree navigation\n\n\tgetParentElement(element: T): TInput | T {\n\t\tconst node = this.tree.getParentElement(this.getDataNode(element));\n\t\treturn (node && node.element)!;\n\t}\n\n\tgetFirstElementChild(element: TInput | T = this.root.element): TInput | T | undefined {\n\t\tconst dataNode = this.getDataNode(element);\n\t\tconst node = this.tree.getFirstElementChild(dataNode === this.root ? null : dataNode);\n\t\treturn (node && node.element)!;\n\t}\n\n\t// Implementation\n\n\tprivate getDataNode(element: TInput | T): IAsyncDataTreeNode<TInput, T> {\n\t\tconst node: IAsyncDataTreeNode<TInput, T> | undefined = this.nodes.get((element === this.root.element ? null : element) as T);\n\n\t\tif (!node) {\n\t\t\tthrow new TreeError(this.user, `Data tree node not found: ${element}`);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tprivate async refreshAndRenderNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): Promise<void> {\n\t\tawait this.refreshNode(node, recursive, viewStateContext);\n\t\tif (this.disposables.isDisposed) {\n\t\t\treturn; // tree disposed during refresh (#199264)\n\t\t}\n\t\tthis.render(node, viewStateContext, options);\n\t}\n\n\tprivate async refreshNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<void> {\n\t\tlet result: Promise<void> | undefined;\n\n\t\tthis.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {\n\t\t\tif (!result && intersects(refreshNode, node)) {\n\t\t\t\tresult = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));\n\t\t\t}\n\t\t});\n\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\n\t\tif (node !== this.root) {\n\t\t\tconst treeNode = this.tree.getNode(node);\n\n\t\t\tif (treeNode.collapsed) {\n\t\t\t\tnode.hasChildren = !!this.dataSource.hasChildren(node.element);\n\t\t\t\tnode.stale = true;\n\t\t\t\tthis.setChildren(node, [], recursive, viewStateContext);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\treturn this.doRefreshSubTree(node, recursive, viewStateContext);\n\t}\n\n\tprivate async doRefreshSubTree(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<void> {\n\t\tlet done: () => void;\n\t\tnode.refreshPromise = new Promise(c => done = c);\n\t\tthis.subTreeRefreshPromises.set(node, node.refreshPromise);\n\n\t\tnode.refreshPromise.finally(() => {\n\t\t\tnode.refreshPromise = undefined;\n\t\t\tthis.subTreeRefreshPromises.delete(node);\n\t\t});\n\n\t\ttry {\n\t\t\tconst childrenToRefresh = await this.doRefreshNode(node, recursive, viewStateContext);\n\t\t\tnode.stale = false;\n\n\t\t\tawait Promises.settled(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));\n\t\t} finally {\n\t\t\tdone!();\n\t\t}\n\t}\n\n\tprivate async doRefreshNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<IAsyncDataTreeNode<TInput, T>[]> {\n\t\tnode.hasChildren = !!this.dataSource.hasChildren(node.element);\n\n\t\tlet childrenPromise: Promise<Iterable<T>>;\n\n\t\tif (!node.hasChildren) {\n\t\t\tchildrenPromise = Promise.resolve(Iterable.empty());\n\t\t} else {\n\t\t\tconst children = this.doGetChildren(node);\n\t\t\tif (isIterable(children)) {\n\t\t\t\tchildrenPromise = Promise.resolve(children);\n\t\t\t} else {\n\t\t\t\tconst slowTimeout = timeout(800);\n\n\t\t\t\tslowTimeout.then(() => {\n\t\t\t\t\tnode.slow = true;\n\t\t\t\t\tthis._onDidChangeNodeSlowState.fire(node);\n\t\t\t\t}, _ => null);\n\n\t\t\t\tchildrenPromise = children.finally(() => slowTimeout.cancel());\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tconst children = await childrenPromise;\n\t\t\treturn this.setChildren(node, children, recursive, viewStateContext);\n\t\t} catch (err) {\n\t\t\tif (node !== this.root && this.tree.hasElement(node)) {\n\t\t\t\tthis.tree.collapse(node);\n\t\t\t}\n\n\t\t\tif (isCancellationError(err)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tif (node.slow) {\n\t\t\t\tnode.slow = false;\n\t\t\t\tthis._onDidChangeNodeSlowState.fire(node);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doGetChildren(node: IAsyncDataTreeNode<TInput, T>): Promise<Iterable<T>> | Iterable<T> {\n\t\tlet result = this.refreshPromises.get(node);\n\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\t\tconst children = this.dataSource.getChildren(node.element);\n\t\tif (isIterable(children)) {\n\t\t\treturn this.processChildren(children);\n\t\t} else {\n\t\t\tresult = createCancelablePromise(async () => this.processChildren(await children));\n\t\t\tthis.refreshPromises.set(node, result);\n\t\t\treturn result.finally(() => { this.refreshPromises.delete(node); });\n\t\t}\n\t}\n\n\tprivate _onDidChangeCollapseState({ node, deep }: ICollapseStateChangeEvent<IAsyncDataTreeNode<TInput, T> | null, any>): void {\n\t\tif (node.element === null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!node.collapsed && node.element.stale) {\n\t\t\tif (deep) {\n\t\t\t\tthis.collapse(node.element.element as T);\n\t\t\t} else {\n\t\t\t\tthis.refreshAndRenderNode(node.element, false)\n\t\t\t\t\t.catch(onUnexpectedError);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate setChildren(node: IAsyncDataTreeNode<TInput, T>, childrenElementsIterable: Iterable<T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): IAsyncDataTreeNode<TInput, T>[] {\n\t\tconst childrenElements = [...childrenElementsIterable];\n\n\t\t// perf: if the node was and still is a leaf, avoid all this hassle\n\t\tif (node.children.length === 0 && childrenElements.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst nodesToForget = new Map<T, IAsyncDataTreeNode<TInput, T>>();\n\t\tconst childrenTreeNodesById = new Map<string, { node: IAsyncDataTreeNode<TInput, T>; collapsed: boolean }>();\n\n\t\tfor (const child of node.children) {\n\t\t\tnodesToForget.set(child.element as T, child);\n\n\t\t\tif (this.identityProvider) {\n\t\t\t\tchildrenTreeNodesById.set(child.id!, { node: child, collapsed: this.tree.hasElement(child) && this.tree.isCollapsed(child) });\n\t\t\t}\n\t\t}\n\n\t\tconst childrenToRefresh: IAsyncDataTreeNode<TInput, T>[] = [];\n\n\t\tconst children = childrenElements.map<IAsyncDataTreeNode<TInput, T>>(element => {\n\t\t\tconst hasChildren = !!this.dataSource.hasChildren(element);\n\n\t\t\tif (!this.identityProvider) {\n\t\t\t\tconst asyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, hasChildren, defaultCollapseState: this.getDefaultCollapseState(element) });\n\n\t\t\t\tif (hasChildren && asyncDataTreeNode.defaultCollapseState === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n\t\t\t\t\tchildrenToRefresh.push(asyncDataTreeNode);\n\t\t\t\t}\n\n\t\t\t\treturn asyncDataTreeNode;\n\t\t\t}\n\n\t\t\tconst id = this.identityProvider.getId(element).toString();\n\t\t\tconst result = childrenTreeNodesById.get(id);\n\n\t\t\tif (result) {\n\t\t\t\tconst asyncDataTreeNode = result.node;\n\n\t\t\t\tnodesToForget.delete(asyncDataTreeNode.element as T);\n\t\t\t\tthis.nodes.delete(asyncDataTreeNode.element as T);\n\t\t\t\tthis.nodes.set(element, asyncDataTreeNode);\n\n\t\t\t\tasyncDataTreeNode.element = element;\n\t\t\t\tasyncDataTreeNode.hasChildren = hasChildren;\n\n\t\t\t\tif (recursive) {\n\t\t\t\t\tif (result.collapsed) {\n\t\t\t\t\t\tasyncDataTreeNode.children.forEach(node => dfs(node, node => this.nodes.delete(node.element as T)));\n\t\t\t\t\t\tasyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);\n\t\t\t\t\t\tasyncDataTreeNode.stale = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchildrenToRefresh.push(asyncDataTreeNode);\n\t\t\t\t\t}\n\t\t\t\t} else if (hasChildren && !result.collapsed) {\n\t\t\t\t\tchildrenToRefresh.push(asyncDataTreeNode);\n\t\t\t\t}\n\n\t\t\t\treturn asyncDataTreeNode;\n\t\t\t}\n\n\t\t\tconst childAsyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, id, hasChildren, defaultCollapseState: this.getDefaultCollapseState(element) });\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\n\t\t\t\tviewStateContext.focus.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\n\t\t\t\tviewStateContext.selection.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\n\t\t\t\tchildrenToRefresh.push(childAsyncDataTreeNode);\n\t\t\t} else if (hasChildren && childAsyncDataTreeNode.defaultCollapseState === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n\t\t\t\tchildrenToRefresh.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\treturn childAsyncDataTreeNode;\n\t\t});\n\n\t\tfor (const node of nodesToForget.values()) {\n\t\t\tdfs(node, node => this.nodes.delete(node.element as T));\n\t\t}\n\n\t\tfor (const child of children) {\n\t\t\tthis.nodes.set(child.element as T, child);\n\t\t}\n\n\t\tnode.children.splice(0, node.children.length, ...children);\n\n\t\t// TODO@joao this doesn't take filter into account\n\t\tif (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {\n\t\t\tchildren[0].forceExpanded = true;\n\t\t\tchildrenToRefresh.push(children[0]);\n\t\t}\n\n\t\treturn childrenToRefresh;\n\t}\n\n\tprotected render(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): void {\n\t\tconst children = node.children.map(node => this.asTreeElement(node, viewStateContext));\n\t\tconst objectTreeOptions: IObjectTreeSetChildrenOptions<IAsyncDataTreeNode<TInput, T>> | undefined = options && {\n\t\t\t...options,\n\t\t\tdiffIdentityProvider: options.diffIdentityProvider && {\n\t\t\t\tgetId(node: IAsyncDataTreeNode<TInput, T>): { toString(): string } {\n\t\t\t\t\treturn options.diffIdentityProvider!.getId(node.element as T);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.tree.setChildren(node === this.root ? null : node, children, objectTreeOptions);\n\n\t\tif (node !== this.root) {\n\t\t\tthis.tree.setCollapsible(node, node.hasChildren);\n\t\t}\n\n\t\tthis._onDidRender.fire();\n\t}\n\n\tprotected asTreeElement(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): IObjectTreeElement<IAsyncDataTreeNode<TInput, T>> {\n\t\tif (node.stale) {\n\t\t\treturn {\n\t\t\t\telement: node,\n\t\t\t\tcollapsible: node.hasChildren,\n\t\t\t\tcollapsed: true\n\t\t\t};\n\t\t}\n\n\t\tlet collapsed: boolean | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded | undefined;\n\n\t\tif (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {\n\t\t\tcollapsed = false;\n\t\t} else if (node.forceExpanded) {\n\t\t\tcollapsed = false;\n\t\t\tnode.forceExpanded = false;\n\t\t} else {\n\t\t\tcollapsed = node.defaultCollapseState;\n\t\t}\n\n\t\treturn {\n\t\t\telement: node,\n\t\t\tchildren: node.hasChildren ? Iterable.map(node.children, child => this.asTreeElement(child, viewStateContext)) : [],\n\t\t\tcollapsible: node.hasChildren,\n\t\t\tcollapsed\n\t\t};\n\t}\n\n\tprotected processChildren(children: Iterable<T>): Iterable<T> {\n\t\tif (this.sorter) {\n\t\t\tchildren = [...children].sort(this.sorter.compare.bind(this.sorter));\n\t\t}\n\n\t\treturn children;\n\t}\n\n\t// view state\n\n\tgetViewState(): IAsyncDataTreeViewState {\n\t\tif (!this.identityProvider) {\n\t\t\tthrow new TreeError(this.user, 'Can\\'t get tree view state without an identity provider');\n\t\t}\n\n\t\tconst getId = (element: T) => this.identityProvider!.getId(element).toString();\n\t\tconst focus = this.getFocus().map(getId);\n\t\tconst selection = this.getSelection().map(getId);\n\n\t\tconst expanded: string[] = [];\n\t\tconst root = this.tree.getNode();\n\t\tconst stack = [root];\n\n\t\twhile (stack.length > 0) {\n\t\t\tconst node = stack.pop()!;\n\n\t\t\tif (node !== root && node.collapsible && !node.collapsed) {\n\t\t\t\texpanded.push(getId(node.element!.element as T));\n\t\t\t}\n\n\t\t\tstack.push(...node.children);\n\t\t}\n\n\t\treturn { focus, selection, expanded, scrollTop: this.scrollTop };\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.dispose();\n\t\tthis.tree.dispose();\n\t}\n}\n\ntype CompressibleAsyncDataTreeNodeMapper<TInput, T, TFilterData> = WeakMapper<ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>, ITreeNode<ICompressedTreeNode<TInput | T>, TFilterData>>;\n\nclass CompressibleAsyncDataTreeNodeWrapper<TInput, T, TFilterData> implements ITreeNode<ICompressedTreeNode<TInput | T>, TFilterData> {\n\n\tget element(): ICompressedTreeNode<TInput | T> {\n\t\treturn {\n\t\t\telements: this.node.element.elements.map(e => e.element),\n\t\t\tincompressible: this.node.element.incompressible\n\t\t};\n\t}\n\n\tget children(): ITreeNode<ICompressedTreeNode<TInput | T>, TFilterData>[] { return this.node.children.map(node => new CompressibleAsyncDataTreeNodeWrapper(node)); }\n\tget depth(): number { return this.node.depth; }\n\tget visibleChildrenCount(): number { return this.node.visibleChildrenCount; }\n\tget visibleChildIndex(): number { return this.node.visibleChildIndex; }\n\tget collapsible(): boolean { return this.node.collapsible; }\n\tget collapsed(): boolean { return this.node.collapsed; }\n\tget visible(): boolean { return this.node.visible; }\n\tget filterData(): TFilterData | undefined { return this.node.filterData; }\n\n\tconstructor(private node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>) { }\n}\n\nclass CompressibleAsyncDataTreeRenderer<TInput, T, TFilterData, TTemplateData> implements ICompressibleTreeRenderer<IAsyncDataTreeNode<TInput, T>, TFilterData, IDataTreeListTemplateData<TTemplateData>> {\n\n\treadonly templateId: string;\n\tprivate renderedNodes = new Map<IAsyncDataTreeNode<TInput, T>, IDataTreeListTemplateData<TTemplateData>>();\n\tprivate disposables: IDisposable[] = [];\n\n\tconstructor(\n\t\tprotected renderer: ICompressibleTreeRenderer<T, TFilterData, TTemplateData>,\n\t\tprotected nodeMapper: AsyncDataTreeNodeMapper<TInput, T, TFilterData>,\n\t\tprivate compressibleNodeMapperProvider: () => CompressibleAsyncDataTreeNodeMapper<TInput, T, TFilterData>,\n\t\treadonly onDidChangeTwistieState: Event<IAsyncDataTreeNode<TInput, T>>\n\t) {\n\t\tthis.templateId = renderer.templateId;\n\t}\n\n\trenderTemplate(container: HTMLElement): IDataTreeListTemplateData<TTemplateData> {\n\t\tconst templateData = this.renderer.renderTemplate(container);\n\t\treturn { templateData };\n\t}\n\n\trenderElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.renderElement(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\trenderCompressedElements(node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node) as ITreeNode<ICompressedTreeNode<T>, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\trenderTwistie(element: IAsyncDataTreeNode<TInput, T>, twistieElement: HTMLElement): boolean {\n\t\tif (element.slow) {\n\t\t\ttwistieElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn true;\n\t\t} else {\n\t\t\ttwistieElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tdisposeElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.disposeElement?.(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\tdisposeCompressedElements(node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.disposeCompressedElements?.(this.compressibleNodeMapperProvider().map(node) as ITreeNode<ICompressedTreeNode<T>, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\tdisposeTemplate(templateData: IDataTreeListTemplateData<TTemplateData>): void {\n\t\tthis.renderer.disposeTemplate(templateData.templateData);\n\t}\n\n\tdispose(): void {\n\t\tthis.renderedNodes.clear();\n\t\tthis.disposables = dispose(this.disposables);\n\t}\n}\n\nexport interface ITreeCompressionDelegate<T> {\n\tisIncompressible(element: T): boolean;\n}\n\nfunction asCompressibleObjectTreeOptions<TInput, T, TFilterData>(options?: ICompressibleAsyncDataTreeOptions<T, TFilterData>): ICompressibleObjectTreeOptions<IAsyncDataTreeNode<TInput, T>, TFilterData> | undefined {\n\tconst objectTreeOptions = options && asObjectTreeOptions(options);\n\n\treturn objectTreeOptions && {\n\t\t...objectTreeOptions,\n\t\tkeyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && {\n\t\t\t...objectTreeOptions.keyboardNavigationLabelProvider,\n\t\t\tgetCompressedNodeKeyboardNavigationLabel(els) {\n\t\t\t\treturn options.keyboardNavigationLabelProvider!.getCompressedNodeKeyboardNavigationLabel(els.map(e => e.element as T));\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport interface ICompressibleAsyncDataTreeOptions<T, TFilterData = void> extends IAsyncDataTreeOptions<T, TFilterData> {\n\treadonly compressionEnabled?: boolean;\n\treadonly keyboardNavigationLabelProvider?: ICompressibleKeyboardNavigationLabelProvider<T>;\n}\n\nexport interface ICompressibleAsyncDataTreeOptionsUpdate extends IAsyncDataTreeOptionsUpdate {\n\treadonly compressionEnabled?: boolean;\n}\n\nexport class CompressibleAsyncDataTree<TInput, T, TFilterData = void> extends AsyncDataTree<TInput, T, TFilterData> {\n\n\tprotected declare readonly tree: CompressibleObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData>;\n\tprotected readonly compressibleNodeMapper: CompressibleAsyncDataTreeNodeMapper<TInput, T, TFilterData> = new WeakMapper(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n\tprivate filter?: ITreeFilter<T, TFilterData>;\n\n\tconstructor(\n\t\tuser: string,\n\t\tcontainer: HTMLElement,\n\t\tvirtualDelegate: IListVirtualDelegate<T>,\n\t\tprivate compressionDelegate: ITreeCompressionDelegate<T>,\n\t\trenderers: ICompressibleTreeRenderer<T, TFilterData, any>[],\n\t\tdataSource: IAsyncDataSource<TInput, T>,\n\t\toptions: ICompressibleAsyncDataTreeOptions<T, TFilterData> = {}\n\t) {\n\t\tsuper(user, container, virtualDelegate, renderers, dataSource, options);\n\t\tthis.filter = options.filter;\n\t}\n\n\tprotected override createTree(\n\t\tuser: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ICompressibleTreeRenderer<T, TFilterData, any>[],\n\t\toptions: ICompressibleAsyncDataTreeOptions<T, TFilterData>\n\t): ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData> {\n\t\tconst objectTreeDelegate = new ComposedTreeDelegate<TInput | T, IAsyncDataTreeNode<TInput, T>>(delegate);\n\t\tconst objectTreeRenderers = renderers.map(r => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));\n\t\tconst objectTreeOptions = asCompressibleObjectTreeOptions<TInput, T, TFilterData>(options) || {};\n\n\t\treturn new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n\t}\n\n\tprotected override asTreeElement(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): ICompressedTreeElement<IAsyncDataTreeNode<TInput, T>> {\n\t\treturn {\n\t\t\tincompressible: this.compressionDelegate.isIncompressible(node.element as T),\n\t\t\t...super.asTreeElement(node, viewStateContext)\n\t\t};\n\t}\n\n\toverride updateOptions(options: ICompressibleAsyncDataTreeOptionsUpdate = {}): void {\n\t\tthis.tree.updateOptions(options);\n\t}\n\n\toverride getViewState(): IAsyncDataTreeViewState {\n\t\tif (!this.identityProvider) {\n\t\t\tthrow new TreeError(this.user, 'Can\\'t get tree view state without an identity provider');\n\t\t}\n\n\t\tconst getId = (element: T) => this.identityProvider!.getId(element).toString();\n\t\tconst focus = this.getFocus().map(getId);\n\t\tconst selection = this.getSelection().map(getId);\n\n\t\tconst expanded: string[] = [];\n\t\tconst root = this.tree.getCompressedTreeNode();\n\t\tconst stack = [root];\n\n\t\twhile (stack.length > 0) {\n\t\t\tconst node = stack.pop()!;\n\n\t\t\tif (node !== root && node.collapsible && !node.collapsed) {\n\t\t\t\tfor (const asyncNode of node.element!.elements) {\n\t\t\t\t\texpanded.push(getId(asyncNode.element as T));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstack.push(...node.children);\n\t\t}\n\n\t\treturn { focus, selection, expanded, scrollTop: this.scrollTop };\n\t}\n\n\tprotected override render(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): void {\n\t\tif (!this.identityProvider) {\n\t\t\treturn super.render(node, viewStateContext);\n\t\t}\n\n\t\t// Preserve traits across compressions. Hacky but does the trick.\n\t\t// This is hard to fix properly since it requires rewriting the traits\n\t\t// across trees and lists. Let's just keep it this way for now.\n\t\tconst getId = (element: T) => this.identityProvider!.getId(element).toString();\n\t\tconst getUncompressedIds = (nodes: IAsyncDataTreeNode<TInput, T>[]): Set<string> => {\n\t\t\tconst result = new Set<string>();\n\n\t\t\tfor (const node of nodes) {\n\t\t\t\tconst compressedNode = this.tree.getCompressedTreeNode(node === this.root ? null : node);\n\n\t\t\t\tif (!compressedNode.element) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (const node of compressedNode.element.elements) {\n\t\t\t\t\tresult.add(getId(node.element as T));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\tconst oldSelection = getUncompressedIds(this.tree.getSelection() as IAsyncDataTreeNode<TInput, T>[]);\n\t\tconst oldFocus = getUncompressedIds(this.tree.getFocus() as IAsyncDataTreeNode<TInput, T>[]);\n\n\t\tsuper.render(node, viewStateContext, options);\n\n\t\tconst selection = this.getSelection();\n\t\tlet didChangeSelection = false;\n\n\t\tconst focus = this.getFocus();\n\t\tlet didChangeFocus = false;\n\n\t\tconst visit = (node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>> | null, TFilterData>) => {\n\t\t\tconst compressedNode = node.element;\n\n\t\t\tif (compressedNode) {\n\t\t\t\tfor (let i = 0; i < compressedNode.elements.length; i++) {\n\t\t\t\t\tconst id = getId(compressedNode.elements[i].element as T);\n\t\t\t\t\tconst element = compressedNode.elements[compressedNode.elements.length - 1].element as T;\n\n\t\t\t\t\t// github.com/microsoft/vscode/issues/85938\n\t\t\t\t\tif (oldSelection.has(id) && selection.indexOf(element) === -1) {\n\t\t\t\t\t\tselection.push(element);\n\t\t\t\t\t\tdidChangeSelection = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (oldFocus.has(id) && focus.indexOf(element) === -1) {\n\t\t\t\t\t\tfocus.push(element);\n\t\t\t\t\t\tdidChangeFocus = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode.children.forEach(visit);\n\t\t};\n\n\t\tvisit(this.tree.getCompressedTreeNode(node === this.root ? null : node));\n\n\t\tif (didChangeSelection) {\n\t\t\tthis.setSelection(selection);\n\t\t}\n\n\t\tif (didChangeFocus) {\n\t\t\tthis.setFocus(focus);\n\t\t}\n\t}\n\n\t// For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work\n\t// and we have to filter everything beforehand\n\t// Related to #85193 and #85835\n\tprotected override processChildren(children: Iterable<T>): Iterable<T> {\n\t\tif (this.filter) {\n\t\t\tchildren = Iterable.filter(children, e => {\n\t\t\t\tconst result = this.filter!.filter(e, TreeVisibility.Visible);\n\t\t\t\tconst visibility = getVisibility(result);\n\n\t\t\t\tif (visibility === TreeVisibility.Recurse) {\n\t\t\t\t\tthrow new Error('Recursive tree visibility not supported in async data compressed trees');\n\t\t\t\t}\n\n\t\t\t\treturn visibility === TreeVisibility.Visible;\n\t\t\t});\n\t\t}\n\n\t\treturn super.processChildren(children);\n\t}\n}\n\nfunction getVisibility<TFilterData>(filterResult: TreeFilterResult<TFilterData>): TreeVisibility {\n\tif (typeof filterResult === 'boolean') {\n\t\treturn filterResult ? TreeVisibility.Visible : TreeVisibility.Hidden;\n\t} else if (isFilterResult(filterResult)) {\n\t\treturn getVisibleState(filterResult.visibility);\n\t} else {\n\t\treturn getVisibleState(filterResult);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDragAndDropData } from '../../dnd';\nimport { IIdentityProvider, IListDragAndDrop, IListDragOverReaction, IListVirtualDelegate } from '../list/list';\nimport { ElementsDragAndDropData, ListViewTargetSector } from '../list/listView';\nimport { IListStyles } from '../list/listWidget';\nimport { ComposedTreeDelegate, TreeFindMode as TreeFindMode, IAbstractTreeOptions, IAbstractTreeOptionsUpdate, TreeFindMatchType, AbstractTreePart } from './abstractTree';\nimport { ICompressedTreeElement, ICompressedTreeNode } from './compressedObjectTreeModel';\nimport { getVisibleState, isFilterResult } from './indexTreeModel';\nimport { CompressibleObjectTree, ICompressibleKeyboardNavigationLabelProvider, ICompressibleObjectTreeOptions, ICompressibleTreeRenderer, IObjectTreeOptions, IObjectTreeSetChildrenOptions, ObjectTree } from './objectTree';\nimport { IAsyncDataSource, ICollapseStateChangeEvent, IObjectTreeElement, ITreeContextMenuEvent, ITreeDragAndDrop, ITreeEvent, ITreeFilter, ITreeMouseEvent, ITreeNode, ITreeRenderer, ITreeSorter, ObjectTreeElementCollapseState, TreeError, TreeFilterResult, TreeVisibility, WeakMapper } from './tree';\nimport { CancelablePromise, createCancelablePromise, Promises, timeout } from '../../../common/async';\nimport { Codicon } from '../../../common/codicons';\nimport { ThemeIcon } from '../../../common/themables';\nimport { isCancellationError, onUnexpectedError } from '../../../common/errors';\nimport { Emitter, Event } from '../../../common/event';\nimport { Iterable } from '../../../common/iterator';\nimport { DisposableStore, dispose, IDisposable } from '../../../common/lifecycle';\nimport { ScrollEvent } from '../../../common/scrollable';\nimport { isIterable } from '../../../common/types';\n\ninterface IAsyncDataTreeNode<TInput, T> {\n\telement: TInput | T;\n\treadonly parent: IAsyncDataTreeNode<TInput, T> | null;\n\treadonly children: IAsyncDataTreeNode<TInput, T>[];\n\treadonly id?: string | null;\n\trefreshPromise: Promise<void> | undefined;\n\thasChildren: boolean;\n\tstale: boolean;\n\tslow: boolean;\n\treadonly defaultCollapseState: undefined | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded;\n\tforceExpanded: boolean;\n}\n\ninterface IAsyncDataTreeNodeRequiredProps<TInput, T> extends Partial<IAsyncDataTreeNode<TInput, T>> {\n\treadonly element: TInput | T;\n\treadonly parent: IAsyncDataTreeNode<TInput, T> | null;\n\treadonly hasChildren: boolean;\n\treadonly defaultCollapseState: undefined | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded;\n}\n\nfunction createAsyncDataTreeNode<TInput, T>(props: IAsyncDataTreeNodeRequiredProps<TInput, T>): IAsyncDataTreeNode<TInput, T> {\n\treturn {\n\t\t...props,\n\t\tchildren: [],\n\t\trefreshPromise: undefined,\n\t\tstale: true,\n\t\tslow: false,\n\t\tforceExpanded: false\n\t};\n}\n\nfunction isAncestor<TInput, T>(ancestor: IAsyncDataTreeNode<TInput, T>, descendant: IAsyncDataTreeNode<TInput, T>): boolean {\n\tif (!descendant.parent) {\n\t\treturn false;\n\t} else if (descendant.parent === ancestor) {\n\t\treturn true;\n\t} else {\n\t\treturn isAncestor(ancestor, descendant.parent);\n\t}\n}\n\nfunction intersects<TInput, T>(node: IAsyncDataTreeNode<TInput, T>, other: IAsyncDataTreeNode<TInput, T>): boolean {\n\treturn node === other || isAncestor(node, other) || isAncestor(other, node);\n}\n\ninterface IDataTreeListTemplateData<T> {\n\ttemplateData: T;\n}\n\ntype AsyncDataTreeNodeMapper<TInput, T, TFilterData> = WeakMapper<ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>, ITreeNode<TInput | T, TFilterData>>;\n\nclass AsyncDataTreeNodeWrapper<TInput, T, TFilterData> implements ITreeNode<TInput | T, TFilterData> {\n\n\tget element(): T { return this.node.element!.element as T; }\n\tget children(): ITreeNode<T, TFilterData>[] { return this.node.children.map(node => new AsyncDataTreeNodeWrapper(node)); }\n\tget depth(): number { return this.node.depth; }\n\tget visibleChildrenCount(): number { return this.node.visibleChildrenCount; }\n\tget visibleChildIndex(): number { return this.node.visibleChildIndex; }\n\tget collapsible(): boolean { return this.node.collapsible; }\n\tget collapsed(): boolean { return this.node.collapsed; }\n\tget visible(): boolean { return this.node.visible; }\n\tget filterData(): TFilterData | undefined { return this.node.filterData; }\n\n\tconstructor(private node: ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>) { }\n}\n\nclass AsyncDataTreeRenderer<TInput, T, TFilterData, TTemplateData> implements ITreeRenderer<IAsyncDataTreeNode<TInput, T>, TFilterData, IDataTreeListTemplateData<TTemplateData>> {\n\n\treadonly templateId: string;\n\tprivate renderedNodes = new Map<IAsyncDataTreeNode<TInput, T>, IDataTreeListTemplateData<TTemplateData>>();\n\n\tconstructor(\n\t\tprotected renderer: ITreeRenderer<T, TFilterData, TTemplateData>,\n\t\tprotected nodeMapper: AsyncDataTreeNodeMapper<TInput, T, TFilterData>,\n\t\treadonly onDidChangeTwistieState: Event<IAsyncDataTreeNode<TInput, T>>\n\t) {\n\t\tthis.templateId = renderer.templateId;\n\t}\n\n\trenderTemplate(container: HTMLElement): IDataTreeListTemplateData<TTemplateData> {\n\t\tconst templateData = this.renderer.renderTemplate(container);\n\t\treturn { templateData };\n\t}\n\n\trenderElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.renderElement(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\trenderTwistie(element: IAsyncDataTreeNode<TInput, T>, twistieElement: HTMLElement): boolean {\n\t\tif (element.slow) {\n\t\t\ttwistieElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn true;\n\t\t} else {\n\t\t\ttwistieElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tdisposeElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.disposeElement?.(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\tdisposeTemplate(templateData: IDataTreeListTemplateData<TTemplateData>): void {\n\t\tthis.renderer.disposeTemplate(templateData.templateData);\n\t}\n\n\tdispose(): void {\n\t\tthis.renderedNodes.clear();\n\t}\n}\n\nfunction asTreeEvent<TInput, T>(e: ITreeEvent<IAsyncDataTreeNode<TInput, T> | null>): ITreeEvent<T> {\n\treturn {\n\t\tbrowserEvent: e.browserEvent,\n\t\telements: e.elements.map(e => e!.element as T)\n\t};\n}\n\nfunction asTreeMouseEvent<TInput, T>(e: ITreeMouseEvent<IAsyncDataTreeNode<TInput, T> | null>): ITreeMouseEvent<T> {\n\treturn {\n\t\tbrowserEvent: e.browserEvent,\n\t\telement: e.element && e.element.element as T,\n\t\ttarget: e.target\n\t};\n}\n\nfunction asTreeContextMenuEvent<TInput, T>(e: ITreeContextMenuEvent<IAsyncDataTreeNode<TInput, T> | null>): ITreeContextMenuEvent<T> {\n\treturn {\n\t\tbrowserEvent: e.browserEvent,\n\t\telement: e.element && e.element.element as T,\n\t\tanchor: e.anchor,\n\t\tisStickyScroll: e.isStickyScroll\n\t};\n}\n\nclass AsyncDataTreeElementsDragAndDropData<TInput, T, TContext> extends ElementsDragAndDropData<T, TContext> {\n\n\toverride set context(context: TContext | undefined) {\n\t\tthis.data.context = context;\n\t}\n\n\toverride get context(): TContext | undefined {\n\t\treturn this.data.context;\n\t}\n\n\tconstructor(private data: ElementsDragAndDropData<IAsyncDataTreeNode<TInput, T>, TContext>) {\n\t\tsuper(data.elements.map(node => node.element as T));\n\t}\n}\n\nfunction asAsyncDataTreeDragAndDropData<TInput, T>(data: IDragAndDropData): IDragAndDropData {\n\tif (data instanceof ElementsDragAndDropData) {\n\t\treturn new AsyncDataTreeElementsDragAndDropData(data);\n\t}\n\n\treturn data;\n}\n\nclass AsyncDataTreeNodeListDragAndDrop<TInput, T> implements IListDragAndDrop<IAsyncDataTreeNode<TInput, T>> {\n\n\tconstructor(private dnd: ITreeDragAndDrop<T>) { }\n\n\tgetDragURI(node: IAsyncDataTreeNode<TInput, T>): string | null {\n\t\treturn this.dnd.getDragURI(node.element as T);\n\t}\n\n\tgetDragLabel(nodes: IAsyncDataTreeNode<TInput, T>[], originalEvent: DragEvent): string | undefined {\n\t\tif (this.dnd.getDragLabel) {\n\t\t\treturn this.dnd.getDragLabel(nodes.map(node => node.element as T), originalEvent);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tonDragStart(data: IDragAndDropData, originalEvent: DragEvent): void {\n\t\tthis.dnd.onDragStart?.(asAsyncDataTreeDragAndDropData(data), originalEvent);\n\t}\n\n\tonDragOver(data: IDragAndDropData, targetNode: IAsyncDataTreeNode<TInput, T> | undefined, targetIndex: number | undefined, targetSector: ListViewTargetSector | undefined, originalEvent: DragEvent, raw = true): boolean | IListDragOverReaction {\n\t\treturn this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element as T, targetIndex, targetSector, originalEvent);\n\t}\n\n\tdrop(data: IDragAndDropData, targetNode: IAsyncDataTreeNode<TInput, T> | undefined, targetIndex: number | undefined, targetSector: ListViewTargetSector | undefined, originalEvent: DragEvent): void {\n\t\tthis.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element as T, targetIndex, targetSector, originalEvent);\n\t}\n\n\tonDragEnd(originalEvent: DragEvent): void {\n\t\tthis.dnd.onDragEnd?.(originalEvent);\n\t}\n\n\tdispose(): void {\n\t\tthis.dnd.dispose();\n\t}\n}\n\nfunction asObjectTreeOptions<TInput, T, TFilterData>(options?: IAsyncDataTreeOptions<T, TFilterData>): IObjectTreeOptions<IAsyncDataTreeNode<TInput, T>, TFilterData> | undefined {\n\treturn options && {\n\t\t...options,\n\t\tcollapseByDefault: true,\n\t\tidentityProvider: options.identityProvider && {\n\t\t\tgetId(el) {\n\t\t\t\treturn options.identityProvider!.getId(el.element as T);\n\t\t\t}\n\t\t},\n\t\tdnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd),\n\t\tmultipleSelectionController: options.multipleSelectionController && {\n\t\t\tisSelectionSingleChangeEvent(e) {\n\t\t\t\treturn options.multipleSelectionController!.isSelectionSingleChangeEvent({ ...e, element: e.element } as any);\n\t\t\t},\n\t\t\tisSelectionRangeChangeEvent(e) {\n\t\t\t\treturn options.multipleSelectionController!.isSelectionRangeChangeEvent({ ...e, element: e.element } as any);\n\t\t\t}\n\t\t},\n\t\taccessibilityProvider: options.accessibilityProvider && {\n\t\t\t...options.accessibilityProvider,\n\t\t\tgetPosInSet: undefined,\n\t\t\tgetSetSize: undefined,\n\t\t\tgetRole: options.accessibilityProvider.getRole ? (el) => {\n\t\t\t\treturn options.accessibilityProvider!.getRole!(el.element as T);\n\t\t\t} : () => 'treeitem',\n\t\t\tisChecked: options.accessibilityProvider.isChecked ? (e) => {\n\t\t\t\treturn !!(options.accessibilityProvider?.isChecked!(e.element as T));\n\t\t\t} : undefined,\n\t\t\tgetAriaLabel(e) {\n\t\t\t\treturn options.accessibilityProvider!.getAriaLabel(e.element as T);\n\t\t\t},\n\t\t\tgetWidgetAriaLabel() {\n\t\t\t\treturn options.accessibilityProvider!.getWidgetAriaLabel();\n\t\t\t},\n\t\t\tgetWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider!.getWidgetRole!() : () => 'tree',\n\t\t\tgetAriaLevel: options.accessibilityProvider.getAriaLevel && (node => {\n\t\t\t\treturn options.accessibilityProvider!.getAriaLevel!(node.element as T);\n\t\t\t}),\n\t\t\tgetActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n\t\t\t\treturn options.accessibilityProvider!.getActiveDescendantId!(node.element as T);\n\t\t\t})\n\t\t},\n\t\tfilter: options.filter && {\n\t\t\tfilter(e, parentVisibility) {\n\t\t\t\treturn options.filter!.filter(e.element as T, parentVisibility);\n\t\t\t}\n\t\t},\n\t\tkeyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {\n\t\t\t...options.keyboardNavigationLabelProvider,\n\t\t\tgetKeyboardNavigationLabel(e) {\n\t\t\t\treturn options.keyboardNavigationLabelProvider!.getKeyboardNavigationLabel(e.element as T);\n\t\t\t}\n\t\t},\n\t\tsorter: undefined,\n\t\texpandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : (\n\t\t\ttypeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : (\n\t\t\t\te => (options.expandOnlyOnTwistieClick as ((e: T) => boolean))(e.element as T)\n\t\t\t)\n\t\t),\n\t\tdefaultFindVisibility: e => {\n\t\t\tif (e.hasChildren && e.stale) {\n\t\t\t\treturn TreeVisibility.Visible;\n\t\t\t} else if (typeof options.defaultFindVisibility === 'number') {\n\t\t\t\treturn options.defaultFindVisibility;\n\t\t\t} else if (typeof options.defaultFindVisibility === 'undefined') {\n\t\t\t\treturn TreeVisibility.Recurse;\n\t\t\t} else {\n\t\t\t\treturn (options.defaultFindVisibility as ((e: T) => TreeVisibility))(e.element as T);\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport interface IAsyncDataTreeOptionsUpdate extends IAbstractTreeOptionsUpdate { }\nexport interface IAsyncDataTreeUpdateChildrenOptions<T> extends IObjectTreeSetChildrenOptions<T> { }\n\nexport interface IAsyncDataTreeOptions<T, TFilterData = void> extends IAsyncDataTreeOptionsUpdate, Pick<IAbstractTreeOptions<T, TFilterData>, Exclude<keyof IAbstractTreeOptions<T, TFilterData>, 'collapseByDefault'>> {\n\treadonly collapseByDefault?: { (e: T): boolean };\n\treadonly identityProvider?: IIdentityProvider<T>;\n\treadonly sorter?: ITreeSorter<T>;\n\treadonly autoExpandSingleChildren?: boolean;\n}\n\nexport interface IAsyncDataTreeViewState {\n\treadonly focus?: string[];\n\treadonly selection?: string[];\n\treadonly expanded?: string[];\n\treadonly scrollTop?: number;\n}\n\ninterface IAsyncDataTreeViewStateContext<TInput, T> {\n\treadonly viewState: IAsyncDataTreeViewState;\n\treadonly selection: IAsyncDataTreeNode<TInput, T>[];\n\treadonly focus: IAsyncDataTreeNode<TInput, T>[];\n}\n\nfunction dfs<TInput, T>(node: IAsyncDataTreeNode<TInput, T>, fn: (node: IAsyncDataTreeNode<TInput, T>) => void): void {\n\tfn(node);\n\tnode.children.forEach(child => dfs(child, fn));\n}\n\nexport class AsyncDataTree<TInput, T, TFilterData = void> implements IDisposable {\n\n\tprotected readonly tree: ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData>;\n\tprotected readonly root: IAsyncDataTreeNode<TInput, T>;\n\tprivate readonly nodes = new Map<null | T, IAsyncDataTreeNode<TInput, T>>();\n\tprivate readonly sorter?: ITreeSorter<T>;\n\tprivate readonly getDefaultCollapseState: { (e: T): undefined | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded };\n\n\tprivate readonly subTreeRefreshPromises = new Map<IAsyncDataTreeNode<TInput, T>, Promise<void>>();\n\tprivate readonly refreshPromises = new Map<IAsyncDataTreeNode<TInput, T>, CancelablePromise<Iterable<T>>>();\n\n\tprotected readonly identityProvider?: IIdentityProvider<T>;\n\tprivate readonly autoExpandSingleChildren: boolean;\n\n\tprivate readonly _onDidRender = new Emitter<void>();\n\tprotected readonly _onDidChangeNodeSlowState = new Emitter<IAsyncDataTreeNode<TInput, T>>();\n\n\tprotected readonly nodeMapper: AsyncDataTreeNodeMapper<TInput, T, TFilterData> = new WeakMapper(node => new AsyncDataTreeNodeWrapper(node));\n\n\tprotected readonly disposables = new DisposableStore();\n\n\tget onDidScroll(): Event<ScrollEvent> { return this.tree.onDidScroll; }\n\n\tget onDidChangeFocus(): Event<ITreeEvent<T>> { return Event.map(this.tree.onDidChangeFocus, asTreeEvent); }\n\tget onDidChangeSelection(): Event<ITreeEvent<T>> { return Event.map(this.tree.onDidChangeSelection, asTreeEvent); }\n\n\tget onKeyDown(): Event<KeyboardEvent> { return this.tree.onKeyDown; }\n\tget onMouseClick(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onMouseClick, asTreeMouseEvent); }\n\tget onMouseDblClick(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent); }\n\tget onContextMenu(): Event<ITreeContextMenuEvent<T>> { return Event.map(this.tree.onContextMenu, asTreeContextMenuEvent); }\n\tget onTap(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onTap, asTreeMouseEvent); }\n\tget onPointer(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onPointer, asTreeMouseEvent); }\n\tget onDidFocus(): Event<void> { return this.tree.onDidFocus; }\n\tget onDidBlur(): Event<void> { return this.tree.onDidBlur; }\n\n\t/**\n\t * To be used internally only!\n\t * @deprecated\n\t */\n\tget onDidChangeModel(): Event<void> { return this.tree.onDidChangeModel; }\n\tget onDidChangeCollapseState(): Event<ICollapseStateChangeEvent<IAsyncDataTreeNode<TInput, T> | null, TFilterData>> { return this.tree.onDidChangeCollapseState; }\n\n\tget onDidUpdateOptions(): Event<IAsyncDataTreeOptionsUpdate> { return this.tree.onDidUpdateOptions; }\n\n\tget onDidChangeFindOpenState(): Event<boolean> { return this.tree.onDidChangeFindOpenState; }\n\tget onDidChangeStickyScrollFocused(): Event<boolean> { return this.tree.onDidChangeStickyScrollFocused; }\n\n\tget findMode(): TreeFindMode { return this.tree.findMode; }\n\tset findMode(mode: TreeFindMode) { this.tree.findMode = mode; }\n\treadonly onDidChangeFindMode: Event<TreeFindMode>;\n\n\tget findMatchType(): TreeFindMatchType { return this.tree.findMatchType; }\n\tset findMatchType(matchType: TreeFindMatchType) { this.tree.findMatchType = matchType; }\n\treadonly onDidChangeFindMatchType: Event<TreeFindMatchType>;\n\n\tget expandOnlyOnTwistieClick(): boolean | ((e: T) => boolean) {\n\t\tif (typeof this.tree.expandOnlyOnTwistieClick === 'boolean') {\n\t\t\treturn this.tree.expandOnlyOnTwistieClick;\n\t\t}\n\n\t\tconst fn = this.tree.expandOnlyOnTwistieClick;\n\t\treturn element => fn(this.nodes.get((element === this.root.element ? null : element) as T) || null);\n\t}\n\n\tget onDidDispose(): Event<void> { return this.tree.onDidDispose; }\n\n\tconstructor(\n\t\tprotected user: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ITreeRenderer<T, TFilterData, any>[],\n\t\tprivate dataSource: IAsyncDataSource<TInput, T>,\n\t\toptions: IAsyncDataTreeOptions<T, TFilterData> = {}\n\t) {\n\t\tthis.identityProvider = options.identityProvider;\n\t\tthis.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n\t\tthis.sorter = options.sorter;\n\t\tthis.getDefaultCollapseState = e => options.collapseByDefault ? (options.collapseByDefault(e) ? ObjectTreeElementCollapseState.PreserveOrCollapsed : ObjectTreeElementCollapseState.PreserveOrExpanded) : undefined;\n\n\t\tthis.tree = this.createTree(user, container, delegate, renderers, options);\n\t\tthis.onDidChangeFindMode = this.tree.onDidChangeFindMode;\n\t\tthis.onDidChangeFindMatchType = this.tree.onDidChangeFindMatchType;\n\n\t\tthis.root = createAsyncDataTreeNode({\n\t\t\telement: undefined!,\n\t\t\tparent: null,\n\t\t\thasChildren: true,\n\t\t\tdefaultCollapseState: undefined\n\t\t});\n\n\t\tif (this.identityProvider) {\n\t\t\tthis.root = {\n\t\t\t\t...this.root,\n\t\t\t\tid: null\n\t\t\t};\n\t\t}\n\n\t\tthis.nodes.set(null, this.root);\n\n\t\tthis.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\n\t}\n\n\tprotected createTree(\n\t\tuser: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ITreeRenderer<T, TFilterData, any>[],\n\t\toptions: IAsyncDataTreeOptions<T, TFilterData>\n\t): ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData> {\n\t\tconst objectTreeDelegate = new ComposedTreeDelegate<TInput | T, IAsyncDataTreeNode<TInput, T>>(delegate);\n\t\tconst objectTreeRenderers = renderers.map(r => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));\n\t\tconst objectTreeOptions = asObjectTreeOptions<TInput, T, TFilterData>(options) || {};\n\n\t\treturn new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n\t}\n\n\tupdateOptions(options: IAsyncDataTreeOptionsUpdate = {}): void {\n\t\tthis.tree.updateOptions(options);\n\t}\n\n\tget options(): IAsyncDataTreeOptions<T, TFilterData> {\n\t\treturn this.tree.options as IAsyncDataTreeOptions<T, TFilterData>;\n\t}\n\n\t// Widget\n\n\tgetHTMLElement(): HTMLElement {\n\t\treturn this.tree.getHTMLElement();\n\t}\n\n\tget contentHeight(): number {\n\t\treturn this.tree.contentHeight;\n\t}\n\n\tget contentWidth(): number {\n\t\treturn this.tree.contentWidth;\n\t}\n\n\tget onDidChangeContentHeight(): Event<number> {\n\t\treturn this.tree.onDidChangeContentHeight;\n\t}\n\n\tget onDidChangeContentWidth(): Event<number> {\n\t\treturn this.tree.onDidChangeContentWidth;\n\t}\n\n\tget scrollTop(): number {\n\t\treturn this.tree.scrollTop;\n\t}\n\n\tset scrollTop(scrollTop: number) {\n\t\tthis.tree.scrollTop = scrollTop;\n\t}\n\n\tget scrollLeft(): number {\n\t\treturn this.tree.scrollLeft;\n\t}\n\n\tset scrollLeft(scrollLeft: number) {\n\t\tthis.tree.scrollLeft = scrollLeft;\n\t}\n\n\tget scrollHeight(): number {\n\t\treturn this.tree.scrollHeight;\n\t}\n\n\tget renderHeight(): number {\n\t\treturn this.tree.renderHeight;\n\t}\n\n\tget lastVisibleElement(): T {\n\t\treturn this.tree.lastVisibleElement!.element as T;\n\t}\n\n\tget ariaLabel(): string {\n\t\treturn this.tree.ariaLabel;\n\t}\n\n\tset ariaLabel(value: string) {\n\t\tthis.tree.ariaLabel = value;\n\t}\n\n\tdomFocus(): void {\n\t\tthis.tree.domFocus();\n\t}\n\n\tlayout(height?: number, width?: number): void {\n\t\tthis.tree.layout(height, width);\n\t}\n\n\tstyle(styles: IListStyles): void {\n\t\tthis.tree.style(styles);\n\t}\n\n\t// Model\n\n\tgetInput(): TInput | undefined {\n\t\treturn this.root.element as TInput;\n\t}\n\n\tasync setInput(input: TInput, viewState?: IAsyncDataTreeViewState): Promise<void> {\n\t\tthis.refreshPromises.forEach(promise => promise.cancel());\n\t\tthis.refreshPromises.clear();\n\n\t\tthis.root.element = input!;\n\n\t\tconst viewStateContext = viewState && { viewState, focus: [], selection: [] } as IAsyncDataTreeViewStateContext<TInput, T>;\n\n\t\tawait this._updateChildren(input, true, false, viewStateContext);\n\n\t\tif (viewStateContext) {\n\t\t\tthis.tree.setFocus(viewStateContext.focus);\n\t\t\tthis.tree.setSelection(viewStateContext.selection);\n\t\t}\n\n\t\tif (viewState && typeof viewState.scrollTop === 'number') {\n\t\t\tthis.scrollTop = viewState.scrollTop;\n\t\t}\n\t}\n\n\tasync updateChildren(element: TInput | T = this.root.element, recursive = true, rerender = false, options?: IAsyncDataTreeUpdateChildrenOptions<T>): Promise<void> {\n\t\tawait this._updateChildren(element, recursive, rerender, undefined, options);\n\t}\n\n\tprivate async _updateChildren(element: TInput | T = this.root.element, recursive = true, rerender = false, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): Promise<void> {\n\t\tif (typeof this.root.element === 'undefined') {\n\t\t\tthrow new TreeError(this.user, 'Tree input not set');\n\t\t}\n\n\t\tif (this.root.refreshPromise) {\n\t\t\tawait this.root.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\tconst node = this.getDataNode(element);\n\t\tawait this.refreshAndRenderNode(node, recursive, viewStateContext, options);\n\n\t\tif (rerender) {\n\t\t\ttry {\n\t\t\t\tthis.tree.rerender(node);\n\t\t\t} catch {\n\t\t\t\t// missing nodes are fine, this could've resulted from\n\t\t\t\t// parallel refresh calls, removing `node` altogether\n\t\t\t}\n\t\t}\n\t}\n\n\tresort(element: TInput | T = this.root.element, recursive = true): void {\n\t\tthis.tree.resort(this.getDataNode(element), recursive);\n\t}\n\n\thasElement(element: TInput | T): boolean {\n\t\treturn this.tree.hasElement(this.getDataNode(element));\n\t}\n\n\thasNode(element: TInput | T): boolean {\n\t\treturn element === this.root.element || this.nodes.has(element as T);\n\t}\n\n\t// View\n\n\trerender(element?: T): void {\n\t\tif (element === undefined || element === this.root.element) {\n\t\t\tthis.tree.rerender();\n\t\t\treturn;\n\t\t}\n\n\t\tconst node = this.getDataNode(element);\n\t\tthis.tree.rerender(node);\n\t}\n\n\tupdateElementHeight(element: T, height: number | undefined): void {\n\t\tconst node = this.getDataNode(element);\n\t\tthis.tree.updateElementHeight(node, height);\n\t}\n\n\tupdateWidth(element: T): void {\n\t\tconst node = this.getDataNode(element);\n\t\tthis.tree.updateWidth(node);\n\t}\n\n\t// Tree\n\n\tgetNode(element: TInput | T = this.root.element): ITreeNode<TInput | T, TFilterData> {\n\t\tconst dataNode = this.getDataNode(element);\n\t\tconst node = this.tree.getNode(dataNode === this.root ? null : dataNode);\n\t\treturn this.nodeMapper.map(node);\n\t}\n\n\tcollapse(element: T, recursive: boolean = false): boolean {\n\t\tconst node = this.getDataNode(element);\n\t\treturn this.tree.collapse(node === this.root ? null : node, recursive);\n\t}\n\n\tasync expand(element: T, recursive: boolean = false): Promise<boolean> {\n\t\tif (typeof this.root.element === 'undefined') {\n\t\t\tthrow new TreeError(this.user, 'Tree input not set');\n\t\t}\n\n\t\tif (this.root.refreshPromise) {\n\t\t\tawait this.root.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\tconst node = this.getDataNode(element);\n\n\t\tif (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (node.refreshPromise) {\n\t\t\tawait this.root.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\tif (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst result = this.tree.expand(node === this.root ? null : node, recursive);\n\n\t\tif (node.refreshPromise) {\n\t\t\tawait this.root.refreshPromise;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\ttoggleCollapsed(element: T, recursive: boolean = false): boolean {\n\t\treturn this.tree.toggleCollapsed(this.getDataNode(element), recursive);\n\t}\n\n\texpandAll(): void {\n\t\tthis.tree.expandAll();\n\t}\n\n\tasync expandTo(element: T): Promise<void> {\n\t\tif (!this.dataSource.getParent) {\n\t\t\tthrow new Error('Can\\'t expand to element without getParent method');\n\t\t}\n\n\t\tconst elements: T[] = [];\n\n\t\twhile (!this.hasNode(element)) {\n\t\t\telement = this.dataSource.getParent(element) as T;\n\n\t\t\tif (element !== this.root.element) {\n\t\t\t\telements.push(element);\n\t\t\t}\n\t\t}\n\n\t\tfor (const element of Iterable.reverse(elements)) {\n\t\t\tawait this.expand(element);\n\t\t}\n\n\t\tthis.tree.expandTo(this.getDataNode(element));\n\t}\n\n\tcollapseAll(): void {\n\t\tthis.tree.collapseAll();\n\t}\n\n\tisCollapsible(element: T): boolean {\n\t\treturn this.tree.isCollapsible(this.getDataNode(element));\n\t}\n\n\tisCollapsed(element: TInput | T): boolean {\n\t\treturn this.tree.isCollapsed(this.getDataNode(element));\n\t}\n\n\ttriggerTypeNavigation(): void {\n\t\tthis.tree.triggerTypeNavigation();\n\t}\n\n\topenFind(): void {\n\t\tthis.tree.openFind();\n\t}\n\n\tcloseFind(): void {\n\t\tthis.tree.closeFind();\n\t}\n\n\trefilter(): void {\n\t\tthis.tree.refilter();\n\t}\n\n\tsetAnchor(element: T | undefined): void {\n\t\tthis.tree.setAnchor(typeof element === 'undefined' ? undefined : this.getDataNode(element));\n\t}\n\n\tgetAnchor(): T | undefined {\n\t\tconst node = this.tree.getAnchor();\n\t\treturn node?.element as T;\n\t}\n\n\tsetSelection(elements: T[], browserEvent?: UIEvent): void {\n\t\tconst nodes = elements.map(e => this.getDataNode(e));\n\t\tthis.tree.setSelection(nodes, browserEvent);\n\t}\n\n\tgetSelection(): T[] {\n\t\tconst nodes = this.tree.getSelection();\n\t\treturn nodes.map(n => n!.element as T);\n\t}\n\n\tsetFocus(elements: T[], browserEvent?: UIEvent): void {\n\t\tconst nodes = elements.map(e => this.getDataNode(e));\n\t\tthis.tree.setFocus(nodes, browserEvent);\n\t}\n\n\tfocusNext(n = 1, loop = false, browserEvent?: UIEvent): void {\n\t\tthis.tree.focusNext(n, loop, browserEvent);\n\t}\n\n\tfocusPrevious(n = 1, loop = false, browserEvent?: UIEvent): void {\n\t\tthis.tree.focusPrevious(n, loop, browserEvent);\n\t}\n\n\tfocusNextPage(browserEvent?: UIEvent): Promise<void> {\n\t\treturn this.tree.focusNextPage(browserEvent);\n\t}\n\n\tfocusPreviousPage(browserEvent?: UIEvent): Promise<void> {\n\t\treturn this.tree.focusPreviousPage(browserEvent);\n\t}\n\n\tfocusLast(browserEvent?: UIEvent): void {\n\t\tthis.tree.focusLast(browserEvent);\n\t}\n\n\tfocusFirst(browserEvent?: UIEvent): void {\n\t\tthis.tree.focusFirst(browserEvent);\n\t}\n\n\tgetFocus(): T[] {\n\t\tconst nodes = this.tree.getFocus();\n\t\treturn nodes.map(n => n!.element as T);\n\t}\n\n\tgetStickyScrollFocus(): T[] {\n\t\tconst nodes = this.tree.getStickyScrollFocus();\n\t\treturn nodes.map(n => n!.element as T);\n\t}\n\n\tgetFocusedPart(): AbstractTreePart {\n\t\treturn this.tree.getFocusedPart();\n\t}\n\n\treveal(element: T, relativeTop?: number): void {\n\t\tthis.tree.reveal(this.getDataNode(element), relativeTop);\n\t}\n\n\tgetRelativeTop(element: T): number | null {\n\t\treturn this.tree.getRelativeTop(this.getDataNode(element));\n\t}\n\n\t// Tree navigation\n\n\tgetParentElement(element: T): TInput | T {\n\t\tconst node = this.tree.getParentElement(this.getDataNode(element));\n\t\treturn (node && node.element)!;\n\t}\n\n\tgetFirstElementChild(element: TInput | T = this.root.element): TInput | T | undefined {\n\t\tconst dataNode = this.getDataNode(element);\n\t\tconst node = this.tree.getFirstElementChild(dataNode === this.root ? null : dataNode);\n\t\treturn (node && node.element)!;\n\t}\n\n\t// Implementation\n\n\tprivate getDataNode(element: TInput | T): IAsyncDataTreeNode<TInput, T> {\n\t\tconst node: IAsyncDataTreeNode<TInput, T> | undefined = this.nodes.get((element === this.root.element ? null : element) as T);\n\n\t\tif (!node) {\n\t\t\tthrow new TreeError(this.user, `Data tree node not found: ${element}`);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tprivate async refreshAndRenderNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): Promise<void> {\n\t\tawait this.refreshNode(node, recursive, viewStateContext);\n\t\tif (this.disposables.isDisposed) {\n\t\t\treturn; // tree disposed during refresh (#199264)\n\t\t}\n\t\tthis.render(node, viewStateContext, options);\n\t}\n\n\tprivate async refreshNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<void> {\n\t\tlet result: Promise<void> | undefined;\n\n\t\tthis.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {\n\t\t\tif (!result && intersects(refreshNode, node)) {\n\t\t\t\tresult = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));\n\t\t\t}\n\t\t});\n\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\n\t\tif (node !== this.root) {\n\t\t\tconst treeNode = this.tree.getNode(node);\n\n\t\t\tif (treeNode.collapsed) {\n\t\t\t\tnode.hasChildren = !!this.dataSource.hasChildren(node.element);\n\t\t\t\tnode.stale = true;\n\t\t\t\tthis.setChildren(node, [], recursive, viewStateContext);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\treturn this.doRefreshSubTree(node, recursive, viewStateContext);\n\t}\n\n\tprivate async doRefreshSubTree(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<void> {\n\t\tlet done: () => void;\n\t\tnode.refreshPromise = new Promise(c => done = c);\n\t\tthis.subTreeRefreshPromises.set(node, node.refreshPromise);\n\n\t\tnode.refreshPromise.finally(() => {\n\t\t\tnode.refreshPromise = undefined;\n\t\t\tthis.subTreeRefreshPromises.delete(node);\n\t\t});\n\n\t\ttry {\n\t\t\tconst childrenToRefresh = await this.doRefreshNode(node, recursive, viewStateContext);\n\t\t\tnode.stale = false;\n\n\t\t\tawait Promises.settled(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));\n\t\t} finally {\n\t\t\tdone!();\n\t\t}\n\t}\n\n\tprivate async doRefreshNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<IAsyncDataTreeNode<TInput, T>[]> {\n\t\tnode.hasChildren = !!this.dataSource.hasChildren(node.element);\n\n\t\tlet childrenPromise: Promise<Iterable<T>>;\n\n\t\tif (!node.hasChildren) {\n\t\t\tchildrenPromise = Promise.resolve(Iterable.empty());\n\t\t} else {\n\t\t\tconst children = this.doGetChildren(node);\n\t\t\tif (isIterable(children)) {\n\t\t\t\tchildrenPromise = Promise.resolve(children);\n\t\t\t} else {\n\t\t\t\tconst slowTimeout = timeout(800);\n\n\t\t\t\tslowTimeout.then(() => {\n\t\t\t\t\tnode.slow = true;\n\t\t\t\t\tthis._onDidChangeNodeSlowState.fire(node);\n\t\t\t\t}, _ => null);\n\n\t\t\t\tchildrenPromise = children.finally(() => slowTimeout.cancel());\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tconst children = await childrenPromise;\n\t\t\treturn this.setChildren(node, children, recursive, viewStateContext);\n\t\t} catch (err) {\n\t\t\tif (node !== this.root && this.tree.hasElement(node)) {\n\t\t\t\tthis.tree.collapse(node);\n\t\t\t}\n\n\t\t\tif (isCancellationError(err)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tif (node.slow) {\n\t\t\t\tnode.slow = false;\n\t\t\t\tthis._onDidChangeNodeSlowState.fire(node);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doGetChildren(node: IAsyncDataTreeNode<TInput, T>): Promise<Iterable<T>> | Iterable<T> {\n\t\tlet result = this.refreshPromises.get(node);\n\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\t\tconst children = this.dataSource.getChildren(node.element);\n\t\tif (isIterable(children)) {\n\t\t\treturn this.processChildren(children);\n\t\t} else {\n\t\t\tresult = createCancelablePromise(async () => this.processChildren(await children));\n\t\t\tthis.refreshPromises.set(node, result);\n\t\t\treturn result.finally(() => { this.refreshPromises.delete(node); });\n\t\t}\n\t}\n\n\tprivate _onDidChangeCollapseState({ node, deep }: ICollapseStateChangeEvent<IAsyncDataTreeNode<TInput, T> | null, any>): void {\n\t\tif (node.element === null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!node.collapsed && node.element.stale) {\n\t\t\tif (deep) {\n\t\t\t\tthis.collapse(node.element.element as T);\n\t\t\t} else {\n\t\t\t\tthis.refreshAndRenderNode(node.element, false)\n\t\t\t\t\t.catch(onUnexpectedError);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate setChildren(node: IAsyncDataTreeNode<TInput, T>, childrenElementsIterable: Iterable<T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): IAsyncDataTreeNode<TInput, T>[] {\n\t\tconst childrenElements = [...childrenElementsIterable];\n\n\t\t// perf: if the node was and still is a leaf, avoid all this hassle\n\t\tif (node.children.length === 0 && childrenElements.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst nodesToForget = new Map<T, IAsyncDataTreeNode<TInput, T>>();\n\t\tconst childrenTreeNodesById = new Map<string, { node: IAsyncDataTreeNode<TInput, T>; collapsed: boolean }>();\n\n\t\tfor (const child of node.children) {\n\t\t\tnodesToForget.set(child.element as T, child);\n\n\t\t\tif (this.identityProvider) {\n\t\t\t\tchildrenTreeNodesById.set(child.id!, { node: child, collapsed: this.tree.hasElement(child) && this.tree.isCollapsed(child) });\n\t\t\t}\n\t\t}\n\n\t\tconst childrenToRefresh: IAsyncDataTreeNode<TInput, T>[] = [];\n\n\t\tconst children = childrenElements.map<IAsyncDataTreeNode<TInput, T>>(element => {\n\t\t\tconst hasChildren = !!this.dataSource.hasChildren(element);\n\n\t\t\tif (!this.identityProvider) {\n\t\t\t\tconst asyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, hasChildren, defaultCollapseState: this.getDefaultCollapseState(element) });\n\n\t\t\t\tif (hasChildren && asyncDataTreeNode.defaultCollapseState === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n\t\t\t\t\tchildrenToRefresh.push(asyncDataTreeNode);\n\t\t\t\t}\n\n\t\t\t\treturn asyncDataTreeNode;\n\t\t\t}\n\n\t\t\tconst id = this.identityProvider.getId(element).toString();\n\t\t\tconst result = childrenTreeNodesById.get(id);\n\n\t\t\tif (result) {\n\t\t\t\tconst asyncDataTreeNode = result.node;\n\n\t\t\t\tnodesToForget.delete(asyncDataTreeNode.element as T);\n\t\t\t\tthis.nodes.delete(asyncDataTreeNode.element as T);\n\t\t\t\tthis.nodes.set(element, asyncDataTreeNode);\n\n\t\t\t\tasyncDataTreeNode.element = element;\n\t\t\t\tasyncDataTreeNode.hasChildren = hasChildren;\n\n\t\t\t\tif (recursive) {\n\t\t\t\t\tif (result.collapsed) {\n\t\t\t\t\t\tasyncDataTreeNode.children.forEach(node => dfs(node, node => this.nodes.delete(node.element as T)));\n\t\t\t\t\t\tasyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);\n\t\t\t\t\t\tasyncDataTreeNode.stale = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchildrenToRefresh.push(asyncDataTreeNode);\n\t\t\t\t\t}\n\t\t\t\t} else if (hasChildren && !result.collapsed) {\n\t\t\t\t\tchildrenToRefresh.push(asyncDataTreeNode);\n\t\t\t\t}\n\n\t\t\t\treturn asyncDataTreeNode;\n\t\t\t}\n\n\t\t\tconst childAsyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, id, hasChildren, defaultCollapseState: this.getDefaultCollapseState(element) });\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\n\t\t\t\tviewStateContext.focus.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\n\t\t\t\tviewStateContext.selection.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\n\t\t\t\tchildrenToRefresh.push(childAsyncDataTreeNode);\n\t\t\t} else if (hasChildren && childAsyncDataTreeNode.defaultCollapseState === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n\t\t\t\tchildrenToRefresh.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\treturn childAsyncDataTreeNode;\n\t\t});\n\n\t\tfor (const node of nodesToForget.values()) {\n\t\t\tdfs(node, node => this.nodes.delete(node.element as T));\n\t\t}\n\n\t\tfor (const child of children) {\n\t\t\tthis.nodes.set(child.element as T, child);\n\t\t}\n\n\t\tnode.children.splice(0, node.children.length, ...children);\n\n\t\t// TODO@joao this doesn't take filter into account\n\t\tif (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {\n\t\t\tchildren[0].forceExpanded = true;\n\t\t\tchildrenToRefresh.push(children[0]);\n\t\t}\n\n\t\treturn childrenToRefresh;\n\t}\n\n\tprotected render(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): void {\n\t\tconst children = node.children.map(node => this.asTreeElement(node, viewStateContext));\n\t\tconst objectTreeOptions: IObjectTreeSetChildrenOptions<IAsyncDataTreeNode<TInput, T>> | undefined = options && {\n\t\t\t...options,\n\t\t\tdiffIdentityProvider: options.diffIdentityProvider && {\n\t\t\t\tgetId(node: IAsyncDataTreeNode<TInput, T>): { toString(): string } {\n\t\t\t\t\treturn options.diffIdentityProvider!.getId(node.element as T);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.tree.setChildren(node === this.root ? null : node, children, objectTreeOptions);\n\n\t\tif (node !== this.root) {\n\t\t\tthis.tree.setCollapsible(node, node.hasChildren);\n\t\t}\n\n\t\tthis._onDidRender.fire();\n\t}\n\n\tprotected asTreeElement(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): IObjectTreeElement<IAsyncDataTreeNode<TInput, T>> {\n\t\tif (node.stale) {\n\t\t\treturn {\n\t\t\t\telement: node,\n\t\t\t\tcollapsible: node.hasChildren,\n\t\t\t\tcollapsed: true\n\t\t\t};\n\t\t}\n\n\t\tlet collapsed: boolean | ObjectTreeElementCollapseState.PreserveOrCollapsed | ObjectTreeElementCollapseState.PreserveOrExpanded | undefined;\n\n\t\tif (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {\n\t\t\tcollapsed = false;\n\t\t} else if (node.forceExpanded) {\n\t\t\tcollapsed = false;\n\t\t\tnode.forceExpanded = false;\n\t\t} else {\n\t\t\tcollapsed = node.defaultCollapseState;\n\t\t}\n\n\t\treturn {\n\t\t\telement: node,\n\t\t\tchildren: node.hasChildren ? Iterable.map(node.children, child => this.asTreeElement(child, viewStateContext)) : [],\n\t\t\tcollapsible: node.hasChildren,\n\t\t\tcollapsed\n\t\t};\n\t}\n\n\tprotected processChildren(children: Iterable<T>): Iterable<T> {\n\t\tif (this.sorter) {\n\t\t\tchildren = [...children].sort(this.sorter.compare.bind(this.sorter));\n\t\t}\n\n\t\treturn children;\n\t}\n\n\t// view state\n\n\tgetViewState(): IAsyncDataTreeViewState {\n\t\tif (!this.identityProvider) {\n\t\t\tthrow new TreeError(this.user, 'Can\\'t get tree view state without an identity provider');\n\t\t}\n\n\t\tconst getId = (element: T) => this.identityProvider!.getId(element).toString();\n\t\tconst focus = this.getFocus().map(getId);\n\t\tconst selection = this.getSelection().map(getId);\n\n\t\tconst expanded: string[] = [];\n\t\tconst root = this.tree.getNode();\n\t\tconst stack = [root];\n\n\t\twhile (stack.length > 0) {\n\t\t\tconst node = stack.pop()!;\n\n\t\t\tif (node !== root && node.collapsible && !node.collapsed) {\n\t\t\t\texpanded.push(getId(node.element!.element as T));\n\t\t\t}\n\n\t\t\tstack.push(...node.children);\n\t\t}\n\n\t\treturn { focus, selection, expanded, scrollTop: this.scrollTop };\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.dispose();\n\t\tthis.tree.dispose();\n\t}\n}\n\ntype CompressibleAsyncDataTreeNodeMapper<TInput, T, TFilterData> = WeakMapper<ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>, ITreeNode<ICompressedTreeNode<TInput | T>, TFilterData>>;\n\nclass CompressibleAsyncDataTreeNodeWrapper<TInput, T, TFilterData> implements ITreeNode<ICompressedTreeNode<TInput | T>, TFilterData> {\n\n\tget element(): ICompressedTreeNode<TInput | T> {\n\t\treturn {\n\t\t\telements: this.node.element.elements.map(e => e.element),\n\t\t\tincompressible: this.node.element.incompressible\n\t\t};\n\t}\n\n\tget children(): ITreeNode<ICompressedTreeNode<TInput | T>, TFilterData>[] { return this.node.children.map(node => new CompressibleAsyncDataTreeNodeWrapper(node)); }\n\tget depth(): number { return this.node.depth; }\n\tget visibleChildrenCount(): number { return this.node.visibleChildrenCount; }\n\tget visibleChildIndex(): number { return this.node.visibleChildIndex; }\n\tget collapsible(): boolean { return this.node.collapsible; }\n\tget collapsed(): boolean { return this.node.collapsed; }\n\tget visible(): boolean { return this.node.visible; }\n\tget filterData(): TFilterData | undefined { return this.node.filterData; }\n\n\tconstructor(private node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>) { }\n}\n\nclass CompressibleAsyncDataTreeRenderer<TInput, T, TFilterData, TTemplateData> implements ICompressibleTreeRenderer<IAsyncDataTreeNode<TInput, T>, TFilterData, IDataTreeListTemplateData<TTemplateData>> {\n\n\treadonly templateId: string;\n\tprivate renderedNodes = new Map<IAsyncDataTreeNode<TInput, T>, IDataTreeListTemplateData<TTemplateData>>();\n\tprivate disposables: IDisposable[] = [];\n\n\tconstructor(\n\t\tprotected renderer: ICompressibleTreeRenderer<T, TFilterData, TTemplateData>,\n\t\tprotected nodeMapper: AsyncDataTreeNodeMapper<TInput, T, TFilterData>,\n\t\tprivate compressibleNodeMapperProvider: () => CompressibleAsyncDataTreeNodeMapper<TInput, T, TFilterData>,\n\t\treadonly onDidChangeTwistieState: Event<IAsyncDataTreeNode<TInput, T>>\n\t) {\n\t\tthis.templateId = renderer.templateId;\n\t}\n\n\trenderTemplate(container: HTMLElement): IDataTreeListTemplateData<TTemplateData> {\n\t\tconst templateData = this.renderer.renderTemplate(container);\n\t\treturn { templateData };\n\t}\n\n\trenderElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.renderElement(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\trenderCompressedElements(node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node) as ITreeNode<ICompressedTreeNode<T>, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\trenderTwistie(element: IAsyncDataTreeNode<TInput, T>, twistieElement: HTMLElement): boolean {\n\t\tif (element.slow) {\n\t\t\ttwistieElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn true;\n\t\t} else {\n\t\t\ttwistieElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tdisposeElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.disposeElement?.(this.nodeMapper.map(node) as ITreeNode<T, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\tdisposeCompressedElements(node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, height: number | undefined): void {\n\t\tthis.renderer.disposeCompressedElements?.(this.compressibleNodeMapperProvider().map(node) as ITreeNode<ICompressedTreeNode<T>, TFilterData>, index, templateData.templateData, height);\n\t}\n\n\tdisposeTemplate(templateData: IDataTreeListTemplateData<TTemplateData>): void {\n\t\tthis.renderer.disposeTemplate(templateData.templateData);\n\t}\n\n\tdispose(): void {\n\t\tthis.renderedNodes.clear();\n\t\tthis.disposables = dispose(this.disposables);\n\t}\n}\n\nexport interface ITreeCompressionDelegate<T> {\n\tisIncompressible(element: T): boolean;\n}\n\nfunction asCompressibleObjectTreeOptions<TInput, T, TFilterData>(options?: ICompressibleAsyncDataTreeOptions<T, TFilterData>): ICompressibleObjectTreeOptions<IAsyncDataTreeNode<TInput, T>, TFilterData> | undefined {\n\tconst objectTreeOptions = options && asObjectTreeOptions(options);\n\n\treturn objectTreeOptions && {\n\t\t...objectTreeOptions,\n\t\tkeyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && {\n\t\t\t...objectTreeOptions.keyboardNavigationLabelProvider,\n\t\t\tgetCompressedNodeKeyboardNavigationLabel(els) {\n\t\t\t\treturn options.keyboardNavigationLabelProvider!.getCompressedNodeKeyboardNavigationLabel(els.map(e => e.element as T));\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport interface ICompressibleAsyncDataTreeOptions<T, TFilterData = void> extends IAsyncDataTreeOptions<T, TFilterData> {\n\treadonly compressionEnabled?: boolean;\n\treadonly keyboardNavigationLabelProvider?: ICompressibleKeyboardNavigationLabelProvider<T>;\n}\n\nexport interface ICompressibleAsyncDataTreeOptionsUpdate extends IAsyncDataTreeOptionsUpdate {\n\treadonly compressionEnabled?: boolean;\n}\n\nexport class CompressibleAsyncDataTree<TInput, T, TFilterData = void> extends AsyncDataTree<TInput, T, TFilterData> {\n\n\tprotected declare readonly tree: CompressibleObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData>;\n\tprotected readonly compressibleNodeMapper: CompressibleAsyncDataTreeNodeMapper<TInput, T, TFilterData> = new WeakMapper(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n\tprivate filter?: ITreeFilter<T, TFilterData>;\n\n\tconstructor(\n\t\tuser: string,\n\t\tcontainer: HTMLElement,\n\t\tvirtualDelegate: IListVirtualDelegate<T>,\n\t\tprivate compressionDelegate: ITreeCompressionDelegate<T>,\n\t\trenderers: ICompressibleTreeRenderer<T, TFilterData, any>[],\n\t\tdataSource: IAsyncDataSource<TInput, T>,\n\t\toptions: ICompressibleAsyncDataTreeOptions<T, TFilterData> = {}\n\t) {\n\t\tsuper(user, container, virtualDelegate, renderers, dataSource, options);\n\t\tthis.filter = options.filter;\n\t}\n\n\tprotected override createTree(\n\t\tuser: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ICompressibleTreeRenderer<T, TFilterData, any>[],\n\t\toptions: ICompressibleAsyncDataTreeOptions<T, TFilterData>\n\t): ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData> {\n\t\tconst objectTreeDelegate = new ComposedTreeDelegate<TInput | T, IAsyncDataTreeNode<TInput, T>>(delegate);\n\t\tconst objectTreeRenderers = renderers.map(r => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));\n\t\tconst objectTreeOptions = asCompressibleObjectTreeOptions<TInput, T, TFilterData>(options) || {};\n\n\t\treturn new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n\t}\n\n\tprotected override asTreeElement(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): ICompressedTreeElement<IAsyncDataTreeNode<TInput, T>> {\n\t\treturn {\n\t\t\tincompressible: this.compressionDelegate.isIncompressible(node.element as T),\n\t\t\t...super.asTreeElement(node, viewStateContext)\n\t\t};\n\t}\n\n\toverride updateOptions(options: ICompressibleAsyncDataTreeOptionsUpdate = {}): void {\n\t\tthis.tree.updateOptions(options);\n\t}\n\n\toverride getViewState(): IAsyncDataTreeViewState {\n\t\tif (!this.identityProvider) {\n\t\t\tthrow new TreeError(this.user, 'Can\\'t get tree view state without an identity provider');\n\t\t}\n\n\t\tconst getId = (element: T) => this.identityProvider!.getId(element).toString();\n\t\tconst focus = this.getFocus().map(getId);\n\t\tconst selection = this.getSelection().map(getId);\n\n\t\tconst expanded: string[] = [];\n\t\tconst root = this.tree.getCompressedTreeNode();\n\t\tconst stack = [root];\n\n\t\twhile (stack.length > 0) {\n\t\t\tconst node = stack.pop()!;\n\n\t\t\tif (node !== root && node.collapsible && !node.collapsed) {\n\t\t\t\tfor (const asyncNode of node.element!.elements) {\n\t\t\t\t\texpanded.push(getId(asyncNode.element as T));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstack.push(...node.children);\n\t\t}\n\n\t\treturn { focus, selection, expanded, scrollTop: this.scrollTop };\n\t}\n\n\tprotected override render(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>, options?: IAsyncDataTreeUpdateChildrenOptions<T>): void {\n\t\tif (!this.identityProvider) {\n\t\t\treturn super.render(node, viewStateContext);\n\t\t}\n\n\t\t// Preserve traits across compressions. Hacky but does the trick.\n\t\t// This is hard to fix properly since it requires rewriting the traits\n\t\t// across trees and lists. Let's just keep it this way for now.\n\t\tconst getId = (element: T) => this.identityProvider!.getId(element).toString();\n\t\tconst getUncompressedIds = (nodes: IAsyncDataTreeNode<TInput, T>[]): Set<string> => {\n\t\t\tconst result = new Set<string>();\n\n\t\t\tfor (const node of nodes) {\n\t\t\t\tconst compressedNode = this.tree.getCompressedTreeNode(node === this.root ? null : node);\n\n\t\t\t\tif (!compressedNode.element) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (const node of compressedNode.element.elements) {\n\t\t\t\t\tresult.add(getId(node.element as T));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\tconst oldSelection = getUncompressedIds(this.tree.getSelection() as IAsyncDataTreeNode<TInput, T>[]);\n\t\tconst oldFocus = getUncompressedIds(this.tree.getFocus() as IAsyncDataTreeNode<TInput, T>[]);\n\n\t\tsuper.render(node, viewStateContext, options);\n\n\t\tconst selection = this.getSelection();\n\t\tlet didChangeSelection = false;\n\n\t\tconst focus = this.getFocus();\n\t\tlet didChangeFocus = false;\n\n\t\tconst visit = (node: ITreeNode<ICompressedTreeNode<IAsyncDataTreeNode<TInput, T>> | null, TFilterData>) => {\n\t\t\tconst compressedNode = node.element;\n\n\t\t\tif (compressedNode) {\n\t\t\t\tfor (let i = 0; i < compressedNode.elements.length; i++) {\n\t\t\t\t\tconst id = getId(compressedNode.elements[i].element as T);\n\t\t\t\t\tconst element = compressedNode.elements[compressedNode.elements.length - 1].element as T;\n\n\t\t\t\t\t// github.com/microsoft/vscode/issues/85938\n\t\t\t\t\tif (oldSelection.has(id) && selection.indexOf(element) === -1) {\n\t\t\t\t\t\tselection.push(element);\n\t\t\t\t\t\tdidChangeSelection = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (oldFocus.has(id) && focus.indexOf(element) === -1) {\n\t\t\t\t\t\tfocus.push(element);\n\t\t\t\t\t\tdidChangeFocus = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode.children.forEach(visit);\n\t\t};\n\n\t\tvisit(this.tree.getCompressedTreeNode(node === this.root ? null : node));\n\n\t\tif (didChangeSelection) {\n\t\t\tthis.setSelection(selection);\n\t\t}\n\n\t\tif (didChangeFocus) {\n\t\t\tthis.setFocus(focus);\n\t\t}\n\t}\n\n\t// For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work\n\t// and we have to filter everything beforehand\n\t// Related to #85193 and #85835\n\tprotected override processChildren(children: Iterable<T>): Iterable<T> {\n\t\tif (this.filter) {\n\t\t\tchildren = Iterable.filter(children, e => {\n\t\t\t\tconst result = this.filter!.filter(e, TreeVisibility.Visible);\n\t\t\t\tconst visibility = getVisibility(result);\n\n\t\t\t\tif (visibility === TreeVisibility.Recurse) {\n\t\t\t\t\tthrow new Error('Recursive tree visibility not supported in async data compressed trees');\n\t\t\t\t}\n\n\t\t\t\treturn visibility === TreeVisibility.Visible;\n\t\t\t});\n\t\t}\n\n\t\treturn super.processChildren(children);\n\t}\n}\n\nfunction getVisibility<TFilterData>(filterResult: TreeFilterResult<TFilterData>): TreeVisibility {\n\tif (typeof filterResult === 'boolean') {\n\t\treturn filterResult ? TreeVisibility.Visible : TreeVisibility.Hidden;\n\t} else if (isFilterResult(filterResult)) {\n\t\treturn getVisibleState(filterResult.visibility);\n\t} else {\n\t\treturn getVisibleState(filterResult);\n\t}\n}\n"]}