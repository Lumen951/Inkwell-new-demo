{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/base/browser/ui/tree/dataTree.ts","vs/base/browser/ui/tree/dataTree.ts"],"names":[],"mappings":"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","file":"dataTree.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IIdentityProvider, IListVirtualDelegate } from '../list/list';\nimport { AbstractTree, AbstractTreeViewState, IAbstractTreeOptions } from './abstractTree';\nimport { IList } from './indexTreeModel';\nimport { ObjectTreeModel } from './objectTreeModel';\nimport { IDataSource, ITreeElement, ITreeModel, ITreeNode, ITreeRenderer, ITreeSorter, TreeError } from './tree';\nimport { Iterable } from '../../../common/iterator';\n\nexport interface IDataTreeOptions<T, TFilterData = void> extends IAbstractTreeOptions<T, TFilterData> {\n\treadonly sorter?: ITreeSorter<T>;\n}\n\nexport class DataTree<TInput, T, TFilterData = void> extends AbstractTree<T | null, TFilterData, T | null> {\n\n\tprotected declare model: ObjectTreeModel<T, TFilterData>;\n\tprivate input: TInput | undefined;\n\n\tprivate identityProvider: IIdentityProvider<T> | undefined;\n\tprivate nodesByIdentity = new Map<string, ITreeNode<T, TFilterData>>();\n\n\tconstructor(\n\t\tprivate user: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ITreeRenderer<T, TFilterData, any>[],\n\t\tprivate dataSource: IDataSource<TInput, T>,\n\t\toptions: IDataTreeOptions<T, TFilterData> = {}\n\t) {\n\t\tsuper(user, container, delegate, renderers, options as IDataTreeOptions<T | null, TFilterData>);\n\t\tthis.identityProvider = options.identityProvider;\n\t}\n\n\t// Model\n\n\tgetInput(): TInput | undefined {\n\t\treturn this.input;\n\t}\n\n\tsetInput(input: TInput | undefined, viewState?: AbstractTreeViewState): void {\n\t\tif (viewState && !this.identityProvider) {\n\t\t\tthrow new TreeError(this.user, 'Can\\'t restore tree view state without an identity provider');\n\t\t}\n\n\t\tthis.input = input;\n\n\t\tif (!input) {\n\t\t\tthis.nodesByIdentity.clear();\n\t\t\tthis.model.setChildren(null, Iterable.empty());\n\t\t\treturn;\n\t\t}\n\n\t\tif (!viewState) {\n\t\t\tthis._refresh(input);\n\t\t\treturn;\n\t\t}\n\n\t\tconst focus: T[] = [];\n\t\tconst selection: T[] = [];\n\n\t\tconst isCollapsed = (element: T) => {\n\t\t\tconst id = this.identityProvider!.getId(element).toString();\n\t\t\treturn !viewState.expanded[id];\n\t\t};\n\n\t\tconst onDidCreateNode = (node: ITreeNode<T, TFilterData>) => {\n\t\t\tconst id = this.identityProvider!.getId(node.element).toString();\n\n\t\t\tif (viewState.focus.has(id)) {\n\t\t\t\tfocus.push(node.element);\n\t\t\t}\n\n\t\t\tif (viewState.selection.has(id)) {\n\t\t\t\tselection.push(node.element);\n\t\t\t}\n\t\t};\n\n\t\tthis._refresh(input, isCollapsed, onDidCreateNode);\n\t\tthis.setFocus(focus);\n\t\tthis.setSelection(selection);\n\n\t\tif (viewState && typeof viewState.scrollTop === 'number') {\n\t\t\tthis.scrollTop = viewState.scrollTop;\n\t\t}\n\t}\n\n\tupdateChildren(element: TInput | T = this.input!): void {\n\t\tif (typeof this.input === 'undefined') {\n\t\t\tthrow new TreeError(this.user, 'Tree input not set');\n\t\t}\n\n\t\tlet isCollapsed: ((el: T) => boolean | undefined) | undefined;\n\n\t\tif (this.identityProvider) {\n\t\t\tisCollapsed = element => {\n\t\t\t\tconst id = this.identityProvider!.getId(element).toString();\n\t\t\t\tconst node = this.nodesByIdentity.get(id);\n\n\t\t\t\tif (!node) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\treturn node.collapsed;\n\t\t\t};\n\t\t}\n\n\t\tthis._refresh(element, isCollapsed);\n\t}\n\n\tresort(element: T | TInput = this.input!, recursive = true): void {\n\t\tthis.model.resort((element === this.input ? null : element) as T, recursive);\n\t}\n\n\t// View\n\n\trefresh(element?: T): void {\n\t\tif (element === undefined) {\n\t\t\tthis.view.rerender();\n\t\t\treturn;\n\t\t}\n\n\t\tthis.model.rerender(element);\n\t}\n\n\t// Implementation\n\n\tprivate _refresh(element: TInput | T, isCollapsed?: (el: T) => boolean | undefined, onDidCreateNode?: (node: ITreeNode<T, TFilterData>) => void): void {\n\t\tlet onDidDeleteNode: ((node: ITreeNode<T, TFilterData>) => void) | undefined;\n\n\t\tif (this.identityProvider) {\n\t\t\tconst insertedElements = new Set<string>();\n\n\t\t\tconst outerOnDidCreateNode = onDidCreateNode;\n\t\t\tonDidCreateNode = (node: ITreeNode<T, TFilterData>) => {\n\t\t\t\tconst id = this.identityProvider!.getId(node.element).toString();\n\n\t\t\t\tinsertedElements.add(id);\n\t\t\t\tthis.nodesByIdentity.set(id, node);\n\n\t\t\t\touterOnDidCreateNode?.(node);\n\t\t\t};\n\n\t\t\tonDidDeleteNode = (node: ITreeNode<T, TFilterData>) => {\n\t\t\t\tconst id = this.identityProvider!.getId(node.element).toString();\n\n\t\t\t\tif (!insertedElements.has(id)) {\n\t\t\t\t\tthis.nodesByIdentity.delete(id);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tthis.model.setChildren((element === this.input ? null : element) as T, this.iterate(element, isCollapsed).elements, { onDidCreateNode, onDidDeleteNode });\n\t}\n\n\tprivate iterate(element: TInput | T, isCollapsed?: (el: T) => boolean | undefined): { elements: Iterable<ITreeElement<T>>; size: number } {\n\t\tconst children = [...this.dataSource.getChildren(element)];\n\t\tconst elements = Iterable.map(children, element => {\n\t\t\tconst { elements: children, size } = this.iterate(element, isCollapsed);\n\t\t\tconst collapsible = this.dataSource.hasChildren ? this.dataSource.hasChildren(element) : undefined;\n\t\t\tconst collapsed = size === 0 ? undefined : (isCollapsed && isCollapsed(element));\n\n\t\t\treturn { element, children, collapsible, collapsed };\n\t\t});\n\n\t\treturn { elements, size: children.length };\n\t}\n\n\tprotected createModel(user: string, view: IList<ITreeNode<T, TFilterData>>, options: IDataTreeOptions<T, TFilterData>): ITreeModel<T | null, TFilterData, T | null> {\n\t\treturn new ObjectTreeModel(user, view, options);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IIdentityProvider, IListVirtualDelegate } from '../list/list';\nimport { AbstractTree, AbstractTreeViewState, IAbstractTreeOptions } from './abstractTree';\nimport { IList } from './indexTreeModel';\nimport { ObjectTreeModel } from './objectTreeModel';\nimport { IDataSource, ITreeElement, ITreeModel, ITreeNode, ITreeRenderer, ITreeSorter, TreeError } from './tree';\nimport { Iterable } from '../../../common/iterator';\n\nexport interface IDataTreeOptions<T, TFilterData = void> extends IAbstractTreeOptions<T, TFilterData> {\n\treadonly sorter?: ITreeSorter<T>;\n}\n\nexport class DataTree<TInput, T, TFilterData = void> extends AbstractTree<T | null, TFilterData, T | null> {\n\n\tprotected declare model: ObjectTreeModel<T, TFilterData>;\n\tprivate input: TInput | undefined;\n\n\tprivate identityProvider: IIdentityProvider<T> | undefined;\n\tprivate nodesByIdentity = new Map<string, ITreeNode<T, TFilterData>>();\n\n\tconstructor(\n\t\tprivate user: string,\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ITreeRenderer<T, TFilterData, any>[],\n\t\tprivate dataSource: IDataSource<TInput, T>,\n\t\toptions: IDataTreeOptions<T, TFilterData> = {}\n\t) {\n\t\tsuper(user, container, delegate, renderers, options as IDataTreeOptions<T | null, TFilterData>);\n\t\tthis.identityProvider = options.identityProvider;\n\t}\n\n\t// Model\n\n\tgetInput(): TInput | undefined {\n\t\treturn this.input;\n\t}\n\n\tsetInput(input: TInput | undefined, viewState?: AbstractTreeViewState): void {\n\t\tif (viewState && !this.identityProvider) {\n\t\t\tthrow new TreeError(this.user, 'Can\\'t restore tree view state without an identity provider');\n\t\t}\n\n\t\tthis.input = input;\n\n\t\tif (!input) {\n\t\t\tthis.nodesByIdentity.clear();\n\t\t\tthis.model.setChildren(null, Iterable.empty());\n\t\t\treturn;\n\t\t}\n\n\t\tif (!viewState) {\n\t\t\tthis._refresh(input);\n\t\t\treturn;\n\t\t}\n\n\t\tconst focus: T[] = [];\n\t\tconst selection: T[] = [];\n\n\t\tconst isCollapsed = (element: T) => {\n\t\t\tconst id = this.identityProvider!.getId(element).toString();\n\t\t\treturn !viewState.expanded[id];\n\t\t};\n\n\t\tconst onDidCreateNode = (node: ITreeNode<T, TFilterData>) => {\n\t\t\tconst id = this.identityProvider!.getId(node.element).toString();\n\n\t\t\tif (viewState.focus.has(id)) {\n\t\t\t\tfocus.push(node.element);\n\t\t\t}\n\n\t\t\tif (viewState.selection.has(id)) {\n\t\t\t\tselection.push(node.element);\n\t\t\t}\n\t\t};\n\n\t\tthis._refresh(input, isCollapsed, onDidCreateNode);\n\t\tthis.setFocus(focus);\n\t\tthis.setSelection(selection);\n\n\t\tif (viewState && typeof viewState.scrollTop === 'number') {\n\t\t\tthis.scrollTop = viewState.scrollTop;\n\t\t}\n\t}\n\n\tupdateChildren(element: TInput | T = this.input!): void {\n\t\tif (typeof this.input === 'undefined') {\n\t\t\tthrow new TreeError(this.user, 'Tree input not set');\n\t\t}\n\n\t\tlet isCollapsed: ((el: T) => boolean | undefined) | undefined;\n\n\t\tif (this.identityProvider) {\n\t\t\tisCollapsed = element => {\n\t\t\t\tconst id = this.identityProvider!.getId(element).toString();\n\t\t\t\tconst node = this.nodesByIdentity.get(id);\n\n\t\t\t\tif (!node) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\treturn node.collapsed;\n\t\t\t};\n\t\t}\n\n\t\tthis._refresh(element, isCollapsed);\n\t}\n\n\tresort(element: T | TInput = this.input!, recursive = true): void {\n\t\tthis.model.resort((element === this.input ? null : element) as T, recursive);\n\t}\n\n\t// View\n\n\trefresh(element?: T): void {\n\t\tif (element === undefined) {\n\t\t\tthis.view.rerender();\n\t\t\treturn;\n\t\t}\n\n\t\tthis.model.rerender(element);\n\t}\n\n\t// Implementation\n\n\tprivate _refresh(element: TInput | T, isCollapsed?: (el: T) => boolean | undefined, onDidCreateNode?: (node: ITreeNode<T, TFilterData>) => void): void {\n\t\tlet onDidDeleteNode: ((node: ITreeNode<T, TFilterData>) => void) | undefined;\n\n\t\tif (this.identityProvider) {\n\t\t\tconst insertedElements = new Set<string>();\n\n\t\t\tconst outerOnDidCreateNode = onDidCreateNode;\n\t\t\tonDidCreateNode = (node: ITreeNode<T, TFilterData>) => {\n\t\t\t\tconst id = this.identityProvider!.getId(node.element).toString();\n\n\t\t\t\tinsertedElements.add(id);\n\t\t\t\tthis.nodesByIdentity.set(id, node);\n\n\t\t\t\touterOnDidCreateNode?.(node);\n\t\t\t};\n\n\t\t\tonDidDeleteNode = (node: ITreeNode<T, TFilterData>) => {\n\t\t\t\tconst id = this.identityProvider!.getId(node.element).toString();\n\n\t\t\t\tif (!insertedElements.has(id)) {\n\t\t\t\t\tthis.nodesByIdentity.delete(id);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tthis.model.setChildren((element === this.input ? null : element) as T, this.iterate(element, isCollapsed).elements, { onDidCreateNode, onDidDeleteNode });\n\t}\n\n\tprivate iterate(element: TInput | T, isCollapsed?: (el: T) => boolean | undefined): { elements: Iterable<ITreeElement<T>>; size: number } {\n\t\tconst children = [...this.dataSource.getChildren(element)];\n\t\tconst elements = Iterable.map(children, element => {\n\t\t\tconst { elements: children, size } = this.iterate(element, isCollapsed);\n\t\t\tconst collapsible = this.dataSource.hasChildren ? this.dataSource.hasChildren(element) : undefined;\n\t\t\tconst collapsed = size === 0 ? undefined : (isCollapsed && isCollapsed(element));\n\n\t\t\treturn { element, children, collapsible, collapsed };\n\t\t});\n\n\t\treturn { elements, size: children.length };\n\t}\n\n\tprotected createModel(user: string, view: IList<ITreeNode<T, TFilterData>>, options: IDataTreeOptions<T, TFilterData>): ITreeModel<T | null, TFilterData, T | null> {\n\t\treturn new ObjectTreeModel(user, view, options);\n\t}\n}\n"]}