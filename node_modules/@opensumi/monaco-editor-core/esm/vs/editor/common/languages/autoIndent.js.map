{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/editor/common/languages/autoIndent.ts","vs/editor/common/languages/autoIndent.ts"],"names":[],"mappings":"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","file":"autoIndent.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../base/common/strings';\nimport { Range } from '../core/range';\nimport { ITextModel } from '../model';\nimport { IndentAction } from './languageConfiguration';\nimport { createScopedLineTokens } from './supports';\nimport { IndentConsts, IndentRulesSupport } from './supports/indentRules';\nimport { EditorAutoIndentStrategy } from '../config/editorOptions';\nimport { getScopedLineTokens, ILanguageConfigurationService } from './languageConfigurationRegistry';\nimport { LineTokens } from '../tokens/lineTokens';\n\nexport interface IVirtualModel {\n\ttokenization: {\n\t\tgetLineTokens(lineNumber: number): LineTokens;\n\t\tgetLanguageId(): string;\n\t\tgetLanguageIdAtPosition(lineNumber: number, column: number): string;\n\t};\n\tgetLineContent(lineNumber: number): string;\n}\n\nexport interface IIndentConverter {\n\tshiftIndent(indentation: string): string;\n\tunshiftIndent(indentation: string): string;\n\tnormalizeIndentation?(indentation: string): string;\n}\n\n/**\n * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n * Result:\n * -1: run into the boundary of embedded languages\n * 0: every line above are invalid\n * else: nearest preceding line of the same language\n */\nfunction getPrecedingValidLine(model: IVirtualModel, lineNumber: number, indentRulesSupport: IndentRulesSupport) {\n\tconst languageId = model.tokenization.getLanguageIdAtPosition(lineNumber, 0);\n\tif (lineNumber > 1) {\n\t\tlet lastLineNumber: number;\n\t\tlet resultLineNumber = -1;\n\n\t\tfor (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n\t\t\tif (model.tokenization.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {\n\t\t\t\treturn resultLineNumber;\n\t\t\t}\n\t\t\tconst text = model.getLineContent(lastLineNumber);\n\t\t\tif (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n\t\t\t\tresultLineNumber = lastLineNumber;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn lastLineNumber;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Get inherited indentation from above lines.\n * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n * 3. If this line doesn't match any indent rules\n *   a. check whether the line above it matches indentNextLinePattern\n *   b. If not, the indent level of this line is the result\n *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n *\n * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n */\nexport function getInheritIndentForLine(\n\tautoIndent: EditorAutoIndentStrategy,\n\tmodel: IVirtualModel,\n\tlineNumber: number,\n\thonorIntentialIndent: boolean = true,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): { indentation: string; action: IndentAction | null; line?: number } | null {\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.tokenization.getLanguageId()).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\n\tif (lineNumber <= 1) {\n\t\treturn {\n\t\t\tindentation: '',\n\t\t\taction: null\n\t\t};\n\t}\n\n\t// Use no indent if this is the first non-blank line\n\tfor (let priorLineNumber = lineNumber - 1; priorLineNumber > 0; priorLineNumber--) {\n\t\tif (model.getLineContent(priorLineNumber) !== '') {\n\t\t\tbreak;\n\t\t}\n\t\tif (priorLineNumber === 1) {\n\t\t\treturn {\n\t\t\t\tindentation: '',\n\t\t\t\taction: null\n\t\t\t};\n\t\t}\n\t}\n\n\tconst precedingUnIgnoredLine = getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n\tif (precedingUnIgnoredLine < 0) {\n\t\treturn null;\n\t} else if (precedingUnIgnoredLine < 1) {\n\t\treturn {\n\t\t\tindentation: '',\n\t\t\taction: null\n\t\t};\n\t}\n\n\tconst precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n\tif (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n\t\treturn {\n\t\t\tindentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n\t\t\taction: IndentAction.Indent,\n\t\t\tline: precedingUnIgnoredLine\n\t\t};\n\t} else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n\t\treturn {\n\t\t\tindentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n\t\t\taction: null,\n\t\t\tline: precedingUnIgnoredLine\n\t\t};\n\t} else {\n\t\t// precedingUnIgnoredLine can not be ignored.\n\t\t// it doesn't increase indent of following lines\n\t\t// it doesn't increase just next line\n\t\t// so current line is not affect by precedingUnIgnoredLine\n\t\t// and then we should get a correct inheritted indentation from above lines\n\t\tif (precedingUnIgnoredLine === 1) {\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n\t\t\t\taction: null,\n\t\t\t\tline: precedingUnIgnoredLine\n\t\t\t};\n\t\t}\n\n\t\tconst previousLine = precedingUnIgnoredLine - 1;\n\n\t\tconst previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n\t\tif (!(previousLineIndentMetadata & (IndentConsts.INCREASE_MASK | IndentConsts.DECREASE_MASK)) &&\n\t\t\t(previousLineIndentMetadata & IndentConsts.INDENT_NEXTLINE_MASK)) {\n\t\t\tlet stopLine = 0;\n\t\t\tfor (let i = previousLine - 1; i > 0; i--) {\n\t\t\t\tif (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstopLine = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n\t\t\t\taction: null,\n\t\t\t\tline: stopLine + 1\n\t\t\t};\n\t\t}\n\n\t\tif (honorIntentialIndent) {\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n\t\t\t\taction: null,\n\t\t\t\tline: precedingUnIgnoredLine\n\t\t\t};\n\t\t} else {\n\t\t\t// search from precedingUnIgnoredLine until we find one whose indent is not temporary\n\t\t\tfor (let i = precedingUnIgnoredLine; i > 0; i--) {\n\t\t\t\tconst lineContent = model.getLineContent(i);\n\t\t\t\tif (indentRulesSupport.shouldIncrease(lineContent)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(lineContent),\n\t\t\t\t\t\taction: IndentAction.Indent,\n\t\t\t\t\t\tline: i\n\t\t\t\t\t};\n\t\t\t\t} else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n\t\t\t\t\tlet stopLine = 0;\n\t\t\t\t\tfor (let j = i - 1; j > 0; j--) {\n\t\t\t\t\t\tif (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstopLine = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n\t\t\t\t\t\taction: null,\n\t\t\t\t\t\tline: stopLine + 1\n\t\t\t\t\t};\n\t\t\t\t} else if (indentRulesSupport.shouldDecrease(lineContent)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(lineContent),\n\t\t\t\t\t\taction: null,\n\t\t\t\t\t\tline: i\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n\t\t\t\taction: null,\n\t\t\t\tline: 1\n\t\t\t};\n\t\t}\n\t}\n}\n\nexport function getGoodIndentForLine(\n\tautoIndent: EditorAutoIndentStrategy,\n\tvirtualModel: IVirtualModel,\n\tlanguageId: string,\n\tlineNumber: number,\n\tindentConverter: IIndentConverter,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): string | null {\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\n\tconst richEditSupport = languageConfigurationService.getLanguageConfiguration(languageId);\n\tif (!richEditSupport) {\n\t\treturn null;\n\t}\n\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\n\tconst indent = getInheritIndentForLine(autoIndent, virtualModel, lineNumber, undefined, languageConfigurationService);\n\tconst lineContent = virtualModel.getLineContent(lineNumber);\n\n\tif (indent) {\n\t\tconst inheritLine = indent.line;\n\t\tif (inheritLine !== undefined) {\n\t\t\t// Apply enter action as long as there are only whitespace lines between inherited line and this line.\n\t\t\tlet shouldApplyEnterRules = true;\n\t\t\tfor (let inBetweenLine = inheritLine; inBetweenLine < lineNumber - 1; inBetweenLine++) {\n\t\t\t\tif (!/^\\s*$/.test(virtualModel.getLineContent(inBetweenLine))) {\n\t\t\t\t\tshouldApplyEnterRules = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (shouldApplyEnterRules) {\n\t\t\t\tconst enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n\n\t\t\t\tif (enterResult) {\n\t\t\t\t\tlet indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n\n\t\t\t\t\tif (enterResult.removeText) {\n\t\t\t\t\t\tindentation = indentation.substring(0, indentation.length - enterResult.removeText);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t(enterResult.indentAction === IndentAction.Indent) ||\n\t\t\t\t\t\t(enterResult.indentAction === IndentAction.IndentOutdent)\n\t\t\t\t\t) {\n\t\t\t\t\t\tindentation = indentConverter.shiftIndent(indentation);\n\t\t\t\t\t} else if (enterResult.indentAction === IndentAction.Outdent) {\n\t\t\t\t\t\tindentation = indentConverter.unshiftIndent(indentation);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (indentRulesSupport.shouldDecrease(lineContent)) {\n\t\t\t\t\t\tindentation = indentConverter.unshiftIndent(indentation);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (enterResult.appendText) {\n\t\t\t\t\t\tindentation += enterResult.appendText;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn strings.getLeadingWhitespace(indentation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (indentRulesSupport.shouldDecrease(lineContent)) {\n\t\t\tif (indent.action === IndentAction.Indent) {\n\t\t\t\treturn indent.indentation;\n\t\t\t} else {\n\t\t\t\treturn indentConverter.unshiftIndent(indent.indentation);\n\t\t\t}\n\t\t} else {\n\t\t\tif (indent.action === IndentAction.Indent) {\n\t\t\t\treturn indentConverter.shiftIndent(indent.indentation);\n\t\t\t} else {\n\t\t\t\treturn indent.indentation;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n\nexport function getIndentForEnter(\n\tautoIndent: EditorAutoIndentStrategy,\n\tmodel: ITextModel,\n\trange: Range,\n\tindentConverter: IIndentConverter,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): { beforeEnter: string; afterEnter: string } | null {\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\tmodel.tokenization.forceTokenization(range.startLineNumber);\n\tconst lineTokens = model.tokenization.getLineTokens(range.startLineNumber);\n\tconst scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n\tconst scopedLineText = scopedLineTokens.getLineContent();\n\n\tlet embeddedLanguage = false;\n\tlet beforeEnterText: string;\n\tif (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n\t\t// we are in the embeded language content\n\t\tembeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n\t\tbeforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n\t} else {\n\t\tbeforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n\t}\n\n\tlet afterEnterText: string;\n\tif (range.isEmpty()) {\n\t\tafterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n\t} else {\n\t\tconst endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n\t\tafterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n\t}\n\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\n\tconst beforeEnterResult = beforeEnterText;\n\tconst beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n\n\tconst virtualModel: IVirtualModel = {\n\t\ttokenization: {\n\t\t\tgetLineTokens: (lineNumber: number) => {\n\t\t\t\treturn model.tokenization.getLineTokens(lineNumber);\n\t\t\t},\n\t\t\tgetLanguageId: () => {\n\t\t\t\treturn model.getLanguageId();\n\t\t\t},\n\t\t\tgetLanguageIdAtPosition: (lineNumber: number, column: number) => {\n\t\t\t\treturn model.getLanguageIdAtPosition(lineNumber, column);\n\t\t\t},\n\t\t},\n\t\tgetLineContent: (lineNumber: number) => {\n\t\t\tif (lineNumber === range.startLineNumber) {\n\t\t\t\treturn beforeEnterResult;\n\t\t\t} else {\n\t\t\t\treturn model.getLineContent(lineNumber);\n\t\t\t}\n\t\t}\n\t};\n\n\tconst currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n\tconst afterEnterAction = getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1, undefined, languageConfigurationService);\n\tif (!afterEnterAction) {\n\t\tconst beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n\t\treturn {\n\t\t\tbeforeEnter: beforeEnter,\n\t\t\tafterEnter: beforeEnter\n\t\t};\n\t}\n\n\tlet afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n\n\tif (afterEnterAction.action === IndentAction.Indent) {\n\t\tafterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n\t}\n\n\tif (indentRulesSupport.shouldDecrease(afterEnterText)) {\n\t\tafterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n\t}\n\n\treturn {\n\t\tbeforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n\t\tafterEnter: afterEnterIndent\n\t};\n}\n\n/**\n * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n */\nexport function getIndentActionForType(\n\tautoIndent: EditorAutoIndentStrategy,\n\tmodel: ITextModel,\n\trange: Range,\n\tch: string,\n\tindentConverter: IIndentConverter,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): string | null {\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\tconst scopedLineTokens = getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n\n\tif (scopedLineTokens.firstCharOffset) {\n\t\t// this line has mixed languages and indentation rules will not work\n\t\treturn null;\n\t}\n\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\n\tconst scopedLineText = scopedLineTokens.getLineContent();\n\tconst beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n\n\t// selection support\n\tlet afterTypeText: string;\n\tif (range.isEmpty()) {\n\t\tafterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n\t} else {\n\t\tconst endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n\t\tafterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n\t}\n\n\t// If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n\t// Users might change the indentation by purpose and we should honor that instead of readjusting.\n\tif (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n\t\t// after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n\t\t// 1. Get inherited indent action\n\t\tconst r = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);\n\t\tif (!r) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet indentation = r.indentation;\n\t\tif (r.action !== IndentAction.Indent) {\n\t\t\tindentation = indentConverter.unshiftIndent(indentation);\n\t\t}\n\n\t\treturn indentation;\n\t}\n\n\treturn null;\n}\n\nexport function getIndentMetadata(\n\tmodel: ITextModel,\n\tlineNumber: number,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): number | null {\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\tif (lineNumber < 1 || lineNumber > model.getLineCount()) {\n\t\treturn null;\n\t}\n\treturn indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../base/common/strings';\nimport { Range } from '../core/range';\nimport { ITextModel } from '../model';\nimport { IndentAction } from './languageConfiguration';\nimport { createScopedLineTokens } from './supports';\nimport { IndentConsts, IndentRulesSupport } from './supports/indentRules';\nimport { EditorAutoIndentStrategy } from '../config/editorOptions';\nimport { getScopedLineTokens, ILanguageConfigurationService } from './languageConfigurationRegistry';\nimport { LineTokens } from '../tokens/lineTokens';\n\nexport interface IVirtualModel {\n\ttokenization: {\n\t\tgetLineTokens(lineNumber: number): LineTokens;\n\t\tgetLanguageId(): string;\n\t\tgetLanguageIdAtPosition(lineNumber: number, column: number): string;\n\t};\n\tgetLineContent(lineNumber: number): string;\n}\n\nexport interface IIndentConverter {\n\tshiftIndent(indentation: string): string;\n\tunshiftIndent(indentation: string): string;\n\tnormalizeIndentation?(indentation: string): string;\n}\n\n/**\n * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n * Result:\n * -1: run into the boundary of embedded languages\n * 0: every line above are invalid\n * else: nearest preceding line of the same language\n */\nfunction getPrecedingValidLine(model: IVirtualModel, lineNumber: number, indentRulesSupport: IndentRulesSupport) {\n\tconst languageId = model.tokenization.getLanguageIdAtPosition(lineNumber, 0);\n\tif (lineNumber > 1) {\n\t\tlet lastLineNumber: number;\n\t\tlet resultLineNumber = -1;\n\n\t\tfor (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n\t\t\tif (model.tokenization.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {\n\t\t\t\treturn resultLineNumber;\n\t\t\t}\n\t\t\tconst text = model.getLineContent(lastLineNumber);\n\t\t\tif (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n\t\t\t\tresultLineNumber = lastLineNumber;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn lastLineNumber;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Get inherited indentation from above lines.\n * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n * 3. If this line doesn't match any indent rules\n *   a. check whether the line above it matches indentNextLinePattern\n *   b. If not, the indent level of this line is the result\n *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n *\n * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n */\nexport function getInheritIndentForLine(\n\tautoIndent: EditorAutoIndentStrategy,\n\tmodel: IVirtualModel,\n\tlineNumber: number,\n\thonorIntentialIndent: boolean = true,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): { indentation: string; action: IndentAction | null; line?: number } | null {\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.tokenization.getLanguageId()).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\n\tif (lineNumber <= 1) {\n\t\treturn {\n\t\t\tindentation: '',\n\t\t\taction: null\n\t\t};\n\t}\n\n\t// Use no indent if this is the first non-blank line\n\tfor (let priorLineNumber = lineNumber - 1; priorLineNumber > 0; priorLineNumber--) {\n\t\tif (model.getLineContent(priorLineNumber) !== '') {\n\t\t\tbreak;\n\t\t}\n\t\tif (priorLineNumber === 1) {\n\t\t\treturn {\n\t\t\t\tindentation: '',\n\t\t\t\taction: null\n\t\t\t};\n\t\t}\n\t}\n\n\tconst precedingUnIgnoredLine = getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n\tif (precedingUnIgnoredLine < 0) {\n\t\treturn null;\n\t} else if (precedingUnIgnoredLine < 1) {\n\t\treturn {\n\t\t\tindentation: '',\n\t\t\taction: null\n\t\t};\n\t}\n\n\tconst precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n\tif (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n\t\treturn {\n\t\t\tindentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n\t\t\taction: IndentAction.Indent,\n\t\t\tline: precedingUnIgnoredLine\n\t\t};\n\t} else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n\t\treturn {\n\t\t\tindentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n\t\t\taction: null,\n\t\t\tline: precedingUnIgnoredLine\n\t\t};\n\t} else {\n\t\t// precedingUnIgnoredLine can not be ignored.\n\t\t// it doesn't increase indent of following lines\n\t\t// it doesn't increase just next line\n\t\t// so current line is not affect by precedingUnIgnoredLine\n\t\t// and then we should get a correct inheritted indentation from above lines\n\t\tif (precedingUnIgnoredLine === 1) {\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n\t\t\t\taction: null,\n\t\t\t\tline: precedingUnIgnoredLine\n\t\t\t};\n\t\t}\n\n\t\tconst previousLine = precedingUnIgnoredLine - 1;\n\n\t\tconst previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n\t\tif (!(previousLineIndentMetadata & (IndentConsts.INCREASE_MASK | IndentConsts.DECREASE_MASK)) &&\n\t\t\t(previousLineIndentMetadata & IndentConsts.INDENT_NEXTLINE_MASK)) {\n\t\t\tlet stopLine = 0;\n\t\t\tfor (let i = previousLine - 1; i > 0; i--) {\n\t\t\t\tif (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstopLine = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n\t\t\t\taction: null,\n\t\t\t\tline: stopLine + 1\n\t\t\t};\n\t\t}\n\n\t\tif (honorIntentialIndent) {\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n\t\t\t\taction: null,\n\t\t\t\tline: precedingUnIgnoredLine\n\t\t\t};\n\t\t} else {\n\t\t\t// search from precedingUnIgnoredLine until we find one whose indent is not temporary\n\t\t\tfor (let i = precedingUnIgnoredLine; i > 0; i--) {\n\t\t\t\tconst lineContent = model.getLineContent(i);\n\t\t\t\tif (indentRulesSupport.shouldIncrease(lineContent)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(lineContent),\n\t\t\t\t\t\taction: IndentAction.Indent,\n\t\t\t\t\t\tline: i\n\t\t\t\t\t};\n\t\t\t\t} else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n\t\t\t\t\tlet stopLine = 0;\n\t\t\t\t\tfor (let j = i - 1; j > 0; j--) {\n\t\t\t\t\t\tif (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstopLine = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n\t\t\t\t\t\taction: null,\n\t\t\t\t\t\tline: stopLine + 1\n\t\t\t\t\t};\n\t\t\t\t} else if (indentRulesSupport.shouldDecrease(lineContent)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(lineContent),\n\t\t\t\t\t\taction: null,\n\t\t\t\t\t\tline: i\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n\t\t\t\taction: null,\n\t\t\t\tline: 1\n\t\t\t};\n\t\t}\n\t}\n}\n\nexport function getGoodIndentForLine(\n\tautoIndent: EditorAutoIndentStrategy,\n\tvirtualModel: IVirtualModel,\n\tlanguageId: string,\n\tlineNumber: number,\n\tindentConverter: IIndentConverter,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): string | null {\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\n\tconst richEditSupport = languageConfigurationService.getLanguageConfiguration(languageId);\n\tif (!richEditSupport) {\n\t\treturn null;\n\t}\n\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\n\tconst indent = getInheritIndentForLine(autoIndent, virtualModel, lineNumber, undefined, languageConfigurationService);\n\tconst lineContent = virtualModel.getLineContent(lineNumber);\n\n\tif (indent) {\n\t\tconst inheritLine = indent.line;\n\t\tif (inheritLine !== undefined) {\n\t\t\t// Apply enter action as long as there are only whitespace lines between inherited line and this line.\n\t\t\tlet shouldApplyEnterRules = true;\n\t\t\tfor (let inBetweenLine = inheritLine; inBetweenLine < lineNumber - 1; inBetweenLine++) {\n\t\t\t\tif (!/^\\s*$/.test(virtualModel.getLineContent(inBetweenLine))) {\n\t\t\t\t\tshouldApplyEnterRules = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (shouldApplyEnterRules) {\n\t\t\t\tconst enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n\n\t\t\t\tif (enterResult) {\n\t\t\t\t\tlet indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n\n\t\t\t\t\tif (enterResult.removeText) {\n\t\t\t\t\t\tindentation = indentation.substring(0, indentation.length - enterResult.removeText);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t(enterResult.indentAction === IndentAction.Indent) ||\n\t\t\t\t\t\t(enterResult.indentAction === IndentAction.IndentOutdent)\n\t\t\t\t\t) {\n\t\t\t\t\t\tindentation = indentConverter.shiftIndent(indentation);\n\t\t\t\t\t} else if (enterResult.indentAction === IndentAction.Outdent) {\n\t\t\t\t\t\tindentation = indentConverter.unshiftIndent(indentation);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (indentRulesSupport.shouldDecrease(lineContent)) {\n\t\t\t\t\t\tindentation = indentConverter.unshiftIndent(indentation);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (enterResult.appendText) {\n\t\t\t\t\t\tindentation += enterResult.appendText;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn strings.getLeadingWhitespace(indentation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (indentRulesSupport.shouldDecrease(lineContent)) {\n\t\t\tif (indent.action === IndentAction.Indent) {\n\t\t\t\treturn indent.indentation;\n\t\t\t} else {\n\t\t\t\treturn indentConverter.unshiftIndent(indent.indentation);\n\t\t\t}\n\t\t} else {\n\t\t\tif (indent.action === IndentAction.Indent) {\n\t\t\t\treturn indentConverter.shiftIndent(indent.indentation);\n\t\t\t} else {\n\t\t\t\treturn indent.indentation;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n\nexport function getIndentForEnter(\n\tautoIndent: EditorAutoIndentStrategy,\n\tmodel: ITextModel,\n\trange: Range,\n\tindentConverter: IIndentConverter,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): { beforeEnter: string; afterEnter: string } | null {\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\tmodel.tokenization.forceTokenization(range.startLineNumber);\n\tconst lineTokens = model.tokenization.getLineTokens(range.startLineNumber);\n\tconst scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n\tconst scopedLineText = scopedLineTokens.getLineContent();\n\n\tlet embeddedLanguage = false;\n\tlet beforeEnterText: string;\n\tif (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n\t\t// we are in the embeded language content\n\t\tembeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n\t\tbeforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n\t} else {\n\t\tbeforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n\t}\n\n\tlet afterEnterText: string;\n\tif (range.isEmpty()) {\n\t\tafterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n\t} else {\n\t\tconst endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n\t\tafterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n\t}\n\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\n\tconst beforeEnterResult = beforeEnterText;\n\tconst beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n\n\tconst virtualModel: IVirtualModel = {\n\t\ttokenization: {\n\t\t\tgetLineTokens: (lineNumber: number) => {\n\t\t\t\treturn model.tokenization.getLineTokens(lineNumber);\n\t\t\t},\n\t\t\tgetLanguageId: () => {\n\t\t\t\treturn model.getLanguageId();\n\t\t\t},\n\t\t\tgetLanguageIdAtPosition: (lineNumber: number, column: number) => {\n\t\t\t\treturn model.getLanguageIdAtPosition(lineNumber, column);\n\t\t\t},\n\t\t},\n\t\tgetLineContent: (lineNumber: number) => {\n\t\t\tif (lineNumber === range.startLineNumber) {\n\t\t\t\treturn beforeEnterResult;\n\t\t\t} else {\n\t\t\t\treturn model.getLineContent(lineNumber);\n\t\t\t}\n\t\t}\n\t};\n\n\tconst currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n\tconst afterEnterAction = getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1, undefined, languageConfigurationService);\n\tif (!afterEnterAction) {\n\t\tconst beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n\t\treturn {\n\t\t\tbeforeEnter: beforeEnter,\n\t\t\tafterEnter: beforeEnter\n\t\t};\n\t}\n\n\tlet afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n\n\tif (afterEnterAction.action === IndentAction.Indent) {\n\t\tafterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n\t}\n\n\tif (indentRulesSupport.shouldDecrease(afterEnterText)) {\n\t\tafterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n\t}\n\n\treturn {\n\t\tbeforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n\t\tafterEnter: afterEnterIndent\n\t};\n}\n\n/**\n * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n */\nexport function getIndentActionForType(\n\tautoIndent: EditorAutoIndentStrategy,\n\tmodel: ITextModel,\n\trange: Range,\n\tch: string,\n\tindentConverter: IIndentConverter,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): string | null {\n\tif (autoIndent < EditorAutoIndentStrategy.Full) {\n\t\treturn null;\n\t}\n\tconst scopedLineTokens = getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n\n\tif (scopedLineTokens.firstCharOffset) {\n\t\t// this line has mixed languages and indentation rules will not work\n\t\treturn null;\n\t}\n\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\n\tconst scopedLineText = scopedLineTokens.getLineContent();\n\tconst beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n\n\t// selection support\n\tlet afterTypeText: string;\n\tif (range.isEmpty()) {\n\t\tafterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n\t} else {\n\t\tconst endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n\t\tafterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n\t}\n\n\t// If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n\t// Users might change the indentation by purpose and we should honor that instead of readjusting.\n\tif (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n\t\t// after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n\t\t// 1. Get inherited indent action\n\t\tconst r = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);\n\t\tif (!r) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet indentation = r.indentation;\n\t\tif (r.action !== IndentAction.Indent) {\n\t\t\tindentation = indentConverter.unshiftIndent(indentation);\n\t\t}\n\n\t\treturn indentation;\n\t}\n\n\treturn null;\n}\n\nexport function getIndentMetadata(\n\tmodel: ITextModel,\n\tlineNumber: number,\n\tlanguageConfigurationService: ILanguageConfigurationService\n): number | null {\n\tconst indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentRulesSupport;\n\tif (!indentRulesSupport) {\n\t\treturn null;\n\t}\n\tif (lineNumber < 1 || lineNumber > model.getLineCount()) {\n\t\treturn null;\n\t}\n\treturn indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n}\n"]}