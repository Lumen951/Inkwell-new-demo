{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/editor/common/services/semanticTokensDto.ts","vs/editor/common/services/semanticTokensDto.ts"],"names":[],"mappings":"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","file":"semanticTokensDto.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../../base/common/buffer';\nimport * as platform from '../../../base/common/platform';\n\nexport interface IFullSemanticTokensDto {\n\tid: number;\n\ttype: 'full';\n\tdata: Uint32Array;\n}\n\nexport interface IDeltaSemanticTokensDto {\n\tid: number;\n\ttype: 'delta';\n\tdeltas: { start: number; deleteCount: number; data?: Uint32Array }[];\n}\n\nexport type ISemanticTokensDto = IFullSemanticTokensDto | IDeltaSemanticTokensDto;\n\nconst enum EncodedSemanticTokensType {\n\tFull = 1,\n\tDelta = 2\n}\n\nfunction reverseEndianness(arr: Uint8Array): void {\n\tfor (let i = 0, len = arr.length; i < len; i += 4) {\n\t\t// flip bytes 0<->3 and 1<->2\n\t\tconst b0 = arr[i + 0];\n\t\tconst b1 = arr[i + 1];\n\t\tconst b2 = arr[i + 2];\n\t\tconst b3 = arr[i + 3];\n\t\tarr[i + 0] = b3;\n\t\tarr[i + 1] = b2;\n\t\tarr[i + 2] = b1;\n\t\tarr[i + 3] = b0;\n\t}\n}\n\nfunction toLittleEndianBuffer(arr: Uint32Array): VSBuffer {\n\tconst uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);\n\tif (!platform.isLittleEndian()) {\n\t\t// the byte order must be changed\n\t\treverseEndianness(uint8Arr);\n\t}\n\treturn VSBuffer.wrap(uint8Arr);\n}\n\nfunction fromLittleEndianBuffer(buff: VSBuffer): Uint32Array {\n\tconst uint8Arr = buff.buffer;\n\tif (!platform.isLittleEndian()) {\n\t\t// the byte order must be changed\n\t\treverseEndianness(uint8Arr);\n\t}\n\tif (uint8Arr.byteOffset % 4 === 0) {\n\t\treturn new Uint32Array(uint8Arr.buffer, uint8Arr.byteOffset, uint8Arr.length / 4);\n\t} else {\n\t\t// unaligned memory access doesn't work on all platforms\n\t\tconst data = new Uint8Array(uint8Arr.byteLength);\n\t\tdata.set(uint8Arr);\n\t\treturn new Uint32Array(data.buffer, data.byteOffset, data.length / 4);\n\t}\n}\n\nexport function encodeSemanticTokensDto(semanticTokens: ISemanticTokensDto): VSBuffer {\n\tconst dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));\n\tlet offset = 0;\n\tdest[offset++] = semanticTokens.id;\n\tif (semanticTokens.type === 'full') {\n\t\tdest[offset++] = EncodedSemanticTokensType.Full;\n\t\tdest[offset++] = semanticTokens.data.length;\n\t\tdest.set(semanticTokens.data, offset); offset += semanticTokens.data.length;\n\t} else {\n\t\tdest[offset++] = EncodedSemanticTokensType.Delta;\n\t\tdest[offset++] = semanticTokens.deltas.length;\n\t\tfor (const delta of semanticTokens.deltas) {\n\t\t\tdest[offset++] = delta.start;\n\t\t\tdest[offset++] = delta.deleteCount;\n\t\t\tif (delta.data) {\n\t\t\t\tdest[offset++] = delta.data.length;\n\t\t\t\tdest.set(delta.data, offset); offset += delta.data.length;\n\t\t\t} else {\n\t\t\t\tdest[offset++] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn toLittleEndianBuffer(dest);\n}\n\nfunction encodeSemanticTokensDtoSize(semanticTokens: ISemanticTokensDto): number {\n\tlet result = 0;\n\tresult += (\n\t\t+ 1 // id\n\t\t+ 1 // type\n\t);\n\tif (semanticTokens.type === 'full') {\n\t\tresult += (\n\t\t\t+ 1 // data length\n\t\t\t+ semanticTokens.data.length\n\t\t);\n\t} else {\n\t\tresult += (\n\t\t\t+ 1 // delta count\n\t\t);\n\t\tresult += (\n\t\t\t+ 1 // start\n\t\t\t+ 1 // deleteCount\n\t\t\t+ 1 // data length\n\t\t) * semanticTokens.deltas.length;\n\t\tfor (const delta of semanticTokens.deltas) {\n\t\t\tif (delta.data) {\n\t\t\t\tresult += delta.data.length;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nexport function decodeSemanticTokensDto(_buff: VSBuffer): ISemanticTokensDto {\n\tconst src = fromLittleEndianBuffer(_buff);\n\tlet offset = 0;\n\tconst id = src[offset++];\n\tconst type: EncodedSemanticTokensType = src[offset++];\n\tif (type === EncodedSemanticTokensType.Full) {\n\t\tconst length = src[offset++];\n\t\tconst data = src.subarray(offset, offset + length); offset += length;\n\t\treturn {\n\t\t\tid: id,\n\t\t\ttype: 'full',\n\t\t\tdata: data\n\t\t};\n\t}\n\tconst deltaCount = src[offset++];\n\tconst deltas: { start: number; deleteCount: number; data?: Uint32Array }[] = [];\n\tfor (let i = 0; i < deltaCount; i++) {\n\t\tconst start = src[offset++];\n\t\tconst deleteCount = src[offset++];\n\t\tconst length = src[offset++];\n\t\tlet data: Uint32Array | undefined;\n\t\tif (length > 0) {\n\t\t\tdata = src.subarray(offset, offset + length); offset += length;\n\t\t}\n\t\tdeltas[i] = { start, deleteCount, data };\n\t}\n\treturn {\n\t\tid: id,\n\t\ttype: 'delta',\n\t\tdeltas: deltas\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../../base/common/buffer';\nimport * as platform from '../../../base/common/platform';\n\nexport interface IFullSemanticTokensDto {\n\tid: number;\n\ttype: 'full';\n\tdata: Uint32Array;\n}\n\nexport interface IDeltaSemanticTokensDto {\n\tid: number;\n\ttype: 'delta';\n\tdeltas: { start: number; deleteCount: number; data?: Uint32Array }[];\n}\n\nexport type ISemanticTokensDto = IFullSemanticTokensDto | IDeltaSemanticTokensDto;\n\nconst enum EncodedSemanticTokensType {\n\tFull = 1,\n\tDelta = 2\n}\n\nfunction reverseEndianness(arr: Uint8Array): void {\n\tfor (let i = 0, len = arr.length; i < len; i += 4) {\n\t\t// flip bytes 0<->3 and 1<->2\n\t\tconst b0 = arr[i + 0];\n\t\tconst b1 = arr[i + 1];\n\t\tconst b2 = arr[i + 2];\n\t\tconst b3 = arr[i + 3];\n\t\tarr[i + 0] = b3;\n\t\tarr[i + 1] = b2;\n\t\tarr[i + 2] = b1;\n\t\tarr[i + 3] = b0;\n\t}\n}\n\nfunction toLittleEndianBuffer(arr: Uint32Array): VSBuffer {\n\tconst uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);\n\tif (!platform.isLittleEndian()) {\n\t\t// the byte order must be changed\n\t\treverseEndianness(uint8Arr);\n\t}\n\treturn VSBuffer.wrap(uint8Arr);\n}\n\nfunction fromLittleEndianBuffer(buff: VSBuffer): Uint32Array {\n\tconst uint8Arr = buff.buffer;\n\tif (!platform.isLittleEndian()) {\n\t\t// the byte order must be changed\n\t\treverseEndianness(uint8Arr);\n\t}\n\tif (uint8Arr.byteOffset % 4 === 0) {\n\t\treturn new Uint32Array(uint8Arr.buffer, uint8Arr.byteOffset, uint8Arr.length / 4);\n\t} else {\n\t\t// unaligned memory access doesn't work on all platforms\n\t\tconst data = new Uint8Array(uint8Arr.byteLength);\n\t\tdata.set(uint8Arr);\n\t\treturn new Uint32Array(data.buffer, data.byteOffset, data.length / 4);\n\t}\n}\n\nexport function encodeSemanticTokensDto(semanticTokens: ISemanticTokensDto): VSBuffer {\n\tconst dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));\n\tlet offset = 0;\n\tdest[offset++] = semanticTokens.id;\n\tif (semanticTokens.type === 'full') {\n\t\tdest[offset++] = EncodedSemanticTokensType.Full;\n\t\tdest[offset++] = semanticTokens.data.length;\n\t\tdest.set(semanticTokens.data, offset); offset += semanticTokens.data.length;\n\t} else {\n\t\tdest[offset++] = EncodedSemanticTokensType.Delta;\n\t\tdest[offset++] = semanticTokens.deltas.length;\n\t\tfor (const delta of semanticTokens.deltas) {\n\t\t\tdest[offset++] = delta.start;\n\t\t\tdest[offset++] = delta.deleteCount;\n\t\t\tif (delta.data) {\n\t\t\t\tdest[offset++] = delta.data.length;\n\t\t\t\tdest.set(delta.data, offset); offset += delta.data.length;\n\t\t\t} else {\n\t\t\t\tdest[offset++] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn toLittleEndianBuffer(dest);\n}\n\nfunction encodeSemanticTokensDtoSize(semanticTokens: ISemanticTokensDto): number {\n\tlet result = 0;\n\tresult += (\n\t\t+ 1 // id\n\t\t+ 1 // type\n\t);\n\tif (semanticTokens.type === 'full') {\n\t\tresult += (\n\t\t\t+ 1 // data length\n\t\t\t+ semanticTokens.data.length\n\t\t);\n\t} else {\n\t\tresult += (\n\t\t\t+ 1 // delta count\n\t\t);\n\t\tresult += (\n\t\t\t+ 1 // start\n\t\t\t+ 1 // deleteCount\n\t\t\t+ 1 // data length\n\t\t) * semanticTokens.deltas.length;\n\t\tfor (const delta of semanticTokens.deltas) {\n\t\t\tif (delta.data) {\n\t\t\t\tresult += delta.data.length;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nexport function decodeSemanticTokensDto(_buff: VSBuffer): ISemanticTokensDto {\n\tconst src = fromLittleEndianBuffer(_buff);\n\tlet offset = 0;\n\tconst id = src[offset++];\n\tconst type: EncodedSemanticTokensType = src[offset++];\n\tif (type === EncodedSemanticTokensType.Full) {\n\t\tconst length = src[offset++];\n\t\tconst data = src.subarray(offset, offset + length); offset += length;\n\t\treturn {\n\t\t\tid: id,\n\t\t\ttype: 'full',\n\t\t\tdata: data\n\t\t};\n\t}\n\tconst deltaCount = src[offset++];\n\tconst deltas: { start: number; deleteCount: number; data?: Uint32Array }[] = [];\n\tfor (let i = 0; i < deltaCount; i++) {\n\t\tconst start = src[offset++];\n\t\tconst deleteCount = src[offset++];\n\t\tconst length = src[offset++];\n\t\tlet data: Uint32Array | undefined;\n\t\tif (length > 0) {\n\t\t\tdata = src.subarray(offset, offset + length); offset += length;\n\t\t}\n\t\tdeltas[i] = { start, deleteCount, data };\n\t}\n\treturn {\n\t\tid: id,\n\t\ttype: 'delta',\n\t\tdeltas: deltas\n\t};\n}\n"]}