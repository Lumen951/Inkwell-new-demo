{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/editor/common/services/editorSimpleWorker.ts","vs/editor/common/services/editorSimpleWorker.ts"],"names":[],"mappings":"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","file":"editorSimpleWorker.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { stringDiff } from '../../../base/common/diff/diff';\nimport { IDisposable } from '../../../base/common/lifecycle';\nimport { URI } from '../../../base/common/uri';\nimport { IRequestHandler } from '../../../base/common/worker/simpleWorker';\nimport { IPosition, Position } from '../core/position';\nimport { IRange, Range } from '../core/range';\nimport { EndOfLineSequence, ITextModel } from '../model';\nimport { IMirrorTextModel, IModelChangedEvent, MirrorTextModel as BaseMirrorModel } from '../model/mirrorTextModel';\nimport { ensureValidWordDefinition, getWordAtText, IWordAtPosition } from '../core/wordHelper';\nimport { IColorInformation, IInplaceReplaceSupportResult, ILink, TextEdit } from '../languages';\nimport { ILinkComputerTarget, computeLinks } from '../languages/linkComputer';\nimport { BasicInplaceReplace } from '../languages/supports/inplaceReplaceSupport';\nimport { DiffAlgorithmName, IDiffComputationResult, ILineChange, IUnicodeHighlightsResult } from './editorWorker';\nimport { createMonacoBaseAPI } from './editorBaseApi';\nimport { IEditorWorkerHost } from './editorWorkerHost';\nimport { StopWatch } from '../../../base/common/stopwatch';\nimport { UnicodeTextModelHighlighter, UnicodeHighlighterOptions } from './unicodeTextModelHighlighter';\nimport { DiffComputer, IChange } from '../diff/legacyLinesDiffComputer';\nimport { ILinesDiffComputer, ILinesDiffComputerOptions } from '../diff/linesDiffComputer';\nimport { DetailedLineRangeMapping } from '../diff/rangeMapping';\nimport { linesDiffComputers } from '../diff/linesDiffComputers';\nimport { createProxyObject, getAllMethodNames } from '../../../base/common/objects';\nimport { IDocumentDiffProviderOptions } from '../diff/documentDiffProvider';\nimport { BugIndicatingError } from '../../../base/common/errors';\nimport { IDocumentColorComputerTarget, computeDefaultDocumentColors } from '../languages/defaultDocumentColorsComputer';\n\nexport interface IMirrorModel extends IMirrorTextModel {\n\treadonly uri: URI;\n\treadonly version: number;\n\tgetValue(): string;\n}\n\nexport interface IWorkerContext<H = undefined> {\n\t/**\n\t * A proxy to the main thread host object.\n\t */\n\thost: H;\n\t/**\n\t * Get all available mirror models in this worker.\n\t */\n\tgetMirrorModels(): IMirrorModel[];\n}\n\n/**\n * @internal\n */\nexport interface IRawModelData {\n\turl: string;\n\tversionId: number;\n\tlines: string[];\n\tEOL: string;\n}\n\n/**\n * @internal\n */\nexport interface ICommonModel extends ILinkComputerTarget, IDocumentColorComputerTarget, IMirrorModel {\n\turi: URI;\n\tversion: number;\n\teol: string;\n\tgetValue(): string;\n\n\tgetLinesContent(): string[];\n\tgetLineCount(): number;\n\tgetLineContent(lineNumber: number): string;\n\tgetLineWords(lineNumber: number, wordDefinition: RegExp): IWordAtPosition[];\n\twords(wordDefinition: RegExp): Iterable<string>;\n\tgetWordUntilPosition(position: IPosition, wordDefinition: RegExp): IWordAtPosition;\n\tgetValueInRange(range: IRange): string;\n\tgetWordAtPosition(position: IPosition, wordDefinition: RegExp): Range | null;\n\toffsetAt(position: IPosition): number;\n\tpositionAt(offset: number): IPosition;\n\tfindMatches(regex: RegExp): RegExpMatchArray[];\n}\n\n/**\n * Range of a word inside a model.\n * @internal\n */\ninterface IWordRange {\n\t/**\n\t * The index where the word starts.\n\t */\n\treadonly start: number;\n\t/**\n\t * The index where the word ends.\n\t */\n\treadonly end: number;\n}\n\n/**\n * @internal\n */\nclass MirrorModel extends BaseMirrorModel implements ICommonModel {\n\n\tpublic get uri(): URI {\n\t\treturn this._uri;\n\t}\n\n\tpublic get eol(): string {\n\t\treturn this._eol;\n\t}\n\n\tpublic getValue(): string {\n\t\treturn this.getText();\n\t}\n\n\tpublic findMatches(regex: RegExp): RegExpMatchArray[] {\n\t\tconst matches = [];\n\t\tfor (let i = 0; i < this._lines.length; i++) {\n\t\t\tconst line = this._lines[i];\n\t\t\tconst offsetToAdd = this.offsetAt(new Position(i + 1, 1));\n\t\t\tconst iteratorOverMatches = line.matchAll(regex);\n\t\t\tfor (const match of iteratorOverMatches) {\n\t\t\t\tif (match.index || match.index === 0) {\n\t\t\t\t\tmatch.index = match.index + offsetToAdd;\n\t\t\t\t}\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t}\n\t\treturn matches;\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\treturn this._lines.slice(0);\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._lines.length;\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\treturn this._lines[lineNumber - 1];\n\t}\n\n\tpublic getWordAtPosition(position: IPosition, wordDefinition: RegExp): Range | null {\n\n\t\tconst wordAtText = getWordAtText(\n\t\t\tposition.column,\n\t\t\tensureValidWordDefinition(wordDefinition),\n\t\t\tthis._lines[position.lineNumber - 1],\n\t\t\t0\n\t\t);\n\n\t\tif (wordAtText) {\n\t\t\treturn new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic getWordUntilPosition(position: IPosition, wordDefinition: RegExp): IWordAtPosition {\n\t\tconst wordAtPosition = this.getWordAtPosition(position, wordDefinition);\n\t\tif (!wordAtPosition) {\n\t\t\treturn {\n\t\t\t\tword: '',\n\t\t\t\tstartColumn: position.column,\n\t\t\t\tendColumn: position.column\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tword: this._lines[position.lineNumber - 1].substring(wordAtPosition.startColumn - 1, position.column - 1),\n\t\t\tstartColumn: wordAtPosition.startColumn,\n\t\t\tendColumn: position.column\n\t\t};\n\t}\n\n\n\tpublic words(wordDefinition: RegExp): Iterable<string> {\n\n\t\tconst lines = this._lines;\n\t\tconst wordenize = this._wordenize.bind(this);\n\n\t\tlet lineNumber = 0;\n\t\tlet lineText = '';\n\t\tlet wordRangesIdx = 0;\n\t\tlet wordRanges: IWordRange[] = [];\n\n\t\treturn {\n\t\t\t*[Symbol.iterator]() {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (wordRangesIdx < wordRanges.length) {\n\t\t\t\t\t\tconst value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n\t\t\t\t\t\twordRangesIdx += 1;\n\t\t\t\t\t\tyield value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (lineNumber < lines.length) {\n\t\t\t\t\t\t\tlineText = lines[lineNumber];\n\t\t\t\t\t\t\twordRanges = wordenize(lineText, wordDefinition);\n\t\t\t\t\t\t\twordRangesIdx = 0;\n\t\t\t\t\t\t\tlineNumber += 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic getLineWords(lineNumber: number, wordDefinition: RegExp): IWordAtPosition[] {\n\t\tconst content = this._lines[lineNumber - 1];\n\t\tconst ranges = this._wordenize(content, wordDefinition);\n\t\tconst words: IWordAtPosition[] = [];\n\t\tfor (const range of ranges) {\n\t\t\twords.push({\n\t\t\t\tword: content.substring(range.start, range.end),\n\t\t\t\tstartColumn: range.start + 1,\n\t\t\t\tendColumn: range.end + 1\n\t\t\t});\n\t\t}\n\t\treturn words;\n\t}\n\n\tprivate _wordenize(content: string, wordDefinition: RegExp): IWordRange[] {\n\t\tconst result: IWordRange[] = [];\n\t\tlet match: RegExpExecArray | null;\n\n\t\twordDefinition.lastIndex = 0; // reset lastIndex just to be sure\n\n\t\twhile (match = wordDefinition.exec(content)) {\n\t\t\tif (match[0].length === 0) {\n\t\t\t\t// it did match the empty string\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.push({ start: match.index, end: match.index + match[0].length });\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic getValueInRange(range: IRange): string {\n\t\trange = this._validateRange(range);\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n\t\t}\n\n\t\tconst lineEnding = this._eol;\n\t\tconst startLineIndex = range.startLineNumber - 1;\n\t\tconst endLineIndex = range.endLineNumber - 1;\n\t\tconst resultLines: string[] = [];\n\n\t\tresultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n\t\tfor (let i = startLineIndex + 1; i < endLineIndex; i++) {\n\t\t\tresultLines.push(this._lines[i]);\n\t\t}\n\t\tresultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n\n\t\treturn resultLines.join(lineEnding);\n\t}\n\n\tpublic offsetAt(position: IPosition): number {\n\t\tposition = this._validatePosition(position);\n\t\tthis._ensureLineStarts();\n\t\treturn this._lineStarts!.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\n\t}\n\n\tpublic positionAt(offset: number): IPosition {\n\t\toffset = Math.floor(offset);\n\t\toffset = Math.max(0, offset);\n\n\t\tthis._ensureLineStarts();\n\t\tconst out = this._lineStarts!.getIndexOf(offset);\n\t\tconst lineLength = this._lines[out.index].length;\n\n\t\t// Ensure we return a valid position\n\t\treturn {\n\t\t\tlineNumber: 1 + out.index,\n\t\t\tcolumn: 1 + Math.min(out.remainder, lineLength)\n\t\t};\n\t}\n\n\tprivate _validateRange(range: IRange): IRange {\n\n\t\tconst start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\n\t\tconst end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\n\n\t\tif (start.lineNumber !== range.startLineNumber\n\t\t\t|| start.column !== range.startColumn\n\t\t\t|| end.lineNumber !== range.endLineNumber\n\t\t\t|| end.column !== range.endColumn) {\n\n\t\t\treturn {\n\t\t\t\tstartLineNumber: start.lineNumber,\n\t\t\t\tstartColumn: start.column,\n\t\t\t\tendLineNumber: end.lineNumber,\n\t\t\t\tendColumn: end.column\n\t\t\t};\n\t\t}\n\n\t\treturn range;\n\t}\n\n\tprivate _validatePosition(position: IPosition): IPosition {\n\t\tif (!Position.isIPosition(position)) {\n\t\t\tthrow new Error('bad position');\n\t\t}\n\t\tlet { lineNumber, column } = position;\n\t\tlet hasChanged = false;\n\n\t\tif (lineNumber < 1) {\n\t\t\tlineNumber = 1;\n\t\t\tcolumn = 1;\n\t\t\thasChanged = true;\n\n\t\t} else if (lineNumber > this._lines.length) {\n\t\t\tlineNumber = this._lines.length;\n\t\t\tcolumn = this._lines[lineNumber - 1].length + 1;\n\t\t\thasChanged = true;\n\n\t\t} else {\n\t\t\tconst maxCharacter = this._lines[lineNumber - 1].length + 1;\n\t\t\tif (column < 1) {\n\t\t\t\tcolumn = 1;\n\t\t\t\thasChanged = true;\n\t\t\t}\n\t\t\telse if (column > maxCharacter) {\n\t\t\t\tcolumn = maxCharacter;\n\t\t\t\thasChanged = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!hasChanged) {\n\t\t\treturn position;\n\t\t} else {\n\t\t\treturn { lineNumber, column };\n\t\t}\n\t}\n}\n\n/**\n * @internal\n */\nexport interface IForeignModuleFactory {\n\t(ctx: IWorkerContext, createData: any): any;\n}\n\ndeclare const require: any;\n\n/**\n * @internal\n */\nexport class EditorSimpleWorker implements IRequestHandler, IDisposable {\n\t_requestHandlerBrand: any;\n\n\tprotected readonly _host: IEditorWorkerHost;\n\tprivate _models: { [uri: string]: MirrorModel };\n\tprivate readonly _foreignModuleFactory: IForeignModuleFactory | null;\n\tprivate _foreignModule: any;\n\n\tconstructor(host: IEditorWorkerHost, foreignModuleFactory: IForeignModuleFactory | null) {\n\t\tthis._host = host;\n\t\tthis._models = Object.create(null);\n\t\tthis._foreignModuleFactory = foreignModuleFactory;\n\t\tthis._foreignModule = null;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._models = Object.create(null);\n\t}\n\n\tprotected _getModel(uri: string): ICommonModel {\n\t\treturn this._models[uri];\n\t}\n\n\tprivate _getModels(): ICommonModel[] {\n\t\tconst all: MirrorModel[] = [];\n\t\tObject.keys(this._models).forEach((key) => all.push(this._models[key]));\n\t\treturn all;\n\t}\n\n\tpublic acceptNewModel(data: IRawModelData): void {\n\t\tthis._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\n\t}\n\n\tpublic acceptModelChanged(strURL: string, e: IModelChangedEvent): void {\n\t\tif (!this._models[strURL]) {\n\t\t\treturn;\n\t\t}\n\t\tconst model = this._models[strURL];\n\t\tmodel.onEvents(e);\n\t}\n\n\tpublic acceptRemovedModel(strURL: string): void {\n\t\tif (!this._models[strURL]) {\n\t\t\treturn;\n\t\t}\n\t\tdelete this._models[strURL];\n\t}\n\n\tpublic async computeUnicodeHighlights(url: string, options: UnicodeHighlighterOptions, range?: IRange): Promise<IUnicodeHighlightsResult> {\n\t\tconst model = this._getModel(url);\n\t\tif (!model) {\n\t\t\treturn { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };\n\t\t}\n\t\treturn UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);\n\t}\n\n\t// ---- BEGIN diff --------------------------------------------------------------------------\n\n\tpublic async computeDiff(originalUrl: string, modifiedUrl: string, options: IDocumentDiffProviderOptions, algorithm: DiffAlgorithmName): Promise<IDiffComputationResult | null> {\n\t\tconst original = this._getModel(originalUrl);\n\t\tconst modified = this._getModel(modifiedUrl);\n\t\tif (!original || !modified) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst result = EditorSimpleWorker.computeDiff(original, modified, options, algorithm);\n\t\treturn result;\n\t}\n\n\tprivate static computeDiff(originalTextModel: ICommonModel | ITextModel, modifiedTextModel: ICommonModel | ITextModel, options: IDocumentDiffProviderOptions, algorithm: DiffAlgorithmName): IDiffComputationResult {\n\t\tconst diffAlgorithm: ILinesDiffComputer = algorithm === 'advanced' ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();\n\n\t\tconst originalLines = originalTextModel.getLinesContent();\n\t\tconst modifiedLines = modifiedTextModel.getLinesContent();\n\n\t\tconst result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);\n\n\t\tconst identical = (result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel));\n\n\t\tfunction getLineChanges(changes: readonly DetailedLineRangeMapping[]): ILineChange[] {\n\t\t\treturn changes.map(m => ([m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, m.innerChanges?.map(m => [\n\t\t\t\tm.originalRange.startLineNumber,\n\t\t\t\tm.originalRange.startColumn,\n\t\t\t\tm.originalRange.endLineNumber,\n\t\t\t\tm.originalRange.endColumn,\n\t\t\t\tm.modifiedRange.startLineNumber,\n\t\t\t\tm.modifiedRange.startColumn,\n\t\t\t\tm.modifiedRange.endLineNumber,\n\t\t\t\tm.modifiedRange.endColumn,\n\t\t\t])]));\n\t\t}\n\n\t\treturn {\n\t\t\tidentical,\n\t\t\tquitEarly: result.hitTimeout,\n\t\t\tchanges: getLineChanges(result.changes),\n\t\t\tmoves: result.moves.map(m => ([\n\t\t\t\tm.lineRangeMapping.original.startLineNumber,\n\t\t\t\tm.lineRangeMapping.original.endLineNumberExclusive,\n\t\t\t\tm.lineRangeMapping.modified.startLineNumber,\n\t\t\t\tm.lineRangeMapping.modified.endLineNumberExclusive,\n\t\t\t\tgetLineChanges(m.changes)\n\t\t\t])),\n\t\t};\n\t}\n\n\tprivate static _modelsAreIdentical(original: ICommonModel | ITextModel, modified: ICommonModel | ITextModel): boolean {\n\t\tconst originalLineCount = original.getLineCount();\n\t\tconst modifiedLineCount = modified.getLineCount();\n\t\tif (originalLineCount !== modifiedLineCount) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let line = 1; line <= originalLineCount; line++) {\n\t\t\tconst originalLine = original.getLineContent(line);\n\t\t\tconst modifiedLine = modified.getLineContent(line);\n\t\t\tif (originalLine !== modifiedLine) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic async computeDirtyDiff(originalUrl: string, modifiedUrl: string, ignoreTrimWhitespace: boolean): Promise<IChange[] | null> {\n\t\tconst original = this._getModel(originalUrl);\n\t\tconst modified = this._getModel(modifiedUrl);\n\t\tif (!original || !modified) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst originalLines = original.getLinesContent();\n\t\tconst modifiedLines = modified.getLinesContent();\n\t\tconst diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\tshouldComputeCharChanges: false,\n\t\t\tshouldPostProcessCharChanges: false,\n\t\t\tshouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n\t\t\tshouldMakePrettyDiff: true,\n\t\t\tmaxComputationTime: 1000\n\t\t});\n\t\treturn diffComputer.computeDiff().changes;\n\t}\n\n\t// ---- END diff --------------------------------------------------------------------------\n\n\n\t// ---- BEGIN minimal edits ---------------------------------------------------------------\n\n\tprivate static readonly _diffLimit = 100000;\n\n\tpublic async computeMoreMinimalEdits(modelUrl: string, edits: TextEdit[], pretty: boolean): Promise<TextEdit[]> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst result: TextEdit[] = [];\n\t\tlet lastEol: EndOfLineSequence | undefined = undefined;\n\n\t\tedits = edits.slice(0).sort((a, b) => {\n\t\t\tif (a.range && b.range) {\n\t\t\t\treturn Range.compareRangesUsingStarts(a.range, b.range);\n\t\t\t}\n\t\t\t// eol only changes should go to the end\n\t\t\tconst aRng = a.range ? 0 : 1;\n\t\t\tconst bRng = b.range ? 0 : 1;\n\t\t\treturn aRng - bRng;\n\t\t});\n\n\t\t// merge adjacent edits\n\t\tlet writeIndex = 0;\n\t\tfor (let readIndex = 1; readIndex < edits.length; readIndex++) {\n\t\t\tif (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {\n\t\t\t\tedits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));\n\t\t\t\tedits[writeIndex].text += edits[readIndex].text;\n\t\t\t} else {\n\t\t\t\twriteIndex++;\n\t\t\t\tedits[writeIndex] = edits[readIndex];\n\t\t\t}\n\t\t}\n\t\tedits.length = writeIndex + 1;\n\n\t\tfor (let { range, text, eol } of edits) {\n\n\t\t\tif (typeof eol === 'number') {\n\t\t\t\tlastEol = eol;\n\t\t\t}\n\n\t\t\tif (Range.isEmpty(range) && !text) {\n\t\t\t\t// empty change\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst original = model.getValueInRange(range);\n\t\t\ttext = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n\n\t\t\tif (original === text) {\n\t\t\t\t// noop\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// make sure diff won't take too long\n\t\t\tif (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n\t\t\t\tresult.push({ range, text });\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// compute diff between original and edit.text\n\t\t\tconst changes = stringDiff(original, text, pretty);\n\t\t\tconst editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n\n\t\t\tfor (const change of changes) {\n\t\t\t\tconst start = model.positionAt(editOffset + change.originalStart);\n\t\t\t\tconst end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n\t\t\t\tconst newEdit: TextEdit = {\n\t\t\t\t\ttext: text.substr(change.modifiedStart, change.modifiedLength),\n\t\t\t\t\trange: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\n\t\t\t\t};\n\n\t\t\t\tif (model.getValueInRange(newEdit.range) !== newEdit.text) {\n\t\t\t\t\tresult.push(newEdit);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (typeof lastEol === 'number') {\n\t\t\tresult.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic computeHumanReadableDiff(modelUrl: string, edits: TextEdit[], options: ILinesDiffComputerOptions): TextEdit[] {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst result: TextEdit[] = [];\n\t\tlet lastEol: EndOfLineSequence | undefined = undefined;\n\n\t\tedits = edits.slice(0).sort((a, b) => {\n\t\t\tif (a.range && b.range) {\n\t\t\t\treturn Range.compareRangesUsingStarts(a.range, b.range);\n\t\t\t}\n\t\t\t// eol only changes should go to the end\n\t\t\tconst aRng = a.range ? 0 : 1;\n\t\t\tconst bRng = b.range ? 0 : 1;\n\t\t\treturn aRng - bRng;\n\t\t});\n\n\t\tfor (let { range, text, eol } of edits) {\n\n\t\t\tif (typeof eol === 'number') {\n\t\t\t\tlastEol = eol;\n\t\t\t}\n\n\t\t\tif (Range.isEmpty(range) && !text) {\n\t\t\t\t// empty change\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst original = model.getValueInRange(range);\n\t\t\ttext = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n\n\t\t\tif (original === text) {\n\t\t\t\t// noop\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// make sure diff won't take too long\n\t\t\tif (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n\t\t\t\tresult.push({ range, text });\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// compute diff between original and edit.text\n\n\t\t\tconst originalLines = original.split(/\\r\\n|\\n|\\r/);\n\t\t\tconst modifiedLines = text.split(/\\r\\n|\\n|\\r/);\n\n\t\t\tconst diff = linesDiffComputers.getDefault().computeDiff(originalLines, modifiedLines, options);\n\n\t\t\tconst start = Range.lift(range).getStartPosition();\n\n\t\t\tfunction addPositions(pos1: Position, pos2: Position): Position {\n\t\t\t\treturn new Position(pos1.lineNumber + pos2.lineNumber - 1, pos2.lineNumber === 1 ? pos1.column + pos2.column - 1 : pos2.column);\n\t\t\t}\n\n\t\t\tfunction getText(lines: string[], range: Range): string[] {\n\t\t\t\tconst result: string[] = [];\n\t\t\t\tfor (let i = range.startLineNumber; i <= range.endLineNumber; i++) {\n\t\t\t\t\tconst line = lines[i - 1];\n\t\t\t\t\tif (i === range.startLineNumber && i === range.endLineNumber) {\n\t\t\t\t\t\tresult.push(line.substring(range.startColumn - 1, range.endColumn - 1));\n\t\t\t\t\t} else if (i === range.startLineNumber) {\n\t\t\t\t\t\tresult.push(line.substring(range.startColumn - 1));\n\t\t\t\t\t} else if (i === range.endLineNumber) {\n\t\t\t\t\t\tresult.push(line.substring(0, range.endColumn - 1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.push(line);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tfor (const c of diff.changes) {\n\t\t\t\tif (c.innerChanges) {\n\t\t\t\t\tfor (const x of c.innerChanges) {\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\trange: Range.fromPositions(\n\t\t\t\t\t\t\t\taddPositions(start, x.originalRange.getStartPosition()),\n\t\t\t\t\t\t\t\taddPositions(start, x.originalRange.getEndPosition())\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\ttext: getText(modifiedLines, x.modifiedRange).join(model.eol)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new BugIndicatingError('The experimental diff algorithm always produces inner changes');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (typeof lastEol === 'number') {\n\t\t\tresult.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// ---- END minimal edits ---------------------------------------------------------------\n\n\tpublic async computeLinks(modelUrl: string): Promise<ILink[] | null> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn computeLinks(model);\n\t}\n\n\t// --- BEGIN default document colors -----------------------------------------------------------\n\n\tpublic async computeDefaultDocumentColors(modelUrl: string): Promise<IColorInformation[] | null> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\t\treturn computeDefaultDocumentColors(model);\n\t}\n\n\t// ---- BEGIN suggest --------------------------------------------------------------------------\n\n\tprivate static readonly _suggestionsLimit = 10000;\n\n\tpublic async textualSuggest(modelUrls: string[], leadingWord: string | undefined, wordDef: string, wordDefFlags: string): Promise<{ words: string[]; duration: number } | null> {\n\n\t\tconst sw = new StopWatch();\n\t\tconst wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n\t\tconst seen = new Set<string>();\n\n\t\touter: for (const url of modelUrls) {\n\t\t\tconst model = this._getModel(url);\n\t\t\tif (!model) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (const word of model.words(wordDefRegExp)) {\n\t\t\t\tif (word === leadingWord || !isNaN(Number(word))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tseen.add(word);\n\t\t\t\tif (seen.size > EditorSimpleWorker._suggestionsLimit) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { words: Array.from(seen), duration: sw.elapsed() };\n\t}\n\n\n\t// ---- END suggest --------------------------------------------------------------------------\n\n\t//#region -- word ranges --\n\n\tpublic async computeWordRanges(modelUrl: string, range: IRange, wordDef: string, wordDefFlags: string): Promise<{ [word: string]: IRange[] }> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn Object.create(null);\n\t\t}\n\t\tconst wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n\t\tconst result: { [word: string]: IRange[] } = Object.create(null);\n\t\tfor (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n\t\t\tconst words = model.getLineWords(line, wordDefRegExp);\n\t\t\tfor (const word of words) {\n\t\t\t\tif (!isNaN(Number(word.word))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlet array = result[word.word];\n\t\t\t\tif (!array) {\n\t\t\t\t\tarray = [];\n\t\t\t\t\tresult[word.word] = array;\n\t\t\t\t}\n\t\t\t\tarray.push({\n\t\t\t\t\tstartLineNumber: line,\n\t\t\t\t\tstartColumn: word.startColumn,\n\t\t\t\t\tendLineNumber: line,\n\t\t\t\t\tendColumn: word.endColumn\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t//#endregion\n\n\tpublic async navigateValueSet(modelUrl: string, range: IRange, up: boolean, wordDef: string, wordDefFlags: string): Promise<IInplaceReplaceSupportResult | null> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n\n\t\tif (range.startColumn === range.endColumn) {\n\t\t\trange = {\n\t\t\t\tstartLineNumber: range.startLineNumber,\n\t\t\t\tstartColumn: range.startColumn,\n\t\t\t\tendLineNumber: range.endLineNumber,\n\t\t\t\tendColumn: range.endColumn + 1\n\t\t\t};\n\t\t}\n\n\t\tconst selectionText = model.getValueInRange(range);\n\n\t\tconst wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n\t\tif (!wordRange) {\n\t\t\treturn null;\n\t\t}\n\t\tconst word = model.getValueInRange(wordRange);\n\t\tconst result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n\t\treturn result;\n\t}\n\n\t// ---- BEGIN foreign module support --------------------------------------------------------------------------\n\n\tpublic loadForeignModule(moduleId: string, createData: any, foreignHostMethods: string[]): Promise<string[]> {\n\t\tconst proxyMethodRequest = (method: string, args: any[]): Promise<any> => {\n\t\t\treturn this._host.fhr(method, args);\n\t\t};\n\n\t\tconst foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);\n\n\t\tconst ctx: IWorkerContext<any> = {\n\t\t\thost: foreignHost,\n\t\t\tgetMirrorModels: (): IMirrorModel[] => {\n\t\t\t\treturn this._getModels();\n\t\t\t}\n\t\t};\n\n\t\tif (this._foreignModuleFactory) {\n\t\t\tthis._foreignModule = this._foreignModuleFactory(ctx, createData);\n\t\t\t// static foreing module\n\t\t\treturn Promise.resolve(getAllMethodNames(this._foreignModule));\n\t\t}\n\t\t// -ESM-comment-begin\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\trequire([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {\n\t\t\t\tthis._foreignModule = foreignModule.create(ctx, createData);\n\n\t\t\t\tresolve(getAllMethodNames(this._foreignModule));\n\n\t\t\t}, reject);\n\t\t});\n\t\t// -ESM-comment-end\n\n\t\t// -ESM-uncomment-begin\n\t\t// return Promise.reject(new Error(`Unexpected usage`));\n\t\t// -ESM-uncomment-end\n\t}\n\n\t// foreign method request\n\tpublic fmr(method: string, args: any[]): Promise<any> {\n\t\tif (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error('Missing requestHandler or method: ' + method));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\t// ---- END foreign module support --------------------------------------------------------------------------\n}\n\n/**\n * Called on the worker side\n * @internal\n */\nexport function create(host: IEditorWorkerHost): IRequestHandler {\n\treturn new EditorSimpleWorker(host, null);\n}\n\n// This is only available in a Web Worker\ndeclare function importScripts(...urls: string[]): void;\n\nif (typeof importScripts === 'function') {\n\t// Running in a web worker\n\tglobalThis.monaco = createMonacoBaseAPI();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { stringDiff } from '../../../base/common/diff/diff';\nimport { IDisposable } from '../../../base/common/lifecycle';\nimport { URI } from '../../../base/common/uri';\nimport { IRequestHandler } from '../../../base/common/worker/simpleWorker';\nimport { IPosition, Position } from '../core/position';\nimport { IRange, Range } from '../core/range';\nimport { EndOfLineSequence, ITextModel } from '../model';\nimport { IMirrorTextModel, IModelChangedEvent, MirrorTextModel as BaseMirrorModel } from '../model/mirrorTextModel';\nimport { ensureValidWordDefinition, getWordAtText, IWordAtPosition } from '../core/wordHelper';\nimport { IColorInformation, IInplaceReplaceSupportResult, ILink, TextEdit } from '../languages';\nimport { ILinkComputerTarget, computeLinks } from '../languages/linkComputer';\nimport { BasicInplaceReplace } from '../languages/supports/inplaceReplaceSupport';\nimport { DiffAlgorithmName, IDiffComputationResult, ILineChange, IUnicodeHighlightsResult } from './editorWorker';\nimport { createMonacoBaseAPI } from './editorBaseApi';\nimport { IEditorWorkerHost } from './editorWorkerHost';\nimport { StopWatch } from '../../../base/common/stopwatch';\nimport { UnicodeTextModelHighlighter, UnicodeHighlighterOptions } from './unicodeTextModelHighlighter';\nimport { DiffComputer, IChange } from '../diff/legacyLinesDiffComputer';\nimport { ILinesDiffComputer, ILinesDiffComputerOptions } from '../diff/linesDiffComputer';\nimport { DetailedLineRangeMapping } from '../diff/rangeMapping';\nimport { linesDiffComputers } from '../diff/linesDiffComputers';\nimport { createProxyObject, getAllMethodNames } from '../../../base/common/objects';\nimport { IDocumentDiffProviderOptions } from '../diff/documentDiffProvider';\nimport { BugIndicatingError } from '../../../base/common/errors';\nimport { IDocumentColorComputerTarget, computeDefaultDocumentColors } from '../languages/defaultDocumentColorsComputer';\n\nexport interface IMirrorModel extends IMirrorTextModel {\n\treadonly uri: URI;\n\treadonly version: number;\n\tgetValue(): string;\n}\n\nexport interface IWorkerContext<H = undefined> {\n\t/**\n\t * A proxy to the main thread host object.\n\t */\n\thost: H;\n\t/**\n\t * Get all available mirror models in this worker.\n\t */\n\tgetMirrorModels(): IMirrorModel[];\n}\n\n/**\n * @internal\n */\nexport interface IRawModelData {\n\turl: string;\n\tversionId: number;\n\tlines: string[];\n\tEOL: string;\n}\n\n/**\n * @internal\n */\nexport interface ICommonModel extends ILinkComputerTarget, IDocumentColorComputerTarget, IMirrorModel {\n\turi: URI;\n\tversion: number;\n\teol: string;\n\tgetValue(): string;\n\n\tgetLinesContent(): string[];\n\tgetLineCount(): number;\n\tgetLineContent(lineNumber: number): string;\n\tgetLineWords(lineNumber: number, wordDefinition: RegExp): IWordAtPosition[];\n\twords(wordDefinition: RegExp): Iterable<string>;\n\tgetWordUntilPosition(position: IPosition, wordDefinition: RegExp): IWordAtPosition;\n\tgetValueInRange(range: IRange): string;\n\tgetWordAtPosition(position: IPosition, wordDefinition: RegExp): Range | null;\n\toffsetAt(position: IPosition): number;\n\tpositionAt(offset: number): IPosition;\n\tfindMatches(regex: RegExp): RegExpMatchArray[];\n}\n\n/**\n * Range of a word inside a model.\n * @internal\n */\ninterface IWordRange {\n\t/**\n\t * The index where the word starts.\n\t */\n\treadonly start: number;\n\t/**\n\t * The index where the word ends.\n\t */\n\treadonly end: number;\n}\n\n/**\n * @internal\n */\nclass MirrorModel extends BaseMirrorModel implements ICommonModel {\n\n\tpublic get uri(): URI {\n\t\treturn this._uri;\n\t}\n\n\tpublic get eol(): string {\n\t\treturn this._eol;\n\t}\n\n\tpublic getValue(): string {\n\t\treturn this.getText();\n\t}\n\n\tpublic findMatches(regex: RegExp): RegExpMatchArray[] {\n\t\tconst matches = [];\n\t\tfor (let i = 0; i < this._lines.length; i++) {\n\t\t\tconst line = this._lines[i];\n\t\t\tconst offsetToAdd = this.offsetAt(new Position(i + 1, 1));\n\t\t\tconst iteratorOverMatches = line.matchAll(regex);\n\t\t\tfor (const match of iteratorOverMatches) {\n\t\t\t\tif (match.index || match.index === 0) {\n\t\t\t\t\tmatch.index = match.index + offsetToAdd;\n\t\t\t\t}\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t}\n\t\treturn matches;\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\treturn this._lines.slice(0);\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._lines.length;\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\treturn this._lines[lineNumber - 1];\n\t}\n\n\tpublic getWordAtPosition(position: IPosition, wordDefinition: RegExp): Range | null {\n\n\t\tconst wordAtText = getWordAtText(\n\t\t\tposition.column,\n\t\t\tensureValidWordDefinition(wordDefinition),\n\t\t\tthis._lines[position.lineNumber - 1],\n\t\t\t0\n\t\t);\n\n\t\tif (wordAtText) {\n\t\t\treturn new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic getWordUntilPosition(position: IPosition, wordDefinition: RegExp): IWordAtPosition {\n\t\tconst wordAtPosition = this.getWordAtPosition(position, wordDefinition);\n\t\tif (!wordAtPosition) {\n\t\t\treturn {\n\t\t\t\tword: '',\n\t\t\t\tstartColumn: position.column,\n\t\t\t\tendColumn: position.column\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tword: this._lines[position.lineNumber - 1].substring(wordAtPosition.startColumn - 1, position.column - 1),\n\t\t\tstartColumn: wordAtPosition.startColumn,\n\t\t\tendColumn: position.column\n\t\t};\n\t}\n\n\n\tpublic words(wordDefinition: RegExp): Iterable<string> {\n\n\t\tconst lines = this._lines;\n\t\tconst wordenize = this._wordenize.bind(this);\n\n\t\tlet lineNumber = 0;\n\t\tlet lineText = '';\n\t\tlet wordRangesIdx = 0;\n\t\tlet wordRanges: IWordRange[] = [];\n\n\t\treturn {\n\t\t\t*[Symbol.iterator]() {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (wordRangesIdx < wordRanges.length) {\n\t\t\t\t\t\tconst value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n\t\t\t\t\t\twordRangesIdx += 1;\n\t\t\t\t\t\tyield value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (lineNumber < lines.length) {\n\t\t\t\t\t\t\tlineText = lines[lineNumber];\n\t\t\t\t\t\t\twordRanges = wordenize(lineText, wordDefinition);\n\t\t\t\t\t\t\twordRangesIdx = 0;\n\t\t\t\t\t\t\tlineNumber += 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic getLineWords(lineNumber: number, wordDefinition: RegExp): IWordAtPosition[] {\n\t\tconst content = this._lines[lineNumber - 1];\n\t\tconst ranges = this._wordenize(content, wordDefinition);\n\t\tconst words: IWordAtPosition[] = [];\n\t\tfor (const range of ranges) {\n\t\t\twords.push({\n\t\t\t\tword: content.substring(range.start, range.end),\n\t\t\t\tstartColumn: range.start + 1,\n\t\t\t\tendColumn: range.end + 1\n\t\t\t});\n\t\t}\n\t\treturn words;\n\t}\n\n\tprivate _wordenize(content: string, wordDefinition: RegExp): IWordRange[] {\n\t\tconst result: IWordRange[] = [];\n\t\tlet match: RegExpExecArray | null;\n\n\t\twordDefinition.lastIndex = 0; // reset lastIndex just to be sure\n\n\t\twhile (match = wordDefinition.exec(content)) {\n\t\t\tif (match[0].length === 0) {\n\t\t\t\t// it did match the empty string\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.push({ start: match.index, end: match.index + match[0].length });\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic getValueInRange(range: IRange): string {\n\t\trange = this._validateRange(range);\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n\t\t}\n\n\t\tconst lineEnding = this._eol;\n\t\tconst startLineIndex = range.startLineNumber - 1;\n\t\tconst endLineIndex = range.endLineNumber - 1;\n\t\tconst resultLines: string[] = [];\n\n\t\tresultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n\t\tfor (let i = startLineIndex + 1; i < endLineIndex; i++) {\n\t\t\tresultLines.push(this._lines[i]);\n\t\t}\n\t\tresultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n\n\t\treturn resultLines.join(lineEnding);\n\t}\n\n\tpublic offsetAt(position: IPosition): number {\n\t\tposition = this._validatePosition(position);\n\t\tthis._ensureLineStarts();\n\t\treturn this._lineStarts!.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\n\t}\n\n\tpublic positionAt(offset: number): IPosition {\n\t\toffset = Math.floor(offset);\n\t\toffset = Math.max(0, offset);\n\n\t\tthis._ensureLineStarts();\n\t\tconst out = this._lineStarts!.getIndexOf(offset);\n\t\tconst lineLength = this._lines[out.index].length;\n\n\t\t// Ensure we return a valid position\n\t\treturn {\n\t\t\tlineNumber: 1 + out.index,\n\t\t\tcolumn: 1 + Math.min(out.remainder, lineLength)\n\t\t};\n\t}\n\n\tprivate _validateRange(range: IRange): IRange {\n\n\t\tconst start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\n\t\tconst end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\n\n\t\tif (start.lineNumber !== range.startLineNumber\n\t\t\t|| start.column !== range.startColumn\n\t\t\t|| end.lineNumber !== range.endLineNumber\n\t\t\t|| end.column !== range.endColumn) {\n\n\t\t\treturn {\n\t\t\t\tstartLineNumber: start.lineNumber,\n\t\t\t\tstartColumn: start.column,\n\t\t\t\tendLineNumber: end.lineNumber,\n\t\t\t\tendColumn: end.column\n\t\t\t};\n\t\t}\n\n\t\treturn range;\n\t}\n\n\tprivate _validatePosition(position: IPosition): IPosition {\n\t\tif (!Position.isIPosition(position)) {\n\t\t\tthrow new Error('bad position');\n\t\t}\n\t\tlet { lineNumber, column } = position;\n\t\tlet hasChanged = false;\n\n\t\tif (lineNumber < 1) {\n\t\t\tlineNumber = 1;\n\t\t\tcolumn = 1;\n\t\t\thasChanged = true;\n\n\t\t} else if (lineNumber > this._lines.length) {\n\t\t\tlineNumber = this._lines.length;\n\t\t\tcolumn = this._lines[lineNumber - 1].length + 1;\n\t\t\thasChanged = true;\n\n\t\t} else {\n\t\t\tconst maxCharacter = this._lines[lineNumber - 1].length + 1;\n\t\t\tif (column < 1) {\n\t\t\t\tcolumn = 1;\n\t\t\t\thasChanged = true;\n\t\t\t}\n\t\t\telse if (column > maxCharacter) {\n\t\t\t\tcolumn = maxCharacter;\n\t\t\t\thasChanged = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!hasChanged) {\n\t\t\treturn position;\n\t\t} else {\n\t\t\treturn { lineNumber, column };\n\t\t}\n\t}\n}\n\n/**\n * @internal\n */\nexport interface IForeignModuleFactory {\n\t(ctx: IWorkerContext, createData: any): any;\n}\n\ndeclare const require: any;\n\n/**\n * @internal\n */\nexport class EditorSimpleWorker implements IRequestHandler, IDisposable {\n\t_requestHandlerBrand: any;\n\n\tprotected readonly _host: IEditorWorkerHost;\n\tprivate _models: { [uri: string]: MirrorModel };\n\tprivate readonly _foreignModuleFactory: IForeignModuleFactory | null;\n\tprivate _foreignModule: any;\n\n\tconstructor(host: IEditorWorkerHost, foreignModuleFactory: IForeignModuleFactory | null) {\n\t\tthis._host = host;\n\t\tthis._models = Object.create(null);\n\t\tthis._foreignModuleFactory = foreignModuleFactory;\n\t\tthis._foreignModule = null;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._models = Object.create(null);\n\t}\n\n\tprotected _getModel(uri: string): ICommonModel {\n\t\treturn this._models[uri];\n\t}\n\n\tprivate _getModels(): ICommonModel[] {\n\t\tconst all: MirrorModel[] = [];\n\t\tObject.keys(this._models).forEach((key) => all.push(this._models[key]));\n\t\treturn all;\n\t}\n\n\tpublic acceptNewModel(data: IRawModelData): void {\n\t\tthis._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\n\t}\n\n\tpublic acceptModelChanged(strURL: string, e: IModelChangedEvent): void {\n\t\tif (!this._models[strURL]) {\n\t\t\treturn;\n\t\t}\n\t\tconst model = this._models[strURL];\n\t\tmodel.onEvents(e);\n\t}\n\n\tpublic acceptRemovedModel(strURL: string): void {\n\t\tif (!this._models[strURL]) {\n\t\t\treturn;\n\t\t}\n\t\tdelete this._models[strURL];\n\t}\n\n\tpublic async computeUnicodeHighlights(url: string, options: UnicodeHighlighterOptions, range?: IRange): Promise<IUnicodeHighlightsResult> {\n\t\tconst model = this._getModel(url);\n\t\tif (!model) {\n\t\t\treturn { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };\n\t\t}\n\t\treturn UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);\n\t}\n\n\t// ---- BEGIN diff --------------------------------------------------------------------------\n\n\tpublic async computeDiff(originalUrl: string, modifiedUrl: string, options: IDocumentDiffProviderOptions, algorithm: DiffAlgorithmName): Promise<IDiffComputationResult | null> {\n\t\tconst original = this._getModel(originalUrl);\n\t\tconst modified = this._getModel(modifiedUrl);\n\t\tif (!original || !modified) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst result = EditorSimpleWorker.computeDiff(original, modified, options, algorithm);\n\t\treturn result;\n\t}\n\n\tprivate static computeDiff(originalTextModel: ICommonModel | ITextModel, modifiedTextModel: ICommonModel | ITextModel, options: IDocumentDiffProviderOptions, algorithm: DiffAlgorithmName): IDiffComputationResult {\n\t\tconst diffAlgorithm: ILinesDiffComputer = algorithm === 'advanced' ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();\n\n\t\tconst originalLines = originalTextModel.getLinesContent();\n\t\tconst modifiedLines = modifiedTextModel.getLinesContent();\n\n\t\tconst result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);\n\n\t\tconst identical = (result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel));\n\n\t\tfunction getLineChanges(changes: readonly DetailedLineRangeMapping[]): ILineChange[] {\n\t\t\treturn changes.map(m => ([m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, m.innerChanges?.map(m => [\n\t\t\t\tm.originalRange.startLineNumber,\n\t\t\t\tm.originalRange.startColumn,\n\t\t\t\tm.originalRange.endLineNumber,\n\t\t\t\tm.originalRange.endColumn,\n\t\t\t\tm.modifiedRange.startLineNumber,\n\t\t\t\tm.modifiedRange.startColumn,\n\t\t\t\tm.modifiedRange.endLineNumber,\n\t\t\t\tm.modifiedRange.endColumn,\n\t\t\t])]));\n\t\t}\n\n\t\treturn {\n\t\t\tidentical,\n\t\t\tquitEarly: result.hitTimeout,\n\t\t\tchanges: getLineChanges(result.changes),\n\t\t\tmoves: result.moves.map(m => ([\n\t\t\t\tm.lineRangeMapping.original.startLineNumber,\n\t\t\t\tm.lineRangeMapping.original.endLineNumberExclusive,\n\t\t\t\tm.lineRangeMapping.modified.startLineNumber,\n\t\t\t\tm.lineRangeMapping.modified.endLineNumberExclusive,\n\t\t\t\tgetLineChanges(m.changes)\n\t\t\t])),\n\t\t};\n\t}\n\n\tprivate static _modelsAreIdentical(original: ICommonModel | ITextModel, modified: ICommonModel | ITextModel): boolean {\n\t\tconst originalLineCount = original.getLineCount();\n\t\tconst modifiedLineCount = modified.getLineCount();\n\t\tif (originalLineCount !== modifiedLineCount) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let line = 1; line <= originalLineCount; line++) {\n\t\t\tconst originalLine = original.getLineContent(line);\n\t\t\tconst modifiedLine = modified.getLineContent(line);\n\t\t\tif (originalLine !== modifiedLine) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic async computeDirtyDiff(originalUrl: string, modifiedUrl: string, ignoreTrimWhitespace: boolean): Promise<IChange[] | null> {\n\t\tconst original = this._getModel(originalUrl);\n\t\tconst modified = this._getModel(modifiedUrl);\n\t\tif (!original || !modified) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst originalLines = original.getLinesContent();\n\t\tconst modifiedLines = modified.getLinesContent();\n\t\tconst diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\tshouldComputeCharChanges: false,\n\t\t\tshouldPostProcessCharChanges: false,\n\t\t\tshouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n\t\t\tshouldMakePrettyDiff: true,\n\t\t\tmaxComputationTime: 1000\n\t\t});\n\t\treturn diffComputer.computeDiff().changes;\n\t}\n\n\t// ---- END diff --------------------------------------------------------------------------\n\n\n\t// ---- BEGIN minimal edits ---------------------------------------------------------------\n\n\tprivate static readonly _diffLimit = 100000;\n\n\tpublic async computeMoreMinimalEdits(modelUrl: string, edits: TextEdit[], pretty: boolean): Promise<TextEdit[]> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst result: TextEdit[] = [];\n\t\tlet lastEol: EndOfLineSequence | undefined = undefined;\n\n\t\tedits = edits.slice(0).sort((a, b) => {\n\t\t\tif (a.range && b.range) {\n\t\t\t\treturn Range.compareRangesUsingStarts(a.range, b.range);\n\t\t\t}\n\t\t\t// eol only changes should go to the end\n\t\t\tconst aRng = a.range ? 0 : 1;\n\t\t\tconst bRng = b.range ? 0 : 1;\n\t\t\treturn aRng - bRng;\n\t\t});\n\n\t\t// merge adjacent edits\n\t\tlet writeIndex = 0;\n\t\tfor (let readIndex = 1; readIndex < edits.length; readIndex++) {\n\t\t\tif (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {\n\t\t\t\tedits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));\n\t\t\t\tedits[writeIndex].text += edits[readIndex].text;\n\t\t\t} else {\n\t\t\t\twriteIndex++;\n\t\t\t\tedits[writeIndex] = edits[readIndex];\n\t\t\t}\n\t\t}\n\t\tedits.length = writeIndex + 1;\n\n\t\tfor (let { range, text, eol } of edits) {\n\n\t\t\tif (typeof eol === 'number') {\n\t\t\t\tlastEol = eol;\n\t\t\t}\n\n\t\t\tif (Range.isEmpty(range) && !text) {\n\t\t\t\t// empty change\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst original = model.getValueInRange(range);\n\t\t\ttext = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n\n\t\t\tif (original === text) {\n\t\t\t\t// noop\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// make sure diff won't take too long\n\t\t\tif (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n\t\t\t\tresult.push({ range, text });\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// compute diff between original and edit.text\n\t\t\tconst changes = stringDiff(original, text, pretty);\n\t\t\tconst editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n\n\t\t\tfor (const change of changes) {\n\t\t\t\tconst start = model.positionAt(editOffset + change.originalStart);\n\t\t\t\tconst end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n\t\t\t\tconst newEdit: TextEdit = {\n\t\t\t\t\ttext: text.substr(change.modifiedStart, change.modifiedLength),\n\t\t\t\t\trange: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\n\t\t\t\t};\n\n\t\t\t\tif (model.getValueInRange(newEdit.range) !== newEdit.text) {\n\t\t\t\t\tresult.push(newEdit);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (typeof lastEol === 'number') {\n\t\t\tresult.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic computeHumanReadableDiff(modelUrl: string, edits: TextEdit[], options: ILinesDiffComputerOptions): TextEdit[] {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst result: TextEdit[] = [];\n\t\tlet lastEol: EndOfLineSequence | undefined = undefined;\n\n\t\tedits = edits.slice(0).sort((a, b) => {\n\t\t\tif (a.range && b.range) {\n\t\t\t\treturn Range.compareRangesUsingStarts(a.range, b.range);\n\t\t\t}\n\t\t\t// eol only changes should go to the end\n\t\t\tconst aRng = a.range ? 0 : 1;\n\t\t\tconst bRng = b.range ? 0 : 1;\n\t\t\treturn aRng - bRng;\n\t\t});\n\n\t\tfor (let { range, text, eol } of edits) {\n\n\t\t\tif (typeof eol === 'number') {\n\t\t\t\tlastEol = eol;\n\t\t\t}\n\n\t\t\tif (Range.isEmpty(range) && !text) {\n\t\t\t\t// empty change\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst original = model.getValueInRange(range);\n\t\t\ttext = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n\n\t\t\tif (original === text) {\n\t\t\t\t// noop\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// make sure diff won't take too long\n\t\t\tif (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n\t\t\t\tresult.push({ range, text });\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// compute diff between original and edit.text\n\n\t\t\tconst originalLines = original.split(/\\r\\n|\\n|\\r/);\n\t\t\tconst modifiedLines = text.split(/\\r\\n|\\n|\\r/);\n\n\t\t\tconst diff = linesDiffComputers.getDefault().computeDiff(originalLines, modifiedLines, options);\n\n\t\t\tconst start = Range.lift(range).getStartPosition();\n\n\t\t\tfunction addPositions(pos1: Position, pos2: Position): Position {\n\t\t\t\treturn new Position(pos1.lineNumber + pos2.lineNumber - 1, pos2.lineNumber === 1 ? pos1.column + pos2.column - 1 : pos2.column);\n\t\t\t}\n\n\t\t\tfunction getText(lines: string[], range: Range): string[] {\n\t\t\t\tconst result: string[] = [];\n\t\t\t\tfor (let i = range.startLineNumber; i <= range.endLineNumber; i++) {\n\t\t\t\t\tconst line = lines[i - 1];\n\t\t\t\t\tif (i === range.startLineNumber && i === range.endLineNumber) {\n\t\t\t\t\t\tresult.push(line.substring(range.startColumn - 1, range.endColumn - 1));\n\t\t\t\t\t} else if (i === range.startLineNumber) {\n\t\t\t\t\t\tresult.push(line.substring(range.startColumn - 1));\n\t\t\t\t\t} else if (i === range.endLineNumber) {\n\t\t\t\t\t\tresult.push(line.substring(0, range.endColumn - 1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.push(line);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tfor (const c of diff.changes) {\n\t\t\t\tif (c.innerChanges) {\n\t\t\t\t\tfor (const x of c.innerChanges) {\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\trange: Range.fromPositions(\n\t\t\t\t\t\t\t\taddPositions(start, x.originalRange.getStartPosition()),\n\t\t\t\t\t\t\t\taddPositions(start, x.originalRange.getEndPosition())\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\ttext: getText(modifiedLines, x.modifiedRange).join(model.eol)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new BugIndicatingError('The experimental diff algorithm always produces inner changes');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (typeof lastEol === 'number') {\n\t\t\tresult.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// ---- END minimal edits ---------------------------------------------------------------\n\n\tpublic async computeLinks(modelUrl: string): Promise<ILink[] | null> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn computeLinks(model);\n\t}\n\n\t// --- BEGIN default document colors -----------------------------------------------------------\n\n\tpublic async computeDefaultDocumentColors(modelUrl: string): Promise<IColorInformation[] | null> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\t\treturn computeDefaultDocumentColors(model);\n\t}\n\n\t// ---- BEGIN suggest --------------------------------------------------------------------------\n\n\tprivate static readonly _suggestionsLimit = 10000;\n\n\tpublic async textualSuggest(modelUrls: string[], leadingWord: string | undefined, wordDef: string, wordDefFlags: string): Promise<{ words: string[]; duration: number } | null> {\n\n\t\tconst sw = new StopWatch();\n\t\tconst wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n\t\tconst seen = new Set<string>();\n\n\t\touter: for (const url of modelUrls) {\n\t\t\tconst model = this._getModel(url);\n\t\t\tif (!model) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (const word of model.words(wordDefRegExp)) {\n\t\t\t\tif (word === leadingWord || !isNaN(Number(word))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tseen.add(word);\n\t\t\t\tif (seen.size > EditorSimpleWorker._suggestionsLimit) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { words: Array.from(seen), duration: sw.elapsed() };\n\t}\n\n\n\t// ---- END suggest --------------------------------------------------------------------------\n\n\t//#region -- word ranges --\n\n\tpublic async computeWordRanges(modelUrl: string, range: IRange, wordDef: string, wordDefFlags: string): Promise<{ [word: string]: IRange[] }> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn Object.create(null);\n\t\t}\n\t\tconst wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n\t\tconst result: { [word: string]: IRange[] } = Object.create(null);\n\t\tfor (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n\t\t\tconst words = model.getLineWords(line, wordDefRegExp);\n\t\t\tfor (const word of words) {\n\t\t\t\tif (!isNaN(Number(word.word))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlet array = result[word.word];\n\t\t\t\tif (!array) {\n\t\t\t\t\tarray = [];\n\t\t\t\t\tresult[word.word] = array;\n\t\t\t\t}\n\t\t\t\tarray.push({\n\t\t\t\t\tstartLineNumber: line,\n\t\t\t\t\tstartColumn: word.startColumn,\n\t\t\t\t\tendLineNumber: line,\n\t\t\t\t\tendColumn: word.endColumn\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t//#endregion\n\n\tpublic async navigateValueSet(modelUrl: string, range: IRange, up: boolean, wordDef: string, wordDefFlags: string): Promise<IInplaceReplaceSupportResult | null> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n\n\t\tif (range.startColumn === range.endColumn) {\n\t\t\trange = {\n\t\t\t\tstartLineNumber: range.startLineNumber,\n\t\t\t\tstartColumn: range.startColumn,\n\t\t\t\tendLineNumber: range.endLineNumber,\n\t\t\t\tendColumn: range.endColumn + 1\n\t\t\t};\n\t\t}\n\n\t\tconst selectionText = model.getValueInRange(range);\n\n\t\tconst wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n\t\tif (!wordRange) {\n\t\t\treturn null;\n\t\t}\n\t\tconst word = model.getValueInRange(wordRange);\n\t\tconst result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n\t\treturn result;\n\t}\n\n\t// ---- BEGIN foreign module support --------------------------------------------------------------------------\n\n\tpublic loadForeignModule(moduleId: string, createData: any, foreignHostMethods: string[]): Promise<string[]> {\n\t\tconst proxyMethodRequest = (method: string, args: any[]): Promise<any> => {\n\t\t\treturn this._host.fhr(method, args);\n\t\t};\n\n\t\tconst foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);\n\n\t\tconst ctx: IWorkerContext<any> = {\n\t\t\thost: foreignHost,\n\t\t\tgetMirrorModels: (): IMirrorModel[] => {\n\t\t\t\treturn this._getModels();\n\t\t\t}\n\t\t};\n\n\t\tif (this._foreignModuleFactory) {\n\t\t\tthis._foreignModule = this._foreignModuleFactory(ctx, createData);\n\t\t\t// static foreing module\n\t\t\treturn Promise.resolve(getAllMethodNames(this._foreignModule));\n\t\t}\n\t\t// -ESM-comment-begin\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\trequire([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {\n\t\t\t\tthis._foreignModule = foreignModule.create(ctx, createData);\n\n\t\t\t\tresolve(getAllMethodNames(this._foreignModule));\n\n\t\t\t}, reject);\n\t\t});\n\t\t// -ESM-comment-end\n\n\t\t// -ESM-uncomment-begin\n\t\t// return Promise.reject(new Error(`Unexpected usage`));\n\t\t// -ESM-uncomment-end\n\t}\n\n\t// foreign method request\n\tpublic fmr(method: string, args: any[]): Promise<any> {\n\t\tif (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error('Missing requestHandler or method: ' + method));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\t// ---- END foreign module support --------------------------------------------------------------------------\n}\n\n/**\n * Called on the worker side\n * @internal\n */\nexport function create(host: IEditorWorkerHost): IRequestHandler {\n\treturn new EditorSimpleWorker(host, null);\n}\n\n// This is only available in a Web Worker\ndeclare function importScripts(...urls: string[]): void;\n\nif (typeof importScripts === 'function') {\n\t// Running in a web worker\n\tglobalThis.monaco = createMonacoBaseAPI();\n}\n"]}