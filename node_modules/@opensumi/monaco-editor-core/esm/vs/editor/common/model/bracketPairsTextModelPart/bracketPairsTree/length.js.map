{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.ts","vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.ts"],"names":[],"mappings":"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","file":"length.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { splitLines } from '../../../../../base/common/strings';\nimport { Position } from '../../../core/position';\nimport { Range } from '../../../core/range';\n\n/**\n * Represents a non-negative length in terms of line and column count.\n * Prefer using {@link Length} for performance reasons.\n*/\nexport class LengthObj {\n\tpublic static zero = new LengthObj(0, 0);\n\n\tpublic static lengthDiffNonNegative(start: LengthObj, end: LengthObj): LengthObj {\n\t\tif (end.isLessThan(start)) {\n\t\t\treturn LengthObj.zero;\n\t\t}\n\t\tif (start.lineCount === end.lineCount) {\n\t\t\treturn new LengthObj(0, end.columnCount - start.columnCount);\n\t\t} else {\n\t\t\treturn new LengthObj(end.lineCount - start.lineCount, end.columnCount);\n\t\t}\n\t}\n\n\tconstructor(\n\t\tpublic readonly lineCount: number,\n\t\tpublic readonly columnCount: number\n\t) { }\n\n\tpublic isZero() {\n\t\treturn this.lineCount === 0 && this.columnCount === 0;\n\t}\n\n\tpublic toLength(): Length {\n\t\treturn toLength(this.lineCount, this.columnCount);\n\t}\n\n\tpublic isLessThan(other: LengthObj): boolean {\n\t\tif (this.lineCount !== other.lineCount) {\n\t\t\treturn this.lineCount < other.lineCount;\n\t\t}\n\t\treturn this.columnCount < other.columnCount;\n\t}\n\n\tpublic isGreaterThan(other: LengthObj): boolean {\n\t\tif (this.lineCount !== other.lineCount) {\n\t\t\treturn this.lineCount > other.lineCount;\n\t\t}\n\t\treturn this.columnCount > other.columnCount;\n\t}\n\n\tpublic equals(other: LengthObj): boolean {\n\t\treturn this.lineCount === other.lineCount && this.columnCount === other.columnCount;\n\t}\n\n\tpublic compare(other: LengthObj): number {\n\t\tif (this.lineCount !== other.lineCount) {\n\t\t\treturn this.lineCount - other.lineCount;\n\t\t}\n\t\treturn this.columnCount - other.columnCount;\n\t}\n\n\tpublic add(other: LengthObj): LengthObj {\n\t\tif (other.lineCount === 0) {\n\t\t\treturn new LengthObj(this.lineCount, this.columnCount + other.columnCount);\n\t\t} else {\n\t\t\treturn new LengthObj(this.lineCount + other.lineCount, other.columnCount);\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn `${this.lineCount},${this.columnCount}`;\n\t}\n}\n\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount: number, startColumnCount: number, endLineCount: number, endColumnCount: number): Length {\n\treturn (startLineCount !== endLineCount)\n\t\t? toLength(endLineCount - startLineCount, endColumnCount)\n\t\t: toLength(0, endColumnCount - startColumnCount);\n}\n\n/**\n * Represents a non-negative length in terms of line and column count.\n * Does not allocate.\n*/\nexport type Length = { _brand: 'Length' };\n\nexport const lengthZero = 0 as any as Length;\n\nexport function lengthIsZero(length: Length): boolean {\n\treturn length as any as number === 0;\n}\n\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = 2 ** 26;\n/*/\nconst factor = 1000000;\n// */\n\nexport function toLength(lineCount: number, columnCount: number): Length {\n\t// llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n\t//       line count (26 bits)    column count (26 bits)\n\n\t// If there is no overflow (all values/sums below 2^26 = 67108864),\n\t// we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n\n\treturn (lineCount * factor + columnCount) as any as Length;\n}\n\nexport function lengthToObj(length: Length): LengthObj {\n\tconst l = length as any as number;\n\tconst lineCount = Math.floor(l / factor);\n\tconst columnCount = l - lineCount * factor;\n\treturn new LengthObj(lineCount, columnCount);\n}\n\nexport function lengthGetLineCount(length: Length): number {\n\treturn Math.floor(length as any as number / factor);\n}\n\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length: Length): number {\n\treturn length as any as number;\n}\n\n\n// [10 lines, 5 cols] + [ 0 lines, 3 cols] = [10 lines, 8 cols]\n// [10 lines, 5 cols] + [20 lines, 3 cols] = [30 lines, 3 cols]\nexport function lengthAdd(length1: Length, length2: Length): Length;\nexport function lengthAdd(l1: any, l2: any): Length {\n\tlet r = l1 + l2;\n\tif (l2 >= factor) { r = r - (l1 % factor); }\n\treturn r;\n}\n\nexport function sumLengths<T>(items: readonly T[], lengthFn: (item: T) => Length): Length {\n\treturn items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\n\nexport function lengthEquals(length1: Length, length2: Length): boolean {\n\treturn length1 === length2;\n}\n\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1: Length, length2: Length): Length {\n\tconst l1 = length1 as any as number;\n\tconst l2 = length2 as any as number;\n\n\tconst diff = l2 - l1;\n\tif (diff <= 0) {\n\t\t// line-count of length1 is higher than line-count of length2\n\t\t// or they are equal and column-count of length1 is higher than column-count of length2\n\t\treturn lengthZero;\n\t}\n\n\tconst lineCount1 = Math.floor(l1 / factor);\n\tconst lineCount2 = Math.floor(l2 / factor);\n\n\tconst colCount2 = l2 - lineCount2 * factor;\n\n\tif (lineCount1 === lineCount2) {\n\t\tconst colCount1 = l1 - lineCount1 * factor;\n\t\treturn toLength(0, colCount2 - colCount1);\n\t} else {\n\t\treturn toLength(lineCount2 - lineCount1, colCount2);\n\t}\n}\n\nexport function lengthLessThan(length1: Length, length2: Length): boolean {\n\t// First, compare line counts, then column counts.\n\treturn (length1 as any as number) < (length2 as any as number);\n}\n\nexport function lengthLessThanEqual(length1: Length, length2: Length): boolean {\n\treturn (length1 as any as number) <= (length2 as any as number);\n}\n\nexport function lengthGreaterThanEqual(length1: Length, length2: Length): boolean {\n\treturn (length1 as any as number) >= (length2 as any as number);\n}\n\nexport function lengthToPosition(length: Length): Position {\n\tconst l = length as any as number;\n\tconst lineCount = Math.floor(l / factor);\n\tconst colCount = l - lineCount * factor;\n\treturn new Position(lineCount + 1, colCount + 1);\n}\n\nexport function positionToLength(position: Position): Length {\n\treturn toLength(position.lineNumber - 1, position.column - 1);\n}\n\nexport function lengthsToRange(lengthStart: Length, lengthEnd: Length): Range {\n\tconst l = lengthStart as any as number;\n\tconst lineCount = Math.floor(l / factor);\n\tconst colCount = l - lineCount * factor;\n\n\tconst l2 = lengthEnd as any as number;\n\tconst lineCount2 = Math.floor(l2 / factor);\n\tconst colCount2 = l2 - lineCount2 * factor;\n\n\treturn new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\n\nexport function lengthOfRange(range: Range): LengthObj {\n\tif (range.startLineNumber === range.endLineNumber) {\n\t\treturn new LengthObj(0, range.endColumn - range.startColumn);\n\t} else {\n\t\treturn new LengthObj(range.endLineNumber - range.startLineNumber, range.endColumn - 1);\n\t}\n}\n\nexport function lengthCompare(length1: Length, length2: Length): number {\n\tconst l1 = length1 as any as number;\n\tconst l2 = length2 as any as number;\n\treturn l1 - l2;\n}\n\nexport function lengthOfString(str: string): Length {\n\tconst lines = splitLines(str);\n\treturn toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n\nexport function lengthOfStringObj(str: string): LengthObj {\n\tconst lines = splitLines(str);\n\treturn new LengthObj(lines.length - 1, lines[lines.length - 1].length);\n}\n\n/**\n * Computes a numeric hash of the given length.\n*/\nexport function lengthHash(length: Length): number {\n\treturn length as any;\n}\n\nexport function lengthMax(length1: Length, length2: Length): Length {\n\treturn length1 > length2 ? length1 : length2;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { splitLines } from '../../../../../base/common/strings';\nimport { Position } from '../../../core/position';\nimport { Range } from '../../../core/range';\n\n/**\n * Represents a non-negative length in terms of line and column count.\n * Prefer using {@link Length} for performance reasons.\n*/\nexport class LengthObj {\n\tpublic static zero = new LengthObj(0, 0);\n\n\tpublic static lengthDiffNonNegative(start: LengthObj, end: LengthObj): LengthObj {\n\t\tif (end.isLessThan(start)) {\n\t\t\treturn LengthObj.zero;\n\t\t}\n\t\tif (start.lineCount === end.lineCount) {\n\t\t\treturn new LengthObj(0, end.columnCount - start.columnCount);\n\t\t} else {\n\t\t\treturn new LengthObj(end.lineCount - start.lineCount, end.columnCount);\n\t\t}\n\t}\n\n\tconstructor(\n\t\tpublic readonly lineCount: number,\n\t\tpublic readonly columnCount: number\n\t) { }\n\n\tpublic isZero() {\n\t\treturn this.lineCount === 0 && this.columnCount === 0;\n\t}\n\n\tpublic toLength(): Length {\n\t\treturn toLength(this.lineCount, this.columnCount);\n\t}\n\n\tpublic isLessThan(other: LengthObj): boolean {\n\t\tif (this.lineCount !== other.lineCount) {\n\t\t\treturn this.lineCount < other.lineCount;\n\t\t}\n\t\treturn this.columnCount < other.columnCount;\n\t}\n\n\tpublic isGreaterThan(other: LengthObj): boolean {\n\t\tif (this.lineCount !== other.lineCount) {\n\t\t\treturn this.lineCount > other.lineCount;\n\t\t}\n\t\treturn this.columnCount > other.columnCount;\n\t}\n\n\tpublic equals(other: LengthObj): boolean {\n\t\treturn this.lineCount === other.lineCount && this.columnCount === other.columnCount;\n\t}\n\n\tpublic compare(other: LengthObj): number {\n\t\tif (this.lineCount !== other.lineCount) {\n\t\t\treturn this.lineCount - other.lineCount;\n\t\t}\n\t\treturn this.columnCount - other.columnCount;\n\t}\n\n\tpublic add(other: LengthObj): LengthObj {\n\t\tif (other.lineCount === 0) {\n\t\t\treturn new LengthObj(this.lineCount, this.columnCount + other.columnCount);\n\t\t} else {\n\t\t\treturn new LengthObj(this.lineCount + other.lineCount, other.columnCount);\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn `${this.lineCount},${this.columnCount}`;\n\t}\n}\n\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount: number, startColumnCount: number, endLineCount: number, endColumnCount: number): Length {\n\treturn (startLineCount !== endLineCount)\n\t\t? toLength(endLineCount - startLineCount, endColumnCount)\n\t\t: toLength(0, endColumnCount - startColumnCount);\n}\n\n/**\n * Represents a non-negative length in terms of line and column count.\n * Does not allocate.\n*/\nexport type Length = { _brand: 'Length' };\n\nexport const lengthZero = 0 as any as Length;\n\nexport function lengthIsZero(length: Length): boolean {\n\treturn length as any as number === 0;\n}\n\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = 2 ** 26;\n/*/\nconst factor = 1000000;\n// */\n\nexport function toLength(lineCount: number, columnCount: number): Length {\n\t// llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n\t//       line count (26 bits)    column count (26 bits)\n\n\t// If there is no overflow (all values/sums below 2^26 = 67108864),\n\t// we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n\n\treturn (lineCount * factor + columnCount) as any as Length;\n}\n\nexport function lengthToObj(length: Length): LengthObj {\n\tconst l = length as any as number;\n\tconst lineCount = Math.floor(l / factor);\n\tconst columnCount = l - lineCount * factor;\n\treturn new LengthObj(lineCount, columnCount);\n}\n\nexport function lengthGetLineCount(length: Length): number {\n\treturn Math.floor(length as any as number / factor);\n}\n\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length: Length): number {\n\treturn length as any as number;\n}\n\n\n// [10 lines, 5 cols] + [ 0 lines, 3 cols] = [10 lines, 8 cols]\n// [10 lines, 5 cols] + [20 lines, 3 cols] = [30 lines, 3 cols]\nexport function lengthAdd(length1: Length, length2: Length): Length;\nexport function lengthAdd(l1: any, l2: any): Length {\n\tlet r = l1 + l2;\n\tif (l2 >= factor) { r = r - (l1 % factor); }\n\treturn r;\n}\n\nexport function sumLengths<T>(items: readonly T[], lengthFn: (item: T) => Length): Length {\n\treturn items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\n\nexport function lengthEquals(length1: Length, length2: Length): boolean {\n\treturn length1 === length2;\n}\n\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1: Length, length2: Length): Length {\n\tconst l1 = length1 as any as number;\n\tconst l2 = length2 as any as number;\n\n\tconst diff = l2 - l1;\n\tif (diff <= 0) {\n\t\t// line-count of length1 is higher than line-count of length2\n\t\t// or they are equal and column-count of length1 is higher than column-count of length2\n\t\treturn lengthZero;\n\t}\n\n\tconst lineCount1 = Math.floor(l1 / factor);\n\tconst lineCount2 = Math.floor(l2 / factor);\n\n\tconst colCount2 = l2 - lineCount2 * factor;\n\n\tif (lineCount1 === lineCount2) {\n\t\tconst colCount1 = l1 - lineCount1 * factor;\n\t\treturn toLength(0, colCount2 - colCount1);\n\t} else {\n\t\treturn toLength(lineCount2 - lineCount1, colCount2);\n\t}\n}\n\nexport function lengthLessThan(length1: Length, length2: Length): boolean {\n\t// First, compare line counts, then column counts.\n\treturn (length1 as any as number) < (length2 as any as number);\n}\n\nexport function lengthLessThanEqual(length1: Length, length2: Length): boolean {\n\treturn (length1 as any as number) <= (length2 as any as number);\n}\n\nexport function lengthGreaterThanEqual(length1: Length, length2: Length): boolean {\n\treturn (length1 as any as number) >= (length2 as any as number);\n}\n\nexport function lengthToPosition(length: Length): Position {\n\tconst l = length as any as number;\n\tconst lineCount = Math.floor(l / factor);\n\tconst colCount = l - lineCount * factor;\n\treturn new Position(lineCount + 1, colCount + 1);\n}\n\nexport function positionToLength(position: Position): Length {\n\treturn toLength(position.lineNumber - 1, position.column - 1);\n}\n\nexport function lengthsToRange(lengthStart: Length, lengthEnd: Length): Range {\n\tconst l = lengthStart as any as number;\n\tconst lineCount = Math.floor(l / factor);\n\tconst colCount = l - lineCount * factor;\n\n\tconst l2 = lengthEnd as any as number;\n\tconst lineCount2 = Math.floor(l2 / factor);\n\tconst colCount2 = l2 - lineCount2 * factor;\n\n\treturn new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\n\nexport function lengthOfRange(range: Range): LengthObj {\n\tif (range.startLineNumber === range.endLineNumber) {\n\t\treturn new LengthObj(0, range.endColumn - range.startColumn);\n\t} else {\n\t\treturn new LengthObj(range.endLineNumber - range.startLineNumber, range.endColumn - 1);\n\t}\n}\n\nexport function lengthCompare(length1: Length, length2: Length): number {\n\tconst l1 = length1 as any as number;\n\tconst l2 = length2 as any as number;\n\treturn l1 - l2;\n}\n\nexport function lengthOfString(str: string): Length {\n\tconst lines = splitLines(str);\n\treturn toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n\nexport function lengthOfStringObj(str: string): LengthObj {\n\tconst lines = splitLines(str);\n\treturn new LengthObj(lines.length - 1, lines[lines.length - 1].length);\n}\n\n/**\n * Computes a numeric hash of the given length.\n*/\nexport function lengthHash(length: Length): number {\n\treturn length as any;\n}\n\nexport function lengthMax(length1: Length, length2: Length): Length {\n\treturn length1 > length2 ? length1 : length2;\n}\n"]}