{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/editor/common/diff/rangeMapping.ts","vs/editor/common/diff/rangeMapping.ts"],"names":[],"mappings":"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","file":"rangeMapping.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LineRange } from '../core/lineRange';\nimport { Range } from '../core/range';\n\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n\tpublic static inverse(mapping: readonly LineRangeMapping[], originalLineCount: number, modifiedLineCount: number): LineRangeMapping[] {\n\t\tconst result: LineRangeMapping[] = [];\n\t\tlet lastOriginalEndLineNumber = 1;\n\t\tlet lastModifiedEndLineNumber = 1;\n\n\t\tfor (const m of mapping) {\n\t\t\tconst r = new LineRangeMapping(\n\t\t\t\tnew LineRange(lastOriginalEndLineNumber, m.original.startLineNumber),\n\t\t\t\tnew LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber),\n\t\t\t);\n\t\t\tif (!r.modified.isEmpty) {\n\t\t\t\tresult.push(r);\n\t\t\t}\n\t\t\tlastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n\t\t\tlastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n\t\t}\n\t\tconst r = new LineRangeMapping(\n\t\t\tnew LineRange(lastOriginalEndLineNumber, originalLineCount + 1),\n\t\t\tnew LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1),\n\t\t);\n\t\tif (!r.modified.isEmpty) {\n\t\t\tresult.push(r);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static clip(mapping: readonly LineRangeMapping[], originalRange: LineRange, modifiedRange: LineRange): LineRangeMapping[] {\n\t\tconst result: LineRangeMapping[] = [];\n\t\tfor (const m of mapping) {\n\t\t\tconst original = m.original.intersect(originalRange);\n\t\t\tconst modified = m.modified.intersect(modifiedRange);\n\t\t\tif (original && !original.isEmpty && modified && !modified.isEmpty) {\n\t\t\t\tresult.push(new LineRangeMapping(original, modified));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The line range in the original text model.\n\t */\n\tpublic readonly original: LineRange;\n\n\t/**\n\t * The line range in the modified text model.\n\t */\n\tpublic readonly modified: LineRange;\n\n\tconstructor(\n\t\toriginalRange: LineRange,\n\t\tmodifiedRange: LineRange\n\t) {\n\t\tthis.original = originalRange;\n\t\tthis.modified = modifiedRange;\n\t}\n\n\n\tpublic toString(): string {\n\t\treturn `{${this.original.toString()}->${this.modified.toString()}}`;\n\t}\n\n\tpublic flip(): LineRangeMapping {\n\t\treturn new LineRangeMapping(this.modified, this.original);\n\t}\n\n\tpublic join(other: LineRangeMapping): LineRangeMapping {\n\t\treturn new LineRangeMapping(\n\t\t\tthis.original.join(other.original),\n\t\t\tthis.modified.join(other.modified)\n\t\t);\n\t}\n\n\tpublic get changedLineCount() {\n\t\treturn Math.max(this.original.length, this.modified.length);\n\t}\n}\n\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n\t/**\n\t * If inner changes have not been computed, this is set to undefined.\n\t * Otherwise, it represents the character-level diff in this line range.\n\t * The original range of each range mapping should be contained in the original line range (same for modified), exceptions are new-lines.\n\t * Must not be an empty array.\n\t */\n\tpublic readonly innerChanges: RangeMapping[] | undefined;\n\n\tconstructor(\n\t\toriginalRange: LineRange,\n\t\tmodifiedRange: LineRange,\n\t\tinnerChanges: RangeMapping[] | undefined\n\t) {\n\t\tsuper(originalRange, modifiedRange);\n\t\tthis.innerChanges = innerChanges;\n\t}\n\n\tpublic override flip(): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map(c => c.flip()));\n\t}\n}\n\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n\t/**\n\t * The original range.\n\t */\n\treadonly originalRange: Range;\n\n\t/**\n\t * The modified range.\n\t */\n\treadonly modifiedRange: Range;\n\n\tconstructor(\n\t\toriginalRange: Range,\n\t\tmodifiedRange: Range\n\t) {\n\t\tthis.originalRange = originalRange;\n\t\tthis.modifiedRange = modifiedRange;\n\t}\n\n\tpublic toString(): string {\n\t\treturn `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n\t}\n\n\tpublic flip(): RangeMapping {\n\t\treturn new RangeMapping(this.modifiedRange, this.originalRange);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LineRange } from '../core/lineRange';\nimport { Range } from '../core/range';\n\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n\tpublic static inverse(mapping: readonly LineRangeMapping[], originalLineCount: number, modifiedLineCount: number): LineRangeMapping[] {\n\t\tconst result: LineRangeMapping[] = [];\n\t\tlet lastOriginalEndLineNumber = 1;\n\t\tlet lastModifiedEndLineNumber = 1;\n\n\t\tfor (const m of mapping) {\n\t\t\tconst r = new LineRangeMapping(\n\t\t\t\tnew LineRange(lastOriginalEndLineNumber, m.original.startLineNumber),\n\t\t\t\tnew LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber),\n\t\t\t);\n\t\t\tif (!r.modified.isEmpty) {\n\t\t\t\tresult.push(r);\n\t\t\t}\n\t\t\tlastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n\t\t\tlastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n\t\t}\n\t\tconst r = new LineRangeMapping(\n\t\t\tnew LineRange(lastOriginalEndLineNumber, originalLineCount + 1),\n\t\t\tnew LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1),\n\t\t);\n\t\tif (!r.modified.isEmpty) {\n\t\t\tresult.push(r);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static clip(mapping: readonly LineRangeMapping[], originalRange: LineRange, modifiedRange: LineRange): LineRangeMapping[] {\n\t\tconst result: LineRangeMapping[] = [];\n\t\tfor (const m of mapping) {\n\t\t\tconst original = m.original.intersect(originalRange);\n\t\t\tconst modified = m.modified.intersect(modifiedRange);\n\t\t\tif (original && !original.isEmpty && modified && !modified.isEmpty) {\n\t\t\t\tresult.push(new LineRangeMapping(original, modified));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The line range in the original text model.\n\t */\n\tpublic readonly original: LineRange;\n\n\t/**\n\t * The line range in the modified text model.\n\t */\n\tpublic readonly modified: LineRange;\n\n\tconstructor(\n\t\toriginalRange: LineRange,\n\t\tmodifiedRange: LineRange\n\t) {\n\t\tthis.original = originalRange;\n\t\tthis.modified = modifiedRange;\n\t}\n\n\n\tpublic toString(): string {\n\t\treturn `{${this.original.toString()}->${this.modified.toString()}}`;\n\t}\n\n\tpublic flip(): LineRangeMapping {\n\t\treturn new LineRangeMapping(this.modified, this.original);\n\t}\n\n\tpublic join(other: LineRangeMapping): LineRangeMapping {\n\t\treturn new LineRangeMapping(\n\t\t\tthis.original.join(other.original),\n\t\t\tthis.modified.join(other.modified)\n\t\t);\n\t}\n\n\tpublic get changedLineCount() {\n\t\treturn Math.max(this.original.length, this.modified.length);\n\t}\n}\n\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n\t/**\n\t * If inner changes have not been computed, this is set to undefined.\n\t * Otherwise, it represents the character-level diff in this line range.\n\t * The original range of each range mapping should be contained in the original line range (same for modified), exceptions are new-lines.\n\t * Must not be an empty array.\n\t */\n\tpublic readonly innerChanges: RangeMapping[] | undefined;\n\n\tconstructor(\n\t\toriginalRange: LineRange,\n\t\tmodifiedRange: LineRange,\n\t\tinnerChanges: RangeMapping[] | undefined\n\t) {\n\t\tsuper(originalRange, modifiedRange);\n\t\tthis.innerChanges = innerChanges;\n\t}\n\n\tpublic override flip(): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map(c => c.flip()));\n\t}\n}\n\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n\t/**\n\t * The original range.\n\t */\n\treadonly originalRange: Range;\n\n\t/**\n\t * The modified range.\n\t */\n\treadonly modifiedRange: Range;\n\n\tconstructor(\n\t\toriginalRange: Range,\n\t\tmodifiedRange: Range\n\t) {\n\t\tthis.originalRange = originalRange;\n\t\tthis.modifiedRange = modifiedRange;\n\t}\n\n\tpublic toString(): string {\n\t\treturn `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n\t}\n\n\tpublic flip(): RangeMapping {\n\t\treturn new RangeMapping(this.modifiedRange, this.originalRange);\n\t}\n}\n"]}