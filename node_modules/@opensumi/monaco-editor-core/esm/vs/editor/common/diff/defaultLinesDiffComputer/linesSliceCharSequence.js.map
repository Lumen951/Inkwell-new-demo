{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.ts","vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.ts"],"names":[],"mappings":"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","file":"linesSliceCharSequence.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind';\nimport { CharCode } from '../../../../base/common/charCode';\nimport { OffsetRange } from '../../core/offsetRange';\nimport { Position } from '../../core/position';\nimport { Range } from '../../core/range';\nimport { ISequence } from './algorithms/diffAlgorithm';\nimport { isSpace } from './utils';\n\nexport class LinesSliceCharSequence implements ISequence {\n\tprivate readonly elements: number[] = [];\n\tprivate readonly firstCharOffsetByLine: number[] = [];\n\tpublic readonly lineRange: OffsetRange;\n\t// To account for trimming\n\tprivate readonly additionalOffsetByLine: number[] = [];\n\n\tconstructor(public readonly lines: string[], lineRange: OffsetRange, public readonly considerWhitespaceChanges: boolean) {\n\t\t// This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\n\t\t// (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\n\n\t\t// If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\n\t\tlet trimFirstLineFully = false;\n\t\tif (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n\t\t\tlineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n\t\t\ttrimFirstLineFully = true;\n\t\t}\n\n\t\tthis.lineRange = lineRange;\n\n\t\tthis.firstCharOffsetByLine[0] = 0;\n\t\tfor (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n\t\t\tlet line = lines[i];\n\t\t\tlet offset = 0;\n\t\t\tif (trimFirstLineFully) {\n\t\t\t\toffset = line.length;\n\t\t\t\tline = '';\n\t\t\t\ttrimFirstLineFully = false;\n\t\t\t} else if (!considerWhitespaceChanges) {\n\t\t\t\tconst trimmedStartLine = line.trimStart();\n\t\t\t\toffset = line.length - trimmedStartLine.length;\n\t\t\t\tline = trimmedStartLine.trimEnd();\n\t\t\t}\n\n\t\t\tthis.additionalOffsetByLine.push(offset);\n\n\t\t\tfor (let i = 0; i < line.length; i++) {\n\t\t\t\tthis.elements.push(line.charCodeAt(i));\n\t\t\t}\n\n\t\t\t// Don't add an \\n that does not exist in the document.\n\t\t\tif (i < lines.length - 1) {\n\t\t\t\tthis.elements.push('\\n'.charCodeAt(0));\n\t\t\t\tthis.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;\n\t\t\t}\n\t\t}\n\t\t// To account for the last line\n\t\tthis.additionalOffsetByLine.push(0);\n\t}\n\n\ttoString() {\n\t\treturn `Slice: \"${this.text}\"`;\n\t}\n\n\tget text(): string {\n\t\treturn this.getText(new OffsetRange(0, this.length));\n\t}\n\n\tgetText(range: OffsetRange): string {\n\t\treturn this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n\t}\n\n\tgetElement(offset: number): number {\n\t\treturn this.elements[offset];\n\t}\n\n\tget length(): number {\n\t\treturn this.elements.length;\n\t}\n\n\tpublic getBoundaryScore(length: number): number {\n\t\t//   a   b   c   ,           d   e   f\n\t\t// 11  0   0   12  15  6   13  0   0   11\n\n\t\tconst prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n\t\tconst nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakCR && nextCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// don't break between \\r and \\n\n\t\t\treturn 0;\n\t\t}\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// prefer the linebreak before the change\n\t\t\treturn 150;\n\t\t}\n\n\t\tlet score = 0;\n\t\tif (prevCategory !== nextCategory) {\n\t\t\tscore += 10;\n\t\t\tif (prevCategory === CharBoundaryCategory.WordLower && nextCategory === CharBoundaryCategory.WordUpper) {\n\t\t\t\tscore += 1;\n\t\t\t}\n\t\t}\n\n\t\tscore += getCategoryBoundaryScore(prevCategory);\n\t\tscore += getCategoryBoundaryScore(nextCategory);\n\n\t\treturn score;\n\t}\n\n\tpublic translateOffset(offset: number): Position {\n\t\t// find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n\t\tif (this.lineRange.isEmpty) {\n\t\t\treturn new Position(this.lineRange.start + 1, 1);\n\t\t}\n\n\t\tconst i = findLastIdxMonotonous(this.firstCharOffsetByLine, (value) => value <= offset);\n\t\treturn new Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);\n\t}\n\n\tpublic translateRange(range: OffsetRange): Range {\n\t\treturn Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n\t}\n\n\t/**\n\t * Finds the word that contains the character at the given offset\n\t */\n\tpublic findWordContaining(offset: number): OffsetRange | undefined {\n\t\tif (offset < 0 || offset >= this.elements.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!isWordChar(this.elements[offset])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// find start\n\t\tlet start = offset;\n\t\twhile (start > 0 && isWordChar(this.elements[start - 1])) {\n\t\t\tstart--;\n\t\t}\n\n\t\t// find end\n\t\tlet end = offset;\n\t\twhile (end < this.elements.length && isWordChar(this.elements[end])) {\n\t\t\tend++;\n\t\t}\n\n\t\treturn new OffsetRange(start, end);\n\t}\n\n\tpublic countLinesIn(range: OffsetRange): number {\n\t\treturn this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n\t}\n\n\tpublic isStronglyEqual(offset1: number, offset2: number): boolean {\n\t\treturn this.elements[offset1] === this.elements[offset2];\n\t}\n\n\tpublic extendToFullLines(range: OffsetRange): OffsetRange {\n\t\tconst start = findLastMonotonous(this.firstCharOffsetByLine, x => x <= range.start) ?? 0;\n\t\tconst end = findFirstMonotonous(this.firstCharOffsetByLine, x => range.endExclusive <= x) ?? this.elements.length;\n\t\treturn new OffsetRange(start, end);\n\t}\n}\n\nfunction isWordChar(charCode: number): boolean {\n\treturn charCode >= CharCode.a && charCode <= CharCode.z\n\t\t|| charCode >= CharCode.A && charCode <= CharCode.Z\n\t\t|| charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9;\n}\n\nconst enum CharBoundaryCategory {\n\tWordLower,\n\tWordUpper,\n\tWordNumber,\n\tEnd,\n\tOther,\n\tSeparator,\n\tSpace,\n\tLineBreakCR,\n\tLineBreakLF,\n}\n\nconst score: Record<CharBoundaryCategory, number> = {\n\t[CharBoundaryCategory.WordLower]: 0,\n\t[CharBoundaryCategory.WordUpper]: 0,\n\t[CharBoundaryCategory.WordNumber]: 0,\n\t[CharBoundaryCategory.End]: 10,\n\t[CharBoundaryCategory.Other]: 2,\n\t[CharBoundaryCategory.Separator]: 30,\n\t[CharBoundaryCategory.Space]: 3,\n\t[CharBoundaryCategory.LineBreakCR]: 10,\n\t[CharBoundaryCategory.LineBreakLF]: 10,\n};\n\nfunction getCategoryBoundaryScore(category: CharBoundaryCategory): number {\n\treturn score[category];\n}\n\nfunction getCategory(charCode: number): CharBoundaryCategory {\n\tif (charCode === CharCode.LineFeed) {\n\t\treturn CharBoundaryCategory.LineBreakLF;\n\t} else if (charCode === CharCode.CarriageReturn) {\n\t\treturn CharBoundaryCategory.LineBreakCR;\n\t} else if (isSpace(charCode)) {\n\t\treturn CharBoundaryCategory.Space;\n\t} else if (charCode >= CharCode.a && charCode <= CharCode.z) {\n\t\treturn CharBoundaryCategory.WordLower;\n\t} else if (charCode >= CharCode.A && charCode <= CharCode.Z) {\n\t\treturn CharBoundaryCategory.WordUpper;\n\t} else if (charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9) {\n\t\treturn CharBoundaryCategory.WordNumber;\n\t} else if (charCode === -1) {\n\t\treturn CharBoundaryCategory.End;\n\t} else if (charCode === CharCode.Comma || charCode === CharCode.Semicolon) {\n\t\treturn CharBoundaryCategory.Separator;\n\t} else {\n\t\treturn CharBoundaryCategory.Other;\n\t}\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind';\nimport { CharCode } from '../../../../base/common/charCode';\nimport { OffsetRange } from '../../core/offsetRange';\nimport { Position } from '../../core/position';\nimport { Range } from '../../core/range';\nimport { ISequence } from './algorithms/diffAlgorithm';\nimport { isSpace } from './utils';\n\nexport class LinesSliceCharSequence implements ISequence {\n\tprivate readonly elements: number[] = [];\n\tprivate readonly firstCharOffsetByLine: number[] = [];\n\tpublic readonly lineRange: OffsetRange;\n\t// To account for trimming\n\tprivate readonly additionalOffsetByLine: number[] = [];\n\n\tconstructor(public readonly lines: string[], lineRange: OffsetRange, public readonly considerWhitespaceChanges: boolean) {\n\t\t// This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\n\t\t// (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\n\n\t\t// If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\n\t\tlet trimFirstLineFully = false;\n\t\tif (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n\t\t\tlineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n\t\t\ttrimFirstLineFully = true;\n\t\t}\n\n\t\tthis.lineRange = lineRange;\n\n\t\tthis.firstCharOffsetByLine[0] = 0;\n\t\tfor (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n\t\t\tlet line = lines[i];\n\t\t\tlet offset = 0;\n\t\t\tif (trimFirstLineFully) {\n\t\t\t\toffset = line.length;\n\t\t\t\tline = '';\n\t\t\t\ttrimFirstLineFully = false;\n\t\t\t} else if (!considerWhitespaceChanges) {\n\t\t\t\tconst trimmedStartLine = line.trimStart();\n\t\t\t\toffset = line.length - trimmedStartLine.length;\n\t\t\t\tline = trimmedStartLine.trimEnd();\n\t\t\t}\n\n\t\t\tthis.additionalOffsetByLine.push(offset);\n\n\t\t\tfor (let i = 0; i < line.length; i++) {\n\t\t\t\tthis.elements.push(line.charCodeAt(i));\n\t\t\t}\n\n\t\t\t// Don't add an \\n that does not exist in the document.\n\t\t\tif (i < lines.length - 1) {\n\t\t\t\tthis.elements.push('\\n'.charCodeAt(0));\n\t\t\t\tthis.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;\n\t\t\t}\n\t\t}\n\t\t// To account for the last line\n\t\tthis.additionalOffsetByLine.push(0);\n\t}\n\n\ttoString() {\n\t\treturn `Slice: \"${this.text}\"`;\n\t}\n\n\tget text(): string {\n\t\treturn this.getText(new OffsetRange(0, this.length));\n\t}\n\n\tgetText(range: OffsetRange): string {\n\t\treturn this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n\t}\n\n\tgetElement(offset: number): number {\n\t\treturn this.elements[offset];\n\t}\n\n\tget length(): number {\n\t\treturn this.elements.length;\n\t}\n\n\tpublic getBoundaryScore(length: number): number {\n\t\t//   a   b   c   ,           d   e   f\n\t\t// 11  0   0   12  15  6   13  0   0   11\n\n\t\tconst prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n\t\tconst nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakCR && nextCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// don't break between \\r and \\n\n\t\t\treturn 0;\n\t\t}\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// prefer the linebreak before the change\n\t\t\treturn 150;\n\t\t}\n\n\t\tlet score = 0;\n\t\tif (prevCategory !== nextCategory) {\n\t\t\tscore += 10;\n\t\t\tif (prevCategory === CharBoundaryCategory.WordLower && nextCategory === CharBoundaryCategory.WordUpper) {\n\t\t\t\tscore += 1;\n\t\t\t}\n\t\t}\n\n\t\tscore += getCategoryBoundaryScore(prevCategory);\n\t\tscore += getCategoryBoundaryScore(nextCategory);\n\n\t\treturn score;\n\t}\n\n\tpublic translateOffset(offset: number): Position {\n\t\t// find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n\t\tif (this.lineRange.isEmpty) {\n\t\t\treturn new Position(this.lineRange.start + 1, 1);\n\t\t}\n\n\t\tconst i = findLastIdxMonotonous(this.firstCharOffsetByLine, (value) => value <= offset);\n\t\treturn new Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);\n\t}\n\n\tpublic translateRange(range: OffsetRange): Range {\n\t\treturn Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n\t}\n\n\t/**\n\t * Finds the word that contains the character at the given offset\n\t */\n\tpublic findWordContaining(offset: number): OffsetRange | undefined {\n\t\tif (offset < 0 || offset >= this.elements.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!isWordChar(this.elements[offset])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// find start\n\t\tlet start = offset;\n\t\twhile (start > 0 && isWordChar(this.elements[start - 1])) {\n\t\t\tstart--;\n\t\t}\n\n\t\t// find end\n\t\tlet end = offset;\n\t\twhile (end < this.elements.length && isWordChar(this.elements[end])) {\n\t\t\tend++;\n\t\t}\n\n\t\treturn new OffsetRange(start, end);\n\t}\n\n\tpublic countLinesIn(range: OffsetRange): number {\n\t\treturn this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n\t}\n\n\tpublic isStronglyEqual(offset1: number, offset2: number): boolean {\n\t\treturn this.elements[offset1] === this.elements[offset2];\n\t}\n\n\tpublic extendToFullLines(range: OffsetRange): OffsetRange {\n\t\tconst start = findLastMonotonous(this.firstCharOffsetByLine, x => x <= range.start) ?? 0;\n\t\tconst end = findFirstMonotonous(this.firstCharOffsetByLine, x => range.endExclusive <= x) ?? this.elements.length;\n\t\treturn new OffsetRange(start, end);\n\t}\n}\n\nfunction isWordChar(charCode: number): boolean {\n\treturn charCode >= CharCode.a && charCode <= CharCode.z\n\t\t|| charCode >= CharCode.A && charCode <= CharCode.Z\n\t\t|| charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9;\n}\n\nconst enum CharBoundaryCategory {\n\tWordLower,\n\tWordUpper,\n\tWordNumber,\n\tEnd,\n\tOther,\n\tSeparator,\n\tSpace,\n\tLineBreakCR,\n\tLineBreakLF,\n}\n\nconst score: Record<CharBoundaryCategory, number> = {\n\t[CharBoundaryCategory.WordLower]: 0,\n\t[CharBoundaryCategory.WordUpper]: 0,\n\t[CharBoundaryCategory.WordNumber]: 0,\n\t[CharBoundaryCategory.End]: 10,\n\t[CharBoundaryCategory.Other]: 2,\n\t[CharBoundaryCategory.Separator]: 30,\n\t[CharBoundaryCategory.Space]: 3,\n\t[CharBoundaryCategory.LineBreakCR]: 10,\n\t[CharBoundaryCategory.LineBreakLF]: 10,\n};\n\nfunction getCategoryBoundaryScore(category: CharBoundaryCategory): number {\n\treturn score[category];\n}\n\nfunction getCategory(charCode: number): CharBoundaryCategory {\n\tif (charCode === CharCode.LineFeed) {\n\t\treturn CharBoundaryCategory.LineBreakLF;\n\t} else if (charCode === CharCode.CarriageReturn) {\n\t\treturn CharBoundaryCategory.LineBreakCR;\n\t} else if (isSpace(charCode)) {\n\t\treturn CharBoundaryCategory.Space;\n\t} else if (charCode >= CharCode.a && charCode <= CharCode.z) {\n\t\treturn CharBoundaryCategory.WordLower;\n\t} else if (charCode >= CharCode.A && charCode <= CharCode.Z) {\n\t\treturn CharBoundaryCategory.WordUpper;\n\t} else if (charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9) {\n\t\treturn CharBoundaryCategory.WordNumber;\n\t} else if (charCode === -1) {\n\t\treturn CharBoundaryCategory.End;\n\t} else if (charCode === CharCode.Comma || charCode === CharCode.Semicolon) {\n\t\treturn CharBoundaryCategory.Separator;\n\t} else {\n\t\treturn CharBoundaryCategory.Other;\n\t}\n}\n\n"]}