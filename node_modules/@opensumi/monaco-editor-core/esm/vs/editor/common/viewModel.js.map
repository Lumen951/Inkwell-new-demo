{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/editor/common/viewModel.ts","vs/editor/common/viewModel.ts"],"names":[],"mappings":"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","file":"viewModel.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from '../../base/common/arrays';\nimport { IScrollPosition, Scrollable } from '../../base/common/scrollable';\nimport * as strings from '../../base/common/strings';\nimport { IPosition, Position } from './core/position';\nimport { Range } from './core/range';\nimport { CursorConfiguration, CursorState, EditOperationType, IColumnSelectData, ICursorSimpleModel, PartialCursorState } from './cursorCommon';\nimport { CursorChangeReason } from './cursorEvents';\nimport { INewScrollPosition, ScrollType } from './editorCommon';\nimport { EditorTheme } from './editorTheme';\nimport { EndOfLinePreference, IGlyphMarginLanesModel, IModelDecorationOptions, ITextModel, PositionAffinity } from './model';\nimport { ILineBreaksComputer, InjectedText } from './modelLineProjectionData';\nimport { BracketGuideOptions, IActiveIndentGuideInfo, IndentGuide } from './textModelGuides';\nimport { IViewLineTokens } from './tokens/lineTokens';\nimport { ViewEventHandler } from './viewEventHandler';\nimport { VerticalRevealType } from './viewEvents';\n\nexport interface IViewModel extends ICursorSimpleModel {\n\n\treadonly model: ITextModel;\n\n\treadonly coordinatesConverter: ICoordinatesConverter;\n\n\treadonly viewLayout: IViewLayout;\n\n\treadonly cursorConfig: CursorConfiguration;\n\n\treadonly glyphLanes: IGlyphMarginLanesModel;\n\n\taddViewEventHandler(eventHandler: ViewEventHandler): void;\n\tremoveViewEventHandler(eventHandler: ViewEventHandler): void;\n\n\t/**\n\t * Gives a hint that a lot of requests are about to come in for these line numbers.\n\t */\n\tsetViewport(startLineNumber: number, endLineNumber: number, centeredLineNumber: number): void;\n\tvisibleLinesStabilized(): void;\n\tsetHasFocus(hasFocus: boolean): void;\n\tonCompositionStart(): void;\n\tonCompositionEnd(): void;\n\n\tgetMinimapDecorationsInRange(range: Range): ViewModelDecoration[];\n\tgetDecorationsInViewport(visibleRange: Range): ViewModelDecoration[];\n\tgetViewportViewLineRenderingData(visibleRange: Range, lineNumber: number): ViewLineRenderingData;\n\tgetViewLineRenderingData(lineNumber: number): ViewLineRenderingData;\n\tgetViewLineData(lineNumber: number): ViewLineData;\n\tgetMinimapLinesRenderingData(startLineNumber: number, endLineNumber: number, needed: boolean[]): MinimapLinesRenderingData;\n\tgetCompletelyVisibleViewRange(): Range;\n\tgetCompletelyVisibleViewRangeAtScrollTop(scrollTop: number): Range;\n\n\tgetHiddenAreas(): Range[];\n\n\tgetLineCount(): number;\n\tgetLineContent(lineNumber: number): string;\n\tgetLineLength(lineNumber: number): number;\n\tgetActiveIndentGuide(lineNumber: number, minLineNumber: number, maxLineNumber: number): IActiveIndentGuideInfo;\n\tgetLinesIndentGuides(startLineNumber: number, endLineNumber: number): number[];\n\tgetBracketGuidesInRangeByLine(startLineNumber: number, endLineNumber: number, activePosition: IPosition | null, options: BracketGuideOptions): IndentGuide[][];\n\tgetLineMinColumn(lineNumber: number): number;\n\tgetLineMaxColumn(lineNumber: number): number;\n\tgetLineFirstNonWhitespaceColumn(lineNumber: number): number;\n\tgetLineLastNonWhitespaceColumn(lineNumber: number): number;\n\tgetAllOverviewRulerDecorations(theme: EditorTheme): OverviewRulerDecorationsGroup[];\n\tgetValueInRange(range: Range, eol: EndOfLinePreference): string;\n\tgetValueLengthInRange(range: Range, eol: EndOfLinePreference): number;\n\tmodifyPosition(position: Position, offset: number): Position;\n\n\tgetInjectedTextAt(viewPosition: Position): InjectedText | null;\n\n\tdeduceModelPositionRelativeToViewPosition(viewAnchorPosition: Position, deltaOffset: number, lineFeedCnt: number): Position;\n\tgetPlainTextToCopy(modelRanges: Range[], emptySelectionClipboard: boolean, forceCRLF: boolean): string | string[];\n\tgetRichTextToCopy(modelRanges: Range[], emptySelectionClipboard: boolean): { html: string; mode: string } | null;\n\n\tcreateLineBreaksComputer(): ILineBreaksComputer;\n\n\t//#region cursor\n\tgetPrimaryCursorState(): CursorState;\n\tgetLastAddedCursorIndex(): number;\n\tgetCursorStates(): CursorState[];\n\tsetCursorStates(source: string | null | undefined, reason: CursorChangeReason, states: PartialCursorState[] | null): boolean;\n\tgetCursorColumnSelectData(): IColumnSelectData;\n\tgetCursorAutoClosedCharacters(): Range[];\n\tsetCursorColumnSelectData(columnSelectData: IColumnSelectData): void;\n\tgetPrevEditOperationType(): EditOperationType;\n\tsetPrevEditOperationType(type: EditOperationType): void;\n\trevealPrimaryCursor(source: string | null | undefined, revealHorizontal: boolean, minimalReveal?: boolean): void;\n\trevealTopMostCursor(source: string | null | undefined): void;\n\trevealBottomMostCursor(source: string | null | undefined): void;\n\trevealRange(source: string | null | undefined, revealHorizontal: boolean, viewRange: Range, verticalType: VerticalRevealType, scrollType: ScrollType): void;\n\t//#endregion\n\n\t//#region viewLayout\n\tchangeWhitespace(callback: (accessor: IWhitespaceChangeAccessor) => void): void;\n\t//#endregion\n}\n\nexport interface IViewLayout {\n\n\tgetScrollable(): Scrollable;\n\n\tgetScrollWidth(): number;\n\tgetScrollHeight(): number;\n\n\tgetCurrentScrollLeft(): number;\n\tgetCurrentScrollTop(): number;\n\tgetCurrentViewport(): Viewport;\n\n\tgetFutureViewport(): Viewport;\n\n\tsetScrollPosition(position: INewScrollPosition, type: ScrollType): void;\n\tdeltaScrollNow(deltaScrollLeft: number, deltaScrollTop: number): void;\n\n\tvalidateScrollPosition(scrollPosition: INewScrollPosition): IScrollPosition;\n\n\tsetMaxLineWidth(maxLineWidth: number): void;\n\tsetOverlayWidgetsMinWidth(overlayWidgetsMinWidth: number): void;\n\n\tgetLinesViewportData(): IPartialViewLinesViewportData;\n\tgetLinesViewportDataAtScrollTop(scrollTop: number): IPartialViewLinesViewportData;\n\tgetWhitespaces(): IEditorWhitespace[];\n\n\tisAfterLines(verticalOffset: number): boolean;\n\tisInTopPadding(verticalOffset: number): boolean;\n\tisInBottomPadding(verticalOffset: number): boolean;\n\tgetLineNumberAtVerticalOffset(verticalOffset: number): number;\n\tgetVerticalOffsetForLineNumber(lineNumber: number, includeViewZones?: boolean): number;\n\tgetVerticalOffsetAfterLineNumber(lineNumber: number, includeViewZones?: boolean): number;\n\tgetWhitespaceAtVerticalOffset(verticalOffset: number): IViewWhitespaceViewportData | null;\n\n\t/**\n\t * Get the layout information for whitespaces currently in the viewport\n\t */\n\tgetWhitespaceViewportData(): IViewWhitespaceViewportData[];\n}\n\nexport interface IEditorWhitespace {\n\treadonly id: string;\n\treadonly afterLineNumber: number;\n\treadonly height: number;\n}\n\n/**\n * An accessor that allows for whitespace to be added, removed or changed in bulk.\n */\nexport interface IWhitespaceChangeAccessor {\n\tinsertWhitespace(afterLineNumber: number, ordinal: number, heightInPx: number, minWidth: number): string;\n\tchangeOneWhitespace(id: string, newAfterLineNumber: number, newHeight: number): void;\n\tremoveWhitespace(id: string): void;\n}\n\nexport interface IPartialViewLinesViewportData {\n\t/**\n\t * Value to be substracted from `scrollTop` (in order to vertical offset numbers < 1MM)\n\t */\n\treadonly bigNumbersDelta: number;\n\t/**\n\t * The first (partially) visible line number.\n\t */\n\treadonly startLineNumber: number;\n\t/**\n\t * The last (partially) visible line number.\n\t */\n\treadonly endLineNumber: number;\n\t/**\n\t * relativeVerticalOffset[i] is the `top` position for line at `i` + `startLineNumber`.\n\t */\n\treadonly relativeVerticalOffset: number[];\n\t/**\n\t * The centered line in the viewport.\n\t */\n\treadonly centeredLineNumber: number;\n\t/**\n\t * The first completely visible line number.\n\t */\n\treadonly completelyVisibleStartLineNumber: number;\n\t/**\n\t * The last completely visible line number.\n\t */\n\treadonly completelyVisibleEndLineNumber: number;\n}\n\nexport interface IViewWhitespaceViewportData {\n\treadonly id: string;\n\treadonly afterLineNumber: number;\n\treadonly verticalOffset: number;\n\treadonly height: number;\n}\n\nexport class Viewport {\n\treadonly _viewportBrand: void = undefined;\n\n\treadonly top: number;\n\treadonly left: number;\n\treadonly width: number;\n\treadonly height: number;\n\n\tconstructor(top: number, left: number, width: number, height: number) {\n\t\tthis.top = top | 0;\n\t\tthis.left = left | 0;\n\t\tthis.width = width | 0;\n\t\tthis.height = height | 0;\n\t}\n}\n\nexport interface ICoordinatesConverter {\n\t// View -> Model conversion and related methods\n\tconvertViewPositionToModelPosition(viewPosition: Position): Position;\n\tconvertViewRangeToModelRange(viewRange: Range): Range;\n\tvalidateViewPosition(viewPosition: Position, expectedModelPosition: Position): Position;\n\tvalidateViewRange(viewRange: Range, expectedModelRange: Range): Range;\n\n\t// Model -> View conversion and related methods\n\t/**\n\t * @param allowZeroLineNumber Should it return 0 when there are hidden lines at the top and the position is in the hidden area?\n\t * @param belowHiddenRanges When the model position is in a hidden area, should it return the first view position after or before?\n\t */\n\tconvertModelPositionToViewPosition(modelPosition: Position, affinity?: PositionAffinity, allowZeroLineNumber?: boolean, belowHiddenRanges?: boolean): Position;\n\t/**\n\t * @param affinity Only has an effect if the range is empty.\n\t*/\n\tconvertModelRangeToViewRange(modelRange: Range, affinity?: PositionAffinity): Range;\n\tmodelPositionIsVisible(modelPosition: Position): boolean;\n\tgetModelLineViewLineCount(modelLineNumber: number): number;\n\tgetViewLineNumberOfModelPosition(modelLineNumber: number, modelColumn: number): number;\n}\n\nexport class MinimapLinesRenderingData {\n\tpublic readonly tabSize: number;\n\tpublic readonly data: Array<ViewLineData | null>;\n\n\tconstructor(\n\t\ttabSize: number,\n\t\tdata: Array<ViewLineData | null>\n\t) {\n\t\tthis.tabSize = tabSize;\n\t\tthis.data = data;\n\t}\n}\n\nexport class ViewLineData {\n\t_viewLineDataBrand: void = undefined;\n\n\t/**\n\t * The content at this view line.\n\t */\n\tpublic readonly content: string;\n\t/**\n\t * Does this line continue with a wrapped line?\n\t */\n\tpublic readonly continuesWithWrappedLine: boolean;\n\t/**\n\t * The minimum allowed column at this view line.\n\t */\n\tpublic readonly minColumn: number;\n\t/**\n\t * The maximum allowed column at this view line.\n\t */\n\tpublic readonly maxColumn: number;\n\t/**\n\t * The visible column at the start of the line (after the fauxIndent).\n\t */\n\tpublic readonly startVisibleColumn: number;\n\t/**\n\t * The tokens at this view line.\n\t */\n\tpublic readonly tokens: IViewLineTokens;\n\n\t/**\n\t * Additional inline decorations for this line.\n\t*/\n\tpublic readonly inlineDecorations: readonly SingleLineInlineDecoration[] | null;\n\n\tconstructor(\n\t\tcontent: string,\n\t\tcontinuesWithWrappedLine: boolean,\n\t\tminColumn: number,\n\t\tmaxColumn: number,\n\t\tstartVisibleColumn: number,\n\t\ttokens: IViewLineTokens,\n\t\tinlineDecorations: readonly SingleLineInlineDecoration[] | null\n\t) {\n\t\tthis.content = content;\n\t\tthis.continuesWithWrappedLine = continuesWithWrappedLine;\n\t\tthis.minColumn = minColumn;\n\t\tthis.maxColumn = maxColumn;\n\t\tthis.startVisibleColumn = startVisibleColumn;\n\t\tthis.tokens = tokens;\n\t\tthis.inlineDecorations = inlineDecorations;\n\t}\n}\n\nexport class ViewLineRenderingData {\n\t/**\n\t * The minimum allowed column at this view line.\n\t */\n\tpublic readonly minColumn: number;\n\t/**\n\t * The maximum allowed column at this view line.\n\t */\n\tpublic readonly maxColumn: number;\n\t/**\n\t * The content at this view line.\n\t */\n\tpublic readonly content: string;\n\t/**\n\t * Does this line continue with a wrapped line?\n\t */\n\tpublic readonly continuesWithWrappedLine: boolean;\n\t/**\n\t * Describes if `content` contains RTL characters.\n\t */\n\tpublic readonly containsRTL: boolean;\n\t/**\n\t * Describes if `content` contains non basic ASCII chars.\n\t */\n\tpublic readonly isBasicASCII: boolean;\n\t/**\n\t * The tokens at this view line.\n\t */\n\tpublic readonly tokens: IViewLineTokens;\n\t/**\n\t * Inline decorations at this view line.\n\t */\n\tpublic readonly inlineDecorations: InlineDecoration[];\n\t/**\n\t * The tab size for this view model.\n\t */\n\tpublic readonly tabSize: number;\n\t/**\n\t * The visible column at the start of the line (after the fauxIndent)\n\t */\n\tpublic readonly startVisibleColumn: number;\n\n\tconstructor(\n\t\tminColumn: number,\n\t\tmaxColumn: number,\n\t\tcontent: string,\n\t\tcontinuesWithWrappedLine: boolean,\n\t\tmightContainRTL: boolean,\n\t\tmightContainNonBasicASCII: boolean,\n\t\ttokens: IViewLineTokens,\n\t\tinlineDecorations: InlineDecoration[],\n\t\ttabSize: number,\n\t\tstartVisibleColumn: number,\n\t) {\n\t\tthis.minColumn = minColumn;\n\t\tthis.maxColumn = maxColumn;\n\t\tthis.content = content;\n\t\tthis.continuesWithWrappedLine = continuesWithWrappedLine;\n\n\t\tthis.isBasicASCII = ViewLineRenderingData.isBasicASCII(content, mightContainNonBasicASCII);\n\t\tthis.containsRTL = ViewLineRenderingData.containsRTL(content, this.isBasicASCII, mightContainRTL);\n\n\t\tthis.tokens = tokens;\n\t\tthis.inlineDecorations = inlineDecorations;\n\t\tthis.tabSize = tabSize;\n\t\tthis.startVisibleColumn = startVisibleColumn;\n\t}\n\n\tpublic static isBasicASCII(lineContent: string, mightContainNonBasicASCII: boolean): boolean {\n\t\tif (mightContainNonBasicASCII) {\n\t\t\treturn strings.isBasicASCII(lineContent);\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static containsRTL(lineContent: string, isBasicASCII: boolean, mightContainRTL: boolean): boolean {\n\t\tif (!isBasicASCII && mightContainRTL) {\n\t\t\treturn strings.containsRTL(lineContent);\n\t\t}\n\t\treturn false;\n\t}\n}\n\nexport const enum InlineDecorationType {\n\tRegular = 0,\n\tBefore = 1,\n\tAfter = 2,\n\tRegularAffectingLetterSpacing = 3\n}\n\nexport class InlineDecoration {\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly inlineClassName: string,\n\t\tpublic readonly type: InlineDecorationType\n\t) {\n\t}\n}\n\nexport class SingleLineInlineDecoration {\n\tconstructor(\n\t\tpublic readonly startOffset: number,\n\t\tpublic readonly endOffset: number,\n\t\tpublic readonly inlineClassName: string,\n\t\tpublic readonly inlineClassNameAffectsLetterSpacing: boolean\n\t) {\n\t}\n\n\ttoInlineDecoration(lineNumber: number): InlineDecoration {\n\t\treturn new InlineDecoration(\n\t\t\tnew Range(lineNumber, this.startOffset + 1, lineNumber, this.endOffset + 1),\n\t\t\tthis.inlineClassName,\n\t\t\tthis.inlineClassNameAffectsLetterSpacing ? InlineDecorationType.RegularAffectingLetterSpacing : InlineDecorationType.Regular\n\t\t);\n\t}\n}\n\nexport class ViewModelDecoration {\n\t_viewModelDecorationBrand: void = undefined;\n\n\tpublic readonly range: Range;\n\tpublic readonly options: IModelDecorationOptions;\n\n\tconstructor(range: Range, options: IModelDecorationOptions) {\n\t\tthis.range = range;\n\t\tthis.options = options;\n\t}\n}\n\nexport class OverviewRulerDecorationsGroup {\n\n\tconstructor(\n\t\tpublic readonly color: string,\n\t\tpublic readonly zIndex: number,\n\t\t/**\n\t\t * Decorations are encoded in a number array using the following scheme:\n\t\t *  - 3*i = lane\n\t\t *  - 3*i+1 = startLineNumber\n\t\t *  - 3*i+2 = endLineNumber\n\t\t */\n\t\tpublic readonly data: number[]\n\t) { }\n\n\tpublic static compareByRenderingProps(a: OverviewRulerDecorationsGroup, b: OverviewRulerDecorationsGroup): number {\n\t\tif (a.zIndex === b.zIndex) {\n\t\t\tif (a.color < b.color) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (a.color > b.color) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\treturn a.zIndex - b.zIndex;\n\t}\n\n\tpublic static equals(a: OverviewRulerDecorationsGroup, b: OverviewRulerDecorationsGroup): boolean {\n\t\treturn (\n\t\t\ta.color === b.color\n\t\t\t&& a.zIndex === b.zIndex\n\t\t\t&& arrays.equals(a.data, b.data)\n\t\t);\n\t}\n\n\tpublic static equalsArr(a: OverviewRulerDecorationsGroup[], b: OverviewRulerDecorationsGroup[]): boolean {\n\t\treturn arrays.equals(a, b, OverviewRulerDecorationsGroup.equals);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from '../../base/common/arrays';\nimport { IScrollPosition, Scrollable } from '../../base/common/scrollable';\nimport * as strings from '../../base/common/strings';\nimport { IPosition, Position } from './core/position';\nimport { Range } from './core/range';\nimport { CursorConfiguration, CursorState, EditOperationType, IColumnSelectData, ICursorSimpleModel, PartialCursorState } from './cursorCommon';\nimport { CursorChangeReason } from './cursorEvents';\nimport { INewScrollPosition, ScrollType } from './editorCommon';\nimport { EditorTheme } from './editorTheme';\nimport { EndOfLinePreference, IGlyphMarginLanesModel, IModelDecorationOptions, ITextModel, PositionAffinity } from './model';\nimport { ILineBreaksComputer, InjectedText } from './modelLineProjectionData';\nimport { BracketGuideOptions, IActiveIndentGuideInfo, IndentGuide } from './textModelGuides';\nimport { IViewLineTokens } from './tokens/lineTokens';\nimport { ViewEventHandler } from './viewEventHandler';\nimport { VerticalRevealType } from './viewEvents';\n\nexport interface IViewModel extends ICursorSimpleModel {\n\n\treadonly model: ITextModel;\n\n\treadonly coordinatesConverter: ICoordinatesConverter;\n\n\treadonly viewLayout: IViewLayout;\n\n\treadonly cursorConfig: CursorConfiguration;\n\n\treadonly glyphLanes: IGlyphMarginLanesModel;\n\n\taddViewEventHandler(eventHandler: ViewEventHandler): void;\n\tremoveViewEventHandler(eventHandler: ViewEventHandler): void;\n\n\t/**\n\t * Gives a hint that a lot of requests are about to come in for these line numbers.\n\t */\n\tsetViewport(startLineNumber: number, endLineNumber: number, centeredLineNumber: number): void;\n\tvisibleLinesStabilized(): void;\n\tsetHasFocus(hasFocus: boolean): void;\n\tonCompositionStart(): void;\n\tonCompositionEnd(): void;\n\n\tgetMinimapDecorationsInRange(range: Range): ViewModelDecoration[];\n\tgetDecorationsInViewport(visibleRange: Range): ViewModelDecoration[];\n\tgetViewportViewLineRenderingData(visibleRange: Range, lineNumber: number): ViewLineRenderingData;\n\tgetViewLineRenderingData(lineNumber: number): ViewLineRenderingData;\n\tgetViewLineData(lineNumber: number): ViewLineData;\n\tgetMinimapLinesRenderingData(startLineNumber: number, endLineNumber: number, needed: boolean[]): MinimapLinesRenderingData;\n\tgetCompletelyVisibleViewRange(): Range;\n\tgetCompletelyVisibleViewRangeAtScrollTop(scrollTop: number): Range;\n\n\tgetHiddenAreas(): Range[];\n\n\tgetLineCount(): number;\n\tgetLineContent(lineNumber: number): string;\n\tgetLineLength(lineNumber: number): number;\n\tgetActiveIndentGuide(lineNumber: number, minLineNumber: number, maxLineNumber: number): IActiveIndentGuideInfo;\n\tgetLinesIndentGuides(startLineNumber: number, endLineNumber: number): number[];\n\tgetBracketGuidesInRangeByLine(startLineNumber: number, endLineNumber: number, activePosition: IPosition | null, options: BracketGuideOptions): IndentGuide[][];\n\tgetLineMinColumn(lineNumber: number): number;\n\tgetLineMaxColumn(lineNumber: number): number;\n\tgetLineFirstNonWhitespaceColumn(lineNumber: number): number;\n\tgetLineLastNonWhitespaceColumn(lineNumber: number): number;\n\tgetAllOverviewRulerDecorations(theme: EditorTheme): OverviewRulerDecorationsGroup[];\n\tgetValueInRange(range: Range, eol: EndOfLinePreference): string;\n\tgetValueLengthInRange(range: Range, eol: EndOfLinePreference): number;\n\tmodifyPosition(position: Position, offset: number): Position;\n\n\tgetInjectedTextAt(viewPosition: Position): InjectedText | null;\n\n\tdeduceModelPositionRelativeToViewPosition(viewAnchorPosition: Position, deltaOffset: number, lineFeedCnt: number): Position;\n\tgetPlainTextToCopy(modelRanges: Range[], emptySelectionClipboard: boolean, forceCRLF: boolean): string | string[];\n\tgetRichTextToCopy(modelRanges: Range[], emptySelectionClipboard: boolean): { html: string; mode: string } | null;\n\n\tcreateLineBreaksComputer(): ILineBreaksComputer;\n\n\t//#region cursor\n\tgetPrimaryCursorState(): CursorState;\n\tgetLastAddedCursorIndex(): number;\n\tgetCursorStates(): CursorState[];\n\tsetCursorStates(source: string | null | undefined, reason: CursorChangeReason, states: PartialCursorState[] | null): boolean;\n\tgetCursorColumnSelectData(): IColumnSelectData;\n\tgetCursorAutoClosedCharacters(): Range[];\n\tsetCursorColumnSelectData(columnSelectData: IColumnSelectData): void;\n\tgetPrevEditOperationType(): EditOperationType;\n\tsetPrevEditOperationType(type: EditOperationType): void;\n\trevealPrimaryCursor(source: string | null | undefined, revealHorizontal: boolean, minimalReveal?: boolean): void;\n\trevealTopMostCursor(source: string | null | undefined): void;\n\trevealBottomMostCursor(source: string | null | undefined): void;\n\trevealRange(source: string | null | undefined, revealHorizontal: boolean, viewRange: Range, verticalType: VerticalRevealType, scrollType: ScrollType): void;\n\t//#endregion\n\n\t//#region viewLayout\n\tchangeWhitespace(callback: (accessor: IWhitespaceChangeAccessor) => void): void;\n\t//#endregion\n}\n\nexport interface IViewLayout {\n\n\tgetScrollable(): Scrollable;\n\n\tgetScrollWidth(): number;\n\tgetScrollHeight(): number;\n\n\tgetCurrentScrollLeft(): number;\n\tgetCurrentScrollTop(): number;\n\tgetCurrentViewport(): Viewport;\n\n\tgetFutureViewport(): Viewport;\n\n\tsetScrollPosition(position: INewScrollPosition, type: ScrollType): void;\n\tdeltaScrollNow(deltaScrollLeft: number, deltaScrollTop: number): void;\n\n\tvalidateScrollPosition(scrollPosition: INewScrollPosition): IScrollPosition;\n\n\tsetMaxLineWidth(maxLineWidth: number): void;\n\tsetOverlayWidgetsMinWidth(overlayWidgetsMinWidth: number): void;\n\n\tgetLinesViewportData(): IPartialViewLinesViewportData;\n\tgetLinesViewportDataAtScrollTop(scrollTop: number): IPartialViewLinesViewportData;\n\tgetWhitespaces(): IEditorWhitespace[];\n\n\tisAfterLines(verticalOffset: number): boolean;\n\tisInTopPadding(verticalOffset: number): boolean;\n\tisInBottomPadding(verticalOffset: number): boolean;\n\tgetLineNumberAtVerticalOffset(verticalOffset: number): number;\n\tgetVerticalOffsetForLineNumber(lineNumber: number, includeViewZones?: boolean): number;\n\tgetVerticalOffsetAfterLineNumber(lineNumber: number, includeViewZones?: boolean): number;\n\tgetWhitespaceAtVerticalOffset(verticalOffset: number): IViewWhitespaceViewportData | null;\n\n\t/**\n\t * Get the layout information for whitespaces currently in the viewport\n\t */\n\tgetWhitespaceViewportData(): IViewWhitespaceViewportData[];\n}\n\nexport interface IEditorWhitespace {\n\treadonly id: string;\n\treadonly afterLineNumber: number;\n\treadonly height: number;\n}\n\n/**\n * An accessor that allows for whitespace to be added, removed or changed in bulk.\n */\nexport interface IWhitespaceChangeAccessor {\n\tinsertWhitespace(afterLineNumber: number, ordinal: number, heightInPx: number, minWidth: number): string;\n\tchangeOneWhitespace(id: string, newAfterLineNumber: number, newHeight: number): void;\n\tremoveWhitespace(id: string): void;\n}\n\nexport interface IPartialViewLinesViewportData {\n\t/**\n\t * Value to be substracted from `scrollTop` (in order to vertical offset numbers < 1MM)\n\t */\n\treadonly bigNumbersDelta: number;\n\t/**\n\t * The first (partially) visible line number.\n\t */\n\treadonly startLineNumber: number;\n\t/**\n\t * The last (partially) visible line number.\n\t */\n\treadonly endLineNumber: number;\n\t/**\n\t * relativeVerticalOffset[i] is the `top` position for line at `i` + `startLineNumber`.\n\t */\n\treadonly relativeVerticalOffset: number[];\n\t/**\n\t * The centered line in the viewport.\n\t */\n\treadonly centeredLineNumber: number;\n\t/**\n\t * The first completely visible line number.\n\t */\n\treadonly completelyVisibleStartLineNumber: number;\n\t/**\n\t * The last completely visible line number.\n\t */\n\treadonly completelyVisibleEndLineNumber: number;\n}\n\nexport interface IViewWhitespaceViewportData {\n\treadonly id: string;\n\treadonly afterLineNumber: number;\n\treadonly verticalOffset: number;\n\treadonly height: number;\n}\n\nexport class Viewport {\n\treadonly _viewportBrand: void = undefined;\n\n\treadonly top: number;\n\treadonly left: number;\n\treadonly width: number;\n\treadonly height: number;\n\n\tconstructor(top: number, left: number, width: number, height: number) {\n\t\tthis.top = top | 0;\n\t\tthis.left = left | 0;\n\t\tthis.width = width | 0;\n\t\tthis.height = height | 0;\n\t}\n}\n\nexport interface ICoordinatesConverter {\n\t// View -> Model conversion and related methods\n\tconvertViewPositionToModelPosition(viewPosition: Position): Position;\n\tconvertViewRangeToModelRange(viewRange: Range): Range;\n\tvalidateViewPosition(viewPosition: Position, expectedModelPosition: Position): Position;\n\tvalidateViewRange(viewRange: Range, expectedModelRange: Range): Range;\n\n\t// Model -> View conversion and related methods\n\t/**\n\t * @param allowZeroLineNumber Should it return 0 when there are hidden lines at the top and the position is in the hidden area?\n\t * @param belowHiddenRanges When the model position is in a hidden area, should it return the first view position after or before?\n\t */\n\tconvertModelPositionToViewPosition(modelPosition: Position, affinity?: PositionAffinity, allowZeroLineNumber?: boolean, belowHiddenRanges?: boolean): Position;\n\t/**\n\t * @param affinity Only has an effect if the range is empty.\n\t*/\n\tconvertModelRangeToViewRange(modelRange: Range, affinity?: PositionAffinity): Range;\n\tmodelPositionIsVisible(modelPosition: Position): boolean;\n\tgetModelLineViewLineCount(modelLineNumber: number): number;\n\tgetViewLineNumberOfModelPosition(modelLineNumber: number, modelColumn: number): number;\n}\n\nexport class MinimapLinesRenderingData {\n\tpublic readonly tabSize: number;\n\tpublic readonly data: Array<ViewLineData | null>;\n\n\tconstructor(\n\t\ttabSize: number,\n\t\tdata: Array<ViewLineData | null>\n\t) {\n\t\tthis.tabSize = tabSize;\n\t\tthis.data = data;\n\t}\n}\n\nexport class ViewLineData {\n\t_viewLineDataBrand: void = undefined;\n\n\t/**\n\t * The content at this view line.\n\t */\n\tpublic readonly content: string;\n\t/**\n\t * Does this line continue with a wrapped line?\n\t */\n\tpublic readonly continuesWithWrappedLine: boolean;\n\t/**\n\t * The minimum allowed column at this view line.\n\t */\n\tpublic readonly minColumn: number;\n\t/**\n\t * The maximum allowed column at this view line.\n\t */\n\tpublic readonly maxColumn: number;\n\t/**\n\t * The visible column at the start of the line (after the fauxIndent).\n\t */\n\tpublic readonly startVisibleColumn: number;\n\t/**\n\t * The tokens at this view line.\n\t */\n\tpublic readonly tokens: IViewLineTokens;\n\n\t/**\n\t * Additional inline decorations for this line.\n\t*/\n\tpublic readonly inlineDecorations: readonly SingleLineInlineDecoration[] | null;\n\n\tconstructor(\n\t\tcontent: string,\n\t\tcontinuesWithWrappedLine: boolean,\n\t\tminColumn: number,\n\t\tmaxColumn: number,\n\t\tstartVisibleColumn: number,\n\t\ttokens: IViewLineTokens,\n\t\tinlineDecorations: readonly SingleLineInlineDecoration[] | null\n\t) {\n\t\tthis.content = content;\n\t\tthis.continuesWithWrappedLine = continuesWithWrappedLine;\n\t\tthis.minColumn = minColumn;\n\t\tthis.maxColumn = maxColumn;\n\t\tthis.startVisibleColumn = startVisibleColumn;\n\t\tthis.tokens = tokens;\n\t\tthis.inlineDecorations = inlineDecorations;\n\t}\n}\n\nexport class ViewLineRenderingData {\n\t/**\n\t * The minimum allowed column at this view line.\n\t */\n\tpublic readonly minColumn: number;\n\t/**\n\t * The maximum allowed column at this view line.\n\t */\n\tpublic readonly maxColumn: number;\n\t/**\n\t * The content at this view line.\n\t */\n\tpublic readonly content: string;\n\t/**\n\t * Does this line continue with a wrapped line?\n\t */\n\tpublic readonly continuesWithWrappedLine: boolean;\n\t/**\n\t * Describes if `content` contains RTL characters.\n\t */\n\tpublic readonly containsRTL: boolean;\n\t/**\n\t * Describes if `content` contains non basic ASCII chars.\n\t */\n\tpublic readonly isBasicASCII: boolean;\n\t/**\n\t * The tokens at this view line.\n\t */\n\tpublic readonly tokens: IViewLineTokens;\n\t/**\n\t * Inline decorations at this view line.\n\t */\n\tpublic readonly inlineDecorations: InlineDecoration[];\n\t/**\n\t * The tab size for this view model.\n\t */\n\tpublic readonly tabSize: number;\n\t/**\n\t * The visible column at the start of the line (after the fauxIndent)\n\t */\n\tpublic readonly startVisibleColumn: number;\n\n\tconstructor(\n\t\tminColumn: number,\n\t\tmaxColumn: number,\n\t\tcontent: string,\n\t\tcontinuesWithWrappedLine: boolean,\n\t\tmightContainRTL: boolean,\n\t\tmightContainNonBasicASCII: boolean,\n\t\ttokens: IViewLineTokens,\n\t\tinlineDecorations: InlineDecoration[],\n\t\ttabSize: number,\n\t\tstartVisibleColumn: number,\n\t) {\n\t\tthis.minColumn = minColumn;\n\t\tthis.maxColumn = maxColumn;\n\t\tthis.content = content;\n\t\tthis.continuesWithWrappedLine = continuesWithWrappedLine;\n\n\t\tthis.isBasicASCII = ViewLineRenderingData.isBasicASCII(content, mightContainNonBasicASCII);\n\t\tthis.containsRTL = ViewLineRenderingData.containsRTL(content, this.isBasicASCII, mightContainRTL);\n\n\t\tthis.tokens = tokens;\n\t\tthis.inlineDecorations = inlineDecorations;\n\t\tthis.tabSize = tabSize;\n\t\tthis.startVisibleColumn = startVisibleColumn;\n\t}\n\n\tpublic static isBasicASCII(lineContent: string, mightContainNonBasicASCII: boolean): boolean {\n\t\tif (mightContainNonBasicASCII) {\n\t\t\treturn strings.isBasicASCII(lineContent);\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static containsRTL(lineContent: string, isBasicASCII: boolean, mightContainRTL: boolean): boolean {\n\t\tif (!isBasicASCII && mightContainRTL) {\n\t\t\treturn strings.containsRTL(lineContent);\n\t\t}\n\t\treturn false;\n\t}\n}\n\nexport const enum InlineDecorationType {\n\tRegular = 0,\n\tBefore = 1,\n\tAfter = 2,\n\tRegularAffectingLetterSpacing = 3\n}\n\nexport class InlineDecoration {\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly inlineClassName: string,\n\t\tpublic readonly type: InlineDecorationType\n\t) {\n\t}\n}\n\nexport class SingleLineInlineDecoration {\n\tconstructor(\n\t\tpublic readonly startOffset: number,\n\t\tpublic readonly endOffset: number,\n\t\tpublic readonly inlineClassName: string,\n\t\tpublic readonly inlineClassNameAffectsLetterSpacing: boolean\n\t) {\n\t}\n\n\ttoInlineDecoration(lineNumber: number): InlineDecoration {\n\t\treturn new InlineDecoration(\n\t\t\tnew Range(lineNumber, this.startOffset + 1, lineNumber, this.endOffset + 1),\n\t\t\tthis.inlineClassName,\n\t\t\tthis.inlineClassNameAffectsLetterSpacing ? InlineDecorationType.RegularAffectingLetterSpacing : InlineDecorationType.Regular\n\t\t);\n\t}\n}\n\nexport class ViewModelDecoration {\n\t_viewModelDecorationBrand: void = undefined;\n\n\tpublic readonly range: Range;\n\tpublic readonly options: IModelDecorationOptions;\n\n\tconstructor(range: Range, options: IModelDecorationOptions) {\n\t\tthis.range = range;\n\t\tthis.options = options;\n\t}\n}\n\nexport class OverviewRulerDecorationsGroup {\n\n\tconstructor(\n\t\tpublic readonly color: string,\n\t\tpublic readonly zIndex: number,\n\t\t/**\n\t\t * Decorations are encoded in a number array using the following scheme:\n\t\t *  - 3*i = lane\n\t\t *  - 3*i+1 = startLineNumber\n\t\t *  - 3*i+2 = endLineNumber\n\t\t */\n\t\tpublic readonly data: number[]\n\t) { }\n\n\tpublic static compareByRenderingProps(a: OverviewRulerDecorationsGroup, b: OverviewRulerDecorationsGroup): number {\n\t\tif (a.zIndex === b.zIndex) {\n\t\t\tif (a.color < b.color) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (a.color > b.color) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\treturn a.zIndex - b.zIndex;\n\t}\n\n\tpublic static equals(a: OverviewRulerDecorationsGroup, b: OverviewRulerDecorationsGroup): boolean {\n\t\treturn (\n\t\t\ta.color === b.color\n\t\t\t&& a.zIndex === b.zIndex\n\t\t\t&& arrays.equals(a.data, b.data)\n\t\t);\n\t}\n\n\tpublic static equalsArr(a: OverviewRulerDecorationsGroup[], b: OverviewRulerDecorationsGroup[]): boolean {\n\t\treturn arrays.equals(a, b, OverviewRulerDecorationsGroup.equals);\n\t}\n}\n"]}