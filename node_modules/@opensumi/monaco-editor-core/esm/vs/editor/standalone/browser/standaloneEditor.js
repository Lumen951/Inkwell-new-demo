"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMonacoEditorAPI = exports.registerEditorOpener = exports.registerLinkOpener = exports.registerCommand = exports.remeasureFonts = exports.setTheme = exports.defineTheme = exports.tokenize = exports.colorizeModelLine = exports.colorize = exports.colorizeElement = exports.createWebWorker = exports.onDidChangeModelLanguage = exports.onWillDisposeModel = exports.onDidCreateModel = exports.getModels = exports.getModel = exports.onDidChangeMarkers = exports.getModelMarkers = exports.removeAllMarkers = exports.setModelMarkers = exports.setModelLanguage = exports.createModel = exports.addKeybindingRules = exports.addKeybindingRule = exports.addEditorAction = exports.addCommand = exports.createMultiFileDiffEditor = exports.createDiffEditor = exports.getDiffEditors = exports.getEditors = exports.onDidCreateDiffEditor = exports.onDidCreateEditor = exports.create = void 0;
const window_1 = require("../../../base/browser/window");
const lifecycle_1 = require("../../../base/common/lifecycle");
const strings_1 = require("../../../base/common/strings");
const uri_1 = require("../../../base/common/uri");
require("./standalone-tokens.css");
const fontMeasurements_1 = require("../../browser/config/fontMeasurements");
const editorExtensions_1 = require("../../browser/editorExtensions");
const codeEditorService_1 = require("../../browser/services/codeEditorService");
const webWorker_1 = require("../../browser/services/webWorker");
const editorOptions_1 = require("../../common/config/editorOptions");
const editorZoom_1 = require("../../common/config/editorZoom");
const fontInfo_1 = require("../../common/config/fontInfo");
const editorCommon_1 = require("../../common/editorCommon");
const languages = require("../../common/languages");
const language_1 = require("../../common/languages/language");
const languageConfigurationRegistry_1 = require("../../common/languages/languageConfigurationRegistry");
const modesRegistry_1 = require("../../common/languages/modesRegistry");
const nullTokenize_1 = require("../../common/languages/nullTokenize");
const model_1 = require("../../common/model");
const model_2 = require("../../common/services/model");
const standaloneEnums = require("../../common/standalone/standaloneEnums");
const colorizer_1 = require("./colorizer");
const standaloneCodeEditor_1 = require("./standaloneCodeEditor");
const standaloneServices_1 = require("./standaloneServices");
const standaloneTheme_1 = require("../common/standaloneTheme");
const actions_1 = require("../../../platform/actions/common/actions");
const commands_1 = require("../../../platform/commands/common/commands");
const contextkey_1 = require("../../../platform/contextkey/common/contextkey");
const keybinding_1 = require("../../../platform/keybinding/common/keybinding");
const markers_1 = require("../../../platform/markers/common/markers");
const opener_1 = require("../../../platform/opener/common/opener");
const multiDiffEditorWidget_1 = require("../../browser/widget/multiDiffEditorWidget/multiDiffEditorWidget");
/**
 * Create a new editor under `domElement`.
 * `domElement` should be empty (not contain other dom nodes).
 * The editor will read the size of `domElement`.
 */
function create(domElement, options, override) {
    const instantiationService = standaloneServices_1.StandaloneServices.initialize(override || {});
    return instantiationService.createInstance(standaloneCodeEditor_1.StandaloneEditor, domElement, options);
}
exports.create = create;
/**
 * Emitted when an editor is created.
 * Creating a diff editor might cause this listener to be invoked with the two editors.
 * @event
 */
function onDidCreateEditor(listener) {
    const codeEditorService = standaloneServices_1.StandaloneServices.get(codeEditorService_1.ICodeEditorService);
    return codeEditorService.onCodeEditorAdd((editor) => {
        listener(editor);
    });
}
exports.onDidCreateEditor = onDidCreateEditor;
/**
 * Emitted when an diff editor is created.
 * @event
 */
function onDidCreateDiffEditor(listener) {
    const codeEditorService = standaloneServices_1.StandaloneServices.get(codeEditorService_1.ICodeEditorService);
    return codeEditorService.onDiffEditorAdd((editor) => {
        listener(editor);
    });
}
exports.onDidCreateDiffEditor = onDidCreateDiffEditor;
/**
 * Get all the created editors.
 */
function getEditors() {
    const codeEditorService = standaloneServices_1.StandaloneServices.get(codeEditorService_1.ICodeEditorService);
    return codeEditorService.listCodeEditors();
}
exports.getEditors = getEditors;
/**
 * Get all the created diff editors.
 */
function getDiffEditors() {
    const codeEditorService = standaloneServices_1.StandaloneServices.get(codeEditorService_1.ICodeEditorService);
    return codeEditorService.listDiffEditors();
}
exports.getDiffEditors = getDiffEditors;
/**
 * Create a new diff editor under `domElement`.
 * `domElement` should be empty (not contain other dom nodes).
 * The editor will read the size of `domElement`.
 */
function createDiffEditor(domElement, options, override) {
    const instantiationService = standaloneServices_1.StandaloneServices.initialize(override || {});
    return instantiationService.createInstance(standaloneCodeEditor_1.StandaloneDiffEditor2, domElement, options);
}
exports.createDiffEditor = createDiffEditor;
function createMultiFileDiffEditor(domElement, override) {
    const instantiationService = standaloneServices_1.StandaloneServices.initialize(override || {});
    return new multiDiffEditorWidget_1.MultiDiffEditorWidget(domElement, {}, instantiationService);
}
exports.createMultiFileDiffEditor = createMultiFileDiffEditor;
/**
 * Add a command.
 */
function addCommand(descriptor) {
    if ((typeof descriptor.id !== 'string') || (typeof descriptor.run !== 'function')) {
        throw new Error('Invalid command descriptor, `id` and `run` are required properties!');
    }
    return commands_1.CommandsRegistry.registerCommand(descriptor.id, descriptor.run);
}
exports.addCommand = addCommand;
/**
 * Add an action to all editors.
 */
function addEditorAction(descriptor) {
    if ((typeof descriptor.id !== 'string') || (typeof descriptor.label !== 'string') || (typeof descriptor.run !== 'function')) {
        throw new Error('Invalid action descriptor, `id`, `label` and `run` are required properties!');
    }
    const precondition = contextkey_1.ContextKeyExpr.deserialize(descriptor.precondition);
    const run = (accessor, ...args) => {
        return editorExtensions_1.EditorCommand.runEditorCommand(accessor, args, precondition, (accessor, editor, args) => Promise.resolve(descriptor.run(editor, ...args)));
    };
    const toDispose = new lifecycle_1.DisposableStore();
    // Register the command
    toDispose.add(commands_1.CommandsRegistry.registerCommand(descriptor.id, run));
    // Register the context menu item
    if (descriptor.contextMenuGroupId) {
        const menuItem = {
            command: {
                id: descriptor.id,
                title: descriptor.label
            },
            when: precondition,
            group: descriptor.contextMenuGroupId,
            order: descriptor.contextMenuOrder || 0
        };
        toDispose.add(actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.EditorContext, menuItem));
    }
    // Register the keybindings
    if (Array.isArray(descriptor.keybindings)) {
        const keybindingService = standaloneServices_1.StandaloneServices.get(keybinding_1.IKeybindingService);
        if (!(keybindingService instanceof standaloneServices_1.StandaloneKeybindingService)) {
            console.warn('Cannot add keybinding because the editor is configured with an unrecognized KeybindingService');
        }
        else {
            const keybindingsWhen = contextkey_1.ContextKeyExpr.and(precondition, contextkey_1.ContextKeyExpr.deserialize(descriptor.keybindingContext));
            toDispose.add(keybindingService.addDynamicKeybindings(descriptor.keybindings.map((keybinding) => {
                return {
                    keybinding,
                    command: descriptor.id,
                    when: keybindingsWhen
                };
            })));
        }
    }
    return toDispose;
}
exports.addEditorAction = addEditorAction;
/**
 * Add a keybinding rule.
 */
function addKeybindingRule(rule) {
    return addKeybindingRules([rule]);
}
exports.addKeybindingRule = addKeybindingRule;
/**
 * Add keybinding rules.
 */
function addKeybindingRules(rules) {
    const keybindingService = standaloneServices_1.StandaloneServices.get(keybinding_1.IKeybindingService);
    if (!(keybindingService instanceof standaloneServices_1.StandaloneKeybindingService)) {
        console.warn('Cannot add keybinding because the editor is configured with an unrecognized KeybindingService');
        return lifecycle_1.Disposable.None;
    }
    return keybindingService.addDynamicKeybindings(rules.map((rule) => {
        return {
            keybinding: rule.keybinding,
            command: rule.command,
            commandArgs: rule.commandArgs,
            when: contextkey_1.ContextKeyExpr.deserialize(rule.when),
        };
    }));
}
exports.addKeybindingRules = addKeybindingRules;
/**
 * Create a new editor model.
 * You can specify the language that should be set for this model or let the language be inferred from the `uri`.
 */
function createModel(value, language, uri) {
    const languageService = standaloneServices_1.StandaloneServices.get(language_1.ILanguageService);
    const languageId = languageService.getLanguageIdByMimeType(language) || language;
    return (0, standaloneCodeEditor_1.createTextModel)(standaloneServices_1.StandaloneServices.get(model_2.IModelService), languageService, value, languageId, uri);
}
exports.createModel = createModel;
/**
 * Change the language for a model.
 */
function setModelLanguage(model, mimeTypeOrLanguageId) {
    const languageService = standaloneServices_1.StandaloneServices.get(language_1.ILanguageService);
    const languageId = languageService.getLanguageIdByMimeType(mimeTypeOrLanguageId) || mimeTypeOrLanguageId || modesRegistry_1.PLAINTEXT_LANGUAGE_ID;
    model.setLanguage(languageService.createById(languageId));
}
exports.setModelLanguage = setModelLanguage;
/**
 * Set the markers for a model.
 */
function setModelMarkers(model, owner, markers) {
    if (model) {
        const markerService = standaloneServices_1.StandaloneServices.get(markers_1.IMarkerService);
        markerService.changeOne(owner, model.uri, markers);
    }
}
exports.setModelMarkers = setModelMarkers;
/**
 * Remove all markers of an owner.
 */
function removeAllMarkers(owner) {
    const markerService = standaloneServices_1.StandaloneServices.get(markers_1.IMarkerService);
    markerService.changeAll(owner, []);
}
exports.removeAllMarkers = removeAllMarkers;
/**
 * Get markers for owner and/or resource
 *
 * @returns list of markers
 */
function getModelMarkers(filter) {
    const markerService = standaloneServices_1.StandaloneServices.get(markers_1.IMarkerService);
    return markerService.read(filter);
}
exports.getModelMarkers = getModelMarkers;
/**
 * Emitted when markers change for a model.
 * @event
 */
function onDidChangeMarkers(listener) {
    const markerService = standaloneServices_1.StandaloneServices.get(markers_1.IMarkerService);
    return markerService.onMarkerChanged(listener);
}
exports.onDidChangeMarkers = onDidChangeMarkers;
/**
 * Get the model that has `uri` if it exists.
 */
function getModel(uri) {
    const modelService = standaloneServices_1.StandaloneServices.get(model_2.IModelService);
    return modelService.getModel(uri);
}
exports.getModel = getModel;
/**
 * Get all the created models.
 */
function getModels() {
    const modelService = standaloneServices_1.StandaloneServices.get(model_2.IModelService);
    return modelService.getModels();
}
exports.getModels = getModels;
/**
 * Emitted when a model is created.
 * @event
 */
function onDidCreateModel(listener) {
    const modelService = standaloneServices_1.StandaloneServices.get(model_2.IModelService);
    return modelService.onModelAdded(listener);
}
exports.onDidCreateModel = onDidCreateModel;
/**
 * Emitted right before a model is disposed.
 * @event
 */
function onWillDisposeModel(listener) {
    const modelService = standaloneServices_1.StandaloneServices.get(model_2.IModelService);
    return modelService.onModelRemoved(listener);
}
exports.onWillDisposeModel = onWillDisposeModel;
/**
 * Emitted when a different language is set to a model.
 * @event
 */
function onDidChangeModelLanguage(listener) {
    const modelService = standaloneServices_1.StandaloneServices.get(model_2.IModelService);
    return modelService.onModelLanguageChanged((e) => {
        listener({
            model: e.model,
            oldLanguage: e.oldLanguageId
        });
    });
}
exports.onDidChangeModelLanguage = onDidChangeModelLanguage;
/**
 * Create a new web worker that has model syncing capabilities built in.
 * Specify an AMD module to load that will `create` an object that will be proxied.
 */
function createWebWorker(opts) {
    return (0, webWorker_1.createWebWorker)(standaloneServices_1.StandaloneServices.get(model_2.IModelService), standaloneServices_1.StandaloneServices.get(languageConfigurationRegistry_1.ILanguageConfigurationService), opts);
}
exports.createWebWorker = createWebWorker;
/**
 * Colorize the contents of `domNode` using attribute `data-lang`.
 */
function colorizeElement(domNode, options) {
    const languageService = standaloneServices_1.StandaloneServices.get(language_1.ILanguageService);
    const themeService = standaloneServices_1.StandaloneServices.get(standaloneTheme_1.IStandaloneThemeService);
    return colorizer_1.Colorizer.colorizeElement(themeService, languageService, domNode, options).then(() => {
        themeService.registerEditorContainer(domNode);
    });
}
exports.colorizeElement = colorizeElement;
/**
 * Colorize `text` using language `languageId`.
 */
function colorize(text, languageId, options) {
    const languageService = standaloneServices_1.StandaloneServices.get(language_1.ILanguageService);
    const themeService = standaloneServices_1.StandaloneServices.get(standaloneTheme_1.IStandaloneThemeService);
    themeService.registerEditorContainer(window_1.mainWindow.document.body);
    return colorizer_1.Colorizer.colorize(languageService, text, languageId, options);
}
exports.colorize = colorize;
/**
 * Colorize a line in a model.
 */
function colorizeModelLine(model, lineNumber, tabSize = 4) {
    const themeService = standaloneServices_1.StandaloneServices.get(standaloneTheme_1.IStandaloneThemeService);
    themeService.registerEditorContainer(window_1.mainWindow.document.body);
    return colorizer_1.Colorizer.colorizeModelLine(model, lineNumber, tabSize);
}
exports.colorizeModelLine = colorizeModelLine;
/**
 * @internal
 */
function getSafeTokenizationSupport(language) {
    const tokenizationSupport = languages.TokenizationRegistry.get(language);
    if (tokenizationSupport) {
        return tokenizationSupport;
    }
    return {
        getInitialState: () => nullTokenize_1.NullState,
        tokenize: (line, hasEOL, state) => (0, nullTokenize_1.nullTokenize)(language, state)
    };
}
/**
 * Tokenize `text` using language `languageId`
 */
function tokenize(text, languageId) {
    // Needed in order to get the mode registered for subsequent look-ups
    languages.TokenizationRegistry.getOrCreate(languageId);
    const tokenizationSupport = getSafeTokenizationSupport(languageId);
    const lines = (0, strings_1.splitLines)(text);
    const result = [];
    let state = tokenizationSupport.getInitialState();
    for (let i = 0, len = lines.length; i < len; i++) {
        const line = lines[i];
        const tokenizationResult = tokenizationSupport.tokenize(line, true, state);
        result[i] = tokenizationResult.tokens;
        state = tokenizationResult.endState;
    }
    return result;
}
exports.tokenize = tokenize;
/**
 * Define a new theme or update an existing theme.
 */
function defineTheme(themeName, themeData) {
    const standaloneThemeService = standaloneServices_1.StandaloneServices.get(standaloneTheme_1.IStandaloneThemeService);
    standaloneThemeService.defineTheme(themeName, themeData);
}
exports.defineTheme = defineTheme;
/**
 * Switches to a theme.
 */
function setTheme(themeName) {
    const standaloneThemeService = standaloneServices_1.StandaloneServices.get(standaloneTheme_1.IStandaloneThemeService);
    standaloneThemeService.setTheme(themeName);
}
exports.setTheme = setTheme;
/**
 * Clears all cached font measurements and triggers re-measurement.
 */
function remeasureFonts() {
    fontMeasurements_1.FontMeasurements.clearAllFontInfos();
}
exports.remeasureFonts = remeasureFonts;
/**
 * Register a command.
 */
function registerCommand(id, handler) {
    return commands_1.CommandsRegistry.registerCommand({ id, handler });
}
exports.registerCommand = registerCommand;
/**
 * Registers a handler that is called when a link is opened in any editor. The handler callback should return `true` if the link was handled and `false` otherwise.
 * The handler that was registered last will be called first when a link is opened.
 *
 * Returns a disposable that can unregister the opener again.
 */
function registerLinkOpener(opener) {
    const openerService = standaloneServices_1.StandaloneServices.get(opener_1.IOpenerService);
    return openerService.registerOpener({
        async open(resource) {
            if (typeof resource === 'string') {
                resource = uri_1.URI.parse(resource);
            }
            return opener.open(resource);
        }
    });
}
exports.registerLinkOpener = registerLinkOpener;
/**
 * Registers a handler that is called when a resource other than the current model should be opened in the editor (e.g. "go to definition").
 * The handler callback should return `true` if the request was handled and `false` otherwise.
 *
 * Returns a disposable that can unregister the opener again.
 *
 * If no handler is registered the default behavior is to do nothing for models other than the currently attached one.
 */
function registerEditorOpener(opener) {
    const codeEditorService = standaloneServices_1.StandaloneServices.get(codeEditorService_1.ICodeEditorService);
    return codeEditorService.registerCodeEditorOpenHandler(async (input, source, sideBySide) => {
        var _a;
        if (!source) {
            return null;
        }
        const selection = (_a = input.options) === null || _a === void 0 ? void 0 : _a.selection;
        let selectionOrPosition;
        if (selection && typeof selection.endLineNumber === 'number' && typeof selection.endColumn === 'number') {
            selectionOrPosition = selection;
        }
        else if (selection) {
            selectionOrPosition = { lineNumber: selection.startLineNumber, column: selection.startColumn };
        }
        if (await opener.openCodeEditor(source, input.resource, selectionOrPosition)) {
            return source; // return source editor to indicate that this handler has successfully handled the opening
        }
        return null; // fallback to other registered handlers
    });
}
exports.registerEditorOpener = registerEditorOpener;
/**
 * @internal
 */
function createMonacoEditorAPI() {
    return {
        // methods
        create: create,
        getEditors: getEditors,
        getDiffEditors: getDiffEditors,
        onDidCreateEditor: onDidCreateEditor,
        onDidCreateDiffEditor: onDidCreateDiffEditor,
        createDiffEditor: createDiffEditor,
        addCommand: addCommand,
        addEditorAction: addEditorAction,
        addKeybindingRule: addKeybindingRule,
        addKeybindingRules: addKeybindingRules,
        createModel: createModel,
        setModelLanguage: setModelLanguage,
        setModelMarkers: setModelMarkers,
        getModelMarkers: getModelMarkers,
        removeAllMarkers: removeAllMarkers,
        onDidChangeMarkers: onDidChangeMarkers,
        getModels: getModels,
        getModel: getModel,
        onDidCreateModel: onDidCreateModel,
        onWillDisposeModel: onWillDisposeModel,
        onDidChangeModelLanguage: onDidChangeModelLanguage,
        createWebWorker: createWebWorker,
        colorizeElement: colorizeElement,
        colorize: colorize,
        colorizeModelLine: colorizeModelLine,
        tokenize: tokenize,
        defineTheme: defineTheme,
        setTheme: setTheme,
        remeasureFonts: remeasureFonts,
        registerCommand: registerCommand,
        registerLinkOpener: registerLinkOpener,
        registerEditorOpener: registerEditorOpener,
        // enums
        AccessibilitySupport: standaloneEnums.AccessibilitySupport,
        ContentWidgetPositionPreference: standaloneEnums.ContentWidgetPositionPreference,
        CursorChangeReason: standaloneEnums.CursorChangeReason,
        DefaultEndOfLine: standaloneEnums.DefaultEndOfLine,
        EditorAutoIndentStrategy: standaloneEnums.EditorAutoIndentStrategy,
        EditorOption: standaloneEnums.EditorOption,
        EndOfLinePreference: standaloneEnums.EndOfLinePreference,
        EndOfLineSequence: standaloneEnums.EndOfLineSequence,
        MinimapPosition: standaloneEnums.MinimapPosition,
        MouseTargetType: standaloneEnums.MouseTargetType,
        OverlayWidgetPositionPreference: standaloneEnums.OverlayWidgetPositionPreference,
        OverviewRulerLane: standaloneEnums.OverviewRulerLane,
        GlyphMarginLane: standaloneEnums.GlyphMarginLane,
        RenderLineNumbersType: standaloneEnums.RenderLineNumbersType,
        RenderMinimap: standaloneEnums.RenderMinimap,
        ScrollbarVisibility: standaloneEnums.ScrollbarVisibility,
        ScrollType: standaloneEnums.ScrollType,
        TextEditorCursorBlinkingStyle: standaloneEnums.TextEditorCursorBlinkingStyle,
        TextEditorCursorStyle: standaloneEnums.TextEditorCursorStyle,
        TrackedRangeStickiness: standaloneEnums.TrackedRangeStickiness,
        WrappingIndent: standaloneEnums.WrappingIndent,
        InjectedTextCursorStops: standaloneEnums.InjectedTextCursorStops,
        PositionAffinity: standaloneEnums.PositionAffinity,
        ShowLightbulbIconMode: standaloneEnums.ShowLightbulbIconMode,
        // classes
        ConfigurationChangedEvent: editorOptions_1.ConfigurationChangedEvent,
        BareFontInfo: fontInfo_1.BareFontInfo,
        FontInfo: fontInfo_1.FontInfo,
        TextModelResolvedOptions: model_1.TextModelResolvedOptions,
        FindMatch: model_1.FindMatch,
        ApplyUpdateResult: editorOptions_1.ApplyUpdateResult,
        EditorZoom: editorZoom_1.EditorZoom,
        createMultiFileDiffEditor: createMultiFileDiffEditor,
        // vars
        EditorType: editorCommon_1.EditorType,
        EditorOptions: editorOptions_1.EditorOptions
    };
}
exports.createMonacoEditorAPI = createMonacoEditorAPI;
//# sourceMappingURL=standaloneEditor.js.map