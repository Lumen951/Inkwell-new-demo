{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/editor/browser/services/webWorker.ts","vs/editor/browser/services/webWorker.ts"],"names":[],"mappings":"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","file":"webWorker.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getAllMethodNames } from '../../../base/common/objects';\nimport { URI } from '../../../base/common/uri';\nimport { EditorWorkerClient } from './editorWorkerService';\nimport { ILanguageConfigurationService } from '../../common/languages/languageConfigurationRegistry';\nimport { IModelService } from '../../common/services/model';\n\n/**\n * Create a new web worker that has model syncing capabilities built in.\n * Specify an AMD module to load that will `create` an object that will be proxied.\n */\nexport function createWebWorker<T extends object>(modelService: IModelService, languageConfigurationService: ILanguageConfigurationService, opts: IWebWorkerOptions): MonacoWebWorker<T> {\n\treturn new MonacoWebWorkerImpl<T>(modelService, languageConfigurationService, opts);\n}\n\n/**\n * A web worker that can provide a proxy to an arbitrary file.\n */\nexport interface MonacoWebWorker<T> {\n\t/**\n\t * Terminate the web worker, thus invalidating the returned proxy.\n\t */\n\tdispose(): void;\n\t/**\n\t * Get a proxy to the arbitrary loaded code.\n\t */\n\tgetProxy(): Promise<T>;\n\t/**\n\t * Synchronize (send) the models at `resources` to the web worker,\n\t * making them available in the monaco.worker.getMirrorModels().\n\t */\n\twithSyncedResources(resources: URI[]): Promise<T>;\n}\n\nexport interface IWebWorkerOptions {\n\t/**\n\t * The AMD moduleId to load.\n\t * It should export a function `create` that should return the exported proxy.\n\t */\n\tmoduleId: string;\n\t/**\n\t * The data to send over when calling create on the module.\n\t */\n\tcreateData?: any;\n\t/**\n\t * A label to be used to identify the web worker for debugging purposes.\n\t */\n\tlabel?: string;\n\t/**\n\t * An object that can be used by the web worker to make calls back to the main thread.\n\t */\n\thost?: any;\n\t/**\n\t * Keep idle models.\n\t * Defaults to false, which means that idle models will stop syncing after a while.\n\t */\n\tkeepIdleModels?: boolean;\n}\n\nclass MonacoWebWorkerImpl<T extends object> extends EditorWorkerClient implements MonacoWebWorker<T> {\n\n\tprivate readonly _foreignModuleId: string;\n\tprivate readonly _foreignModuleHost: { [method: string]: Function } | null;\n\tprivate _foreignModuleCreateData: any | null;\n\tprivate _foreignProxy: Promise<T> | null;\n\n\tconstructor(modelService: IModelService, languageConfigurationService: ILanguageConfigurationService, opts: IWebWorkerOptions) {\n\t\tsuper(modelService, opts.keepIdleModels || false, opts.label, languageConfigurationService);\n\t\tthis._foreignModuleId = opts.moduleId;\n\t\tthis._foreignModuleCreateData = opts.createData || null;\n\t\tthis._foreignModuleHost = opts.host || null;\n\t\tthis._foreignProxy = null;\n\t}\n\n\t// foreign host request\n\tpublic override fhr(method: string, args: any[]): Promise<any> {\n\t\tif (!this._foreignModuleHost || typeof this._foreignModuleHost[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error('Missing method ' + method + ' or missing main thread foreign host.'));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve(this._foreignModuleHost[method].apply(this._foreignModuleHost, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\tprivate _getForeignProxy(): Promise<T> {\n\t\tif (!this._foreignProxy) {\n\t\t\tthis._foreignProxy = this._getProxy().then((proxy) => {\n\t\t\t\tconst foreignHostMethods = this._foreignModuleHost ? getAllMethodNames(this._foreignModuleHost) : [];\n\t\t\t\treturn proxy.loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, foreignHostMethods).then((foreignMethods) => {\n\t\t\t\t\tthis._foreignModuleCreateData = null;\n\n\t\t\t\t\tconst proxyMethodRequest = (method: string, args: any[]): Promise<any> => {\n\t\t\t\t\t\treturn proxy.fmr(method, args);\n\t\t\t\t\t};\n\n\t\t\t\t\tconst createProxyMethod = (method: string, proxyMethodRequest: (method: string, args: any[]) => Promise<any>): () => Promise<any> => {\n\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\tconst args = Array.prototype.slice.call(arguments, 0);\n\t\t\t\t\t\t\treturn proxyMethodRequest(method, args);\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\tconst foreignProxy = {} as T;\n\t\t\t\t\tfor (const foreignMethod of foreignMethods) {\n\t\t\t\t\t\t(<any>foreignProxy)[foreignMethod] = createProxyMethod(foreignMethod, proxyMethodRequest);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn foreignProxy;\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\treturn this._foreignProxy;\n\t}\n\n\tpublic getProxy(): Promise<T> {\n\t\treturn this._getForeignProxy();\n\t}\n\n\tpublic withSyncedResources(resources: URI[]): Promise<T> {\n\t\treturn this._withSyncedResources(resources).then(_ => this.getProxy());\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getAllMethodNames } from '../../../base/common/objects';\nimport { URI } from '../../../base/common/uri';\nimport { EditorWorkerClient } from './editorWorkerService';\nimport { ILanguageConfigurationService } from '../../common/languages/languageConfigurationRegistry';\nimport { IModelService } from '../../common/services/model';\n\n/**\n * Create a new web worker that has model syncing capabilities built in.\n * Specify an AMD module to load that will `create` an object that will be proxied.\n */\nexport function createWebWorker<T extends object>(modelService: IModelService, languageConfigurationService: ILanguageConfigurationService, opts: IWebWorkerOptions): MonacoWebWorker<T> {\n\treturn new MonacoWebWorkerImpl<T>(modelService, languageConfigurationService, opts);\n}\n\n/**\n * A web worker that can provide a proxy to an arbitrary file.\n */\nexport interface MonacoWebWorker<T> {\n\t/**\n\t * Terminate the web worker, thus invalidating the returned proxy.\n\t */\n\tdispose(): void;\n\t/**\n\t * Get a proxy to the arbitrary loaded code.\n\t */\n\tgetProxy(): Promise<T>;\n\t/**\n\t * Synchronize (send) the models at `resources` to the web worker,\n\t * making them available in the monaco.worker.getMirrorModels().\n\t */\n\twithSyncedResources(resources: URI[]): Promise<T>;\n}\n\nexport interface IWebWorkerOptions {\n\t/**\n\t * The AMD moduleId to load.\n\t * It should export a function `create` that should return the exported proxy.\n\t */\n\tmoduleId: string;\n\t/**\n\t * The data to send over when calling create on the module.\n\t */\n\tcreateData?: any;\n\t/**\n\t * A label to be used to identify the web worker for debugging purposes.\n\t */\n\tlabel?: string;\n\t/**\n\t * An object that can be used by the web worker to make calls back to the main thread.\n\t */\n\thost?: any;\n\t/**\n\t * Keep idle models.\n\t * Defaults to false, which means that idle models will stop syncing after a while.\n\t */\n\tkeepIdleModels?: boolean;\n}\n\nclass MonacoWebWorkerImpl<T extends object> extends EditorWorkerClient implements MonacoWebWorker<T> {\n\n\tprivate readonly _foreignModuleId: string;\n\tprivate readonly _foreignModuleHost: { [method: string]: Function } | null;\n\tprivate _foreignModuleCreateData: any | null;\n\tprivate _foreignProxy: Promise<T> | null;\n\n\tconstructor(modelService: IModelService, languageConfigurationService: ILanguageConfigurationService, opts: IWebWorkerOptions) {\n\t\tsuper(modelService, opts.keepIdleModels || false, opts.label, languageConfigurationService);\n\t\tthis._foreignModuleId = opts.moduleId;\n\t\tthis._foreignModuleCreateData = opts.createData || null;\n\t\tthis._foreignModuleHost = opts.host || null;\n\t\tthis._foreignProxy = null;\n\t}\n\n\t// foreign host request\n\tpublic override fhr(method: string, args: any[]): Promise<any> {\n\t\tif (!this._foreignModuleHost || typeof this._foreignModuleHost[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error('Missing method ' + method + ' or missing main thread foreign host.'));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve(this._foreignModuleHost[method].apply(this._foreignModuleHost, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\tprivate _getForeignProxy(): Promise<T> {\n\t\tif (!this._foreignProxy) {\n\t\t\tthis._foreignProxy = this._getProxy().then((proxy) => {\n\t\t\t\tconst foreignHostMethods = this._foreignModuleHost ? getAllMethodNames(this._foreignModuleHost) : [];\n\t\t\t\treturn proxy.loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, foreignHostMethods).then((foreignMethods) => {\n\t\t\t\t\tthis._foreignModuleCreateData = null;\n\n\t\t\t\t\tconst proxyMethodRequest = (method: string, args: any[]): Promise<any> => {\n\t\t\t\t\t\treturn proxy.fmr(method, args);\n\t\t\t\t\t};\n\n\t\t\t\t\tconst createProxyMethod = (method: string, proxyMethodRequest: (method: string, args: any[]) => Promise<any>): () => Promise<any> => {\n\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\tconst args = Array.prototype.slice.call(arguments, 0);\n\t\t\t\t\t\t\treturn proxyMethodRequest(method, args);\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\tconst foreignProxy = {} as T;\n\t\t\t\t\tfor (const foreignMethod of foreignMethods) {\n\t\t\t\t\t\t(<any>foreignProxy)[foreignMethod] = createProxyMethod(foreignMethod, proxyMethodRequest);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn foreignProxy;\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\treturn this._foreignProxy;\n\t}\n\n\tpublic getProxy(): Promise<T> {\n\t\treturn this._getForeignProxy();\n\t}\n\n\tpublic withSyncedResources(resources: URI[]): Promise<T> {\n\t\treturn this._withSyncedResources(resources).then(_ => this.getProxy());\n\t}\n}\n"]}