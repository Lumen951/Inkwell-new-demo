"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiDiffEditorWidgetImpl = void 0;
const dom_1 = require("../../../../base/browser/dom");
const scrollableElement_1 = require("../../../../base/browser/ui/scrollbar/scrollableElement");
const arraysFind_1 = require("../../../../base/common/arraysFind");
const lifecycle_1 = require("../../../../base/common/lifecycle");
const observable_1 = require("../../../../base/common/observable");
const base_1 = require("../../../../base/common/observableInternal/base");
const scrollable_1 = require("../../../../base/common/scrollable");
require("./style.css");
const utils_1 = require("../diffEditor/utils");
const offsetRange_1 = require("../../../common/core/offsetRange");
const selection_1 = require("../../../common/core/selection");
const editorContextKeys_1 = require("../../../common/editorContextKeys");
const contextkey_1 = require("../../../../platform/contextkey/common/contextkey");
const instantiation_1 = require("../../../../platform/instantiation/common/instantiation");
const serviceCollection_1 = require("../../../../platform/instantiation/common/serviceCollection");
const diffEditorItemTemplate_1 = require("./diffEditorItemTemplate");
const objectPool_1 = require("./objectPool");
let MultiDiffEditorWidgetImpl = class MultiDiffEditorWidgetImpl extends lifecycle_1.Disposable {
    constructor(_element, _dimension, _viewModel, _workbenchUIElementFactory, _parentContextKeyService, _parentInstantiationService) {
        super();
        this._element = _element;
        this._dimension = _dimension;
        this._viewModel = _viewModel;
        this._workbenchUIElementFactory = _workbenchUIElementFactory;
        this._parentContextKeyService = _parentContextKeyService;
        this._parentInstantiationService = _parentInstantiationService;
        this._elements = (0, dom_1.h)('div.monaco-component.multiDiffEditor', [
            (0, dom_1.h)('div@content', {
                style: {
                    overflow: 'hidden',
                }
            }),
            (0, dom_1.h)('div.monaco-editor@overflowWidgetsDomNode', {}),
        ]);
        this._sizeObserver = this._register(new utils_1.ObservableElementSizeObserver(this._element, undefined));
        this._objectPool = this._register(new objectPool_1.ObjectPool((data) => {
            const template = this._instantiationService.createInstance(diffEditorItemTemplate_1.DiffEditorItemTemplate, this._elements.content, this._elements.overflowWidgetsDomNode, this._workbenchUIElementFactory);
            template.setData(data);
            return template;
        }));
        this._scrollable = this._register(new scrollable_1.Scrollable({
            forceIntegerValues: false,
            scheduleAtNextAnimationFrame: (cb) => (0, dom_1.scheduleAtNextAnimationFrame)((0, dom_1.getWindow)(this._element), cb),
            smoothScrollDuration: 100,
        }));
        this._scrollableElement = this._register(new scrollableElement_1.SmoothScrollableElement(this._elements.root, {
            vertical: 1 /* ScrollbarVisibility.Auto */,
            horizontal: 1 /* ScrollbarVisibility.Auto */,
            useShadows: false,
        }, this._scrollable));
        this.scrollTop = (0, observable_1.observableFromEvent)(this._scrollableElement.onScroll, () => /** @description scrollTop */ this._scrollableElement.getScrollPosition().scrollTop);
        this.scrollLeft = (0, observable_1.observableFromEvent)(this._scrollableElement.onScroll, () => /** @description scrollLeft */ this._scrollableElement.getScrollPosition().scrollLeft);
        this._viewItems = (0, observable_1.derivedWithStore)(this, (reader, store) => {
            const vm = this._viewModel.read(reader);
            if (!vm) {
                return [];
            }
            const items = vm.items.read(reader);
            return items.map(d => {
                var _a;
                const item = store.add(new VirtualizedViewItem(d, this._objectPool, this.scrollLeft, delta => {
                    this._scrollableElement.setScrollPosition({ scrollTop: this._scrollableElement.getScrollPosition().scrollTop + delta });
                }));
                const data = (_a = this._lastDocStates) === null || _a === void 0 ? void 0 : _a[item.getKey()];
                if (data) {
                    (0, base_1.transaction)(tx => {
                        item.setViewState(data, tx);
                    });
                }
                return item;
            });
        });
        this._spaceBetweenPx = 0;
        this._totalHeight = this._viewItems.map(this, (items, reader) => items.reduce((r, i) => r + i.contentHeight.read(reader) + this._spaceBetweenPx, 0));
        this.activeDiffItem = (0, observable_1.derived)(this, reader => this._viewItems.read(reader).find(i => { var _a; return (_a = i.template.read(reader)) === null || _a === void 0 ? void 0 : _a.isFocused.read(reader); }));
        this.lastActiveDiffItem = (0, observable_1.derivedObservableWithCache)((reader, lastValue) => { var _a; return (_a = this.activeDiffItem.read(reader)) !== null && _a !== void 0 ? _a : lastValue; });
        this.activeControl = (0, observable_1.derived)(this, reader => { var _a, _b; return (_b = (_a = this.lastActiveDiffItem.read(reader)) === null || _a === void 0 ? void 0 : _a.template.read(reader)) === null || _b === void 0 ? void 0 : _b.editor; });
        this._contextKeyService = this._register(this._parentContextKeyService.createScoped(this._element));
        this._instantiationService = this._parentInstantiationService.createChild(new serviceCollection_1.ServiceCollection([contextkey_1.IContextKeyService, this._contextKeyService]));
        /** This accounts for documents that are not loaded yet. */
        this._lastDocStates = {};
        this._contextKeyService.createKey(editorContextKeys_1.EditorContextKeys.inMultiDiffEditor.key, true);
        this._register((0, observable_1.autorunWithStore)((reader, store) => {
            const viewModel = this._viewModel.read(reader);
            if (viewModel && viewModel.contextKeys) {
                for (const [key, value] of Object.entries(viewModel.contextKeys)) {
                    const contextKey = this._contextKeyService.createKey(key, undefined);
                    contextKey.set(value);
                    store.add((0, lifecycle_1.toDisposable)(() => contextKey.reset()));
                }
            }
        }));
        const ctxAllCollapsed = this._parentContextKeyService.createKey(editorContextKeys_1.EditorContextKeys.multiDiffEditorAllCollapsed.key, false);
        this._register((0, observable_1.autorun)((reader) => {
            const viewModel = this._viewModel.read(reader);
            if (viewModel) {
                const allCollapsed = viewModel.items.read(reader).every(item => item.collapsed.read(reader));
                ctxAllCollapsed.set(allCollapsed);
            }
        }));
        this._register((0, observable_1.autorun)((reader) => {
            const lastActiveDiffItem = this.lastActiveDiffItem.read(reader);
            (0, base_1.transaction)(tx => {
                var _a;
                (_a = this._viewModel.read(reader)) === null || _a === void 0 ? void 0 : _a.activeDiffItem.set(lastActiveDiffItem === null || lastActiveDiffItem === void 0 ? void 0 : lastActiveDiffItem.viewModel, tx);
            });
        }));
        this._register((0, observable_1.autorun)((reader) => {
            /** @description Update widget dimension */
            const dimension = this._dimension.read(reader);
            this._sizeObserver.observe(dimension);
        }));
        this._elements.content.style.position = 'relative';
        this._register((0, observable_1.autorun)((reader) => {
            /** @description Update scroll dimensions */
            const height = this._sizeObserver.height.read(reader);
            this._elements.root.style.height = `${height}px`;
            const totalHeight = this._totalHeight.read(reader);
            this._elements.content.style.height = `${totalHeight}px`;
            const width = this._sizeObserver.width.read(reader);
            let scrollWidth = width;
            const viewItems = this._viewItems.read(reader);
            const max = (0, arraysFind_1.findFirstMaxBy)(viewItems, i => i.maxScroll.read(reader).maxScroll);
            if (max) {
                const maxScroll = max.maxScroll.read(reader);
                scrollWidth = width + maxScroll.maxScroll;
            }
            this._scrollableElement.setScrollDimensions({
                width: width,
                height: height,
                scrollHeight: totalHeight,
                scrollWidth,
            });
        }));
        _element.replaceChildren(this._scrollableElement.getDomNode());
        this._register((0, lifecycle_1.toDisposable)(() => {
            _element.replaceChildren();
        }));
        this._register(this._register((0, observable_1.autorun)(reader => {
            /** @description Render all */
            (0, base_1.globalTransaction)(tx => {
                this.render(reader);
            });
        })));
    }
    setScrollState(scrollState) {
        this._scrollableElement.setScrollPosition({ scrollLeft: scrollState.left, scrollTop: scrollState.top });
    }
    reveal(resource, options) {
        var _a;
        const viewItems = this._viewItems.get();
        let searchCallback;
        if ('original' in resource) {
            searchCallback = (item) => { var _a; return ((_a = item.viewModel.originalUri) === null || _a === void 0 ? void 0 : _a.toString()) === resource.original.toString(); };
        }
        else {
            searchCallback = (item) => { var _a; return ((_a = item.viewModel.modifiedUri) === null || _a === void 0 ? void 0 : _a.toString()) === resource.modified.toString(); };
        }
        const index = viewItems.findIndex(searchCallback);
        let scrollTop = 0;
        for (let i = 0; i < index; i++) {
            scrollTop += viewItems[i].contentHeight.get() + this._spaceBetweenPx;
        }
        this._scrollableElement.setScrollPosition({ scrollTop });
        const diffEditor = (_a = viewItems[index].template.get()) === null || _a === void 0 ? void 0 : _a.editor;
        const editor = 'original' in resource ? diffEditor === null || diffEditor === void 0 ? void 0 : diffEditor.getOriginalEditor() : diffEditor === null || diffEditor === void 0 ? void 0 : diffEditor.getModifiedEditor();
        if (editor && (options === null || options === void 0 ? void 0 : options.range)) {
            editor.revealRangeInCenter(options.range);
            highlightRange(editor, options.range);
        }
    }
    getViewState() {
        return {
            scrollState: {
                top: this.scrollTop.get(),
                left: this.scrollLeft.get(),
            },
            docStates: Object.fromEntries(this._viewItems.get().map(i => [i.getKey(), i.getViewState()])),
        };
    }
    setViewState(viewState) {
        this.setScrollState(viewState.scrollState);
        this._lastDocStates = viewState.docStates;
        (0, base_1.transaction)(tx => {
            /** setViewState */
            if (viewState.docStates) {
                for (const i of this._viewItems.get()) {
                    const state = viewState.docStates[i.getKey()];
                    if (state) {
                        i.setViewState(state, tx);
                    }
                }
            }
        });
    }
    tryGetCodeEditor(resource) {
        var _a;
        const item = this._viewItems.get().find(v => v.viewModel.diffEditorViewModel.model.modified.uri.toString() === resource.toString()
            || v.viewModel.diffEditorViewModel.model.original.uri.toString() === resource.toString());
        const editor = (_a = item === null || item === void 0 ? void 0 : item.template.get()) === null || _a === void 0 ? void 0 : _a.editor;
        if (!editor) {
            return undefined;
        }
        if (item.viewModel.diffEditorViewModel.model.modified.uri.toString() === resource.toString()) {
            return { diffEditor: editor, editor: editor.getModifiedEditor() };
        }
        else {
            return { diffEditor: editor, editor: editor.getOriginalEditor() };
        }
    }
    render(reader) {
        const scrollTop = this.scrollTop.read(reader);
        let contentScrollOffsetToScrollOffset = 0;
        let itemHeightSumBefore = 0;
        let itemContentHeightSumBefore = 0;
        const viewPortHeight = this._sizeObserver.height.read(reader);
        const contentViewPort = offsetRange_1.OffsetRange.ofStartAndLength(scrollTop, viewPortHeight);
        const width = this._sizeObserver.width.read(reader);
        for (const v of this._viewItems.read(reader)) {
            const itemContentHeight = v.contentHeight.read(reader);
            const itemHeight = Math.min(itemContentHeight, viewPortHeight);
            const itemRange = offsetRange_1.OffsetRange.ofStartAndLength(itemHeightSumBefore, itemHeight);
            const itemContentRange = offsetRange_1.OffsetRange.ofStartAndLength(itemContentHeightSumBefore, itemContentHeight);
            if (itemContentRange.isBefore(contentViewPort)) {
                contentScrollOffsetToScrollOffset -= itemContentHeight - itemHeight;
                v.hide();
            }
            else if (itemContentRange.isAfter(contentViewPort)) {
                v.hide();
            }
            else {
                const scroll = Math.max(0, Math.min(contentViewPort.start - itemContentRange.start, itemContentHeight - itemHeight));
                contentScrollOffsetToScrollOffset -= scroll;
                const viewPort = offsetRange_1.OffsetRange.ofStartAndLength(scrollTop + contentScrollOffsetToScrollOffset, viewPortHeight);
                v.render(itemRange, scroll, width, viewPort);
            }
            itemHeightSumBefore += itemHeight + this._spaceBetweenPx;
            itemContentHeightSumBefore += itemContentHeight + this._spaceBetweenPx;
        }
        this._elements.content.style.transform = `translateY(${-(scrollTop + contentScrollOffsetToScrollOffset)}px)`;
    }
};
exports.MultiDiffEditorWidgetImpl = MultiDiffEditorWidgetImpl;
exports.MultiDiffEditorWidgetImpl = MultiDiffEditorWidgetImpl = __decorate([
    __param(4, contextkey_1.IContextKeyService),
    __param(5, instantiation_1.IInstantiationService)
], MultiDiffEditorWidgetImpl);
function highlightRange(targetEditor, range) {
    const modelNow = targetEditor.getModel();
    const decorations = targetEditor.createDecorationsCollection([{ range, options: { description: 'symbol-navigate-action-highlight', className: 'symbolHighlight' } }]);
    setTimeout(() => {
        if (targetEditor.getModel() === modelNow) {
            decorations.clear();
        }
    }, 350);
}
class VirtualizedViewItem extends lifecycle_1.Disposable {
    constructor(viewModel, _objectPool, _scrollLeft, _deltaScrollVertical) {
        super();
        this.viewModel = viewModel;
        this._objectPool = _objectPool;
        this._scrollLeft = _scrollLeft;
        this._deltaScrollVertical = _deltaScrollVertical;
        this._templateRef = this._register((0, base_1.disposableObservableValue)(this, undefined));
        this.contentHeight = (0, observable_1.derived)(this, reader => { var _a, _b, _c; return (_c = (_b = (_a = this._templateRef.read(reader)) === null || _a === void 0 ? void 0 : _a.object.contentHeight) === null || _b === void 0 ? void 0 : _b.read(reader)) !== null && _c !== void 0 ? _c : this.viewModel.lastTemplateData.read(reader).contentHeight; });
        this.maxScroll = (0, observable_1.derived)(this, reader => { var _a, _b; return (_b = (_a = this._templateRef.read(reader)) === null || _a === void 0 ? void 0 : _a.object.maxScroll.read(reader)) !== null && _b !== void 0 ? _b : { maxScroll: 0, scrollWidth: 0 }; });
        this.template = (0, observable_1.derived)(this, reader => { var _a; return (_a = this._templateRef.read(reader)) === null || _a === void 0 ? void 0 : _a.object; });
        this._isHidden = (0, observable_1.observableValue)(this, false);
        this._register((0, observable_1.autorun)((reader) => {
            var _a;
            const scrollLeft = this._scrollLeft.read(reader);
            (_a = this._templateRef.read(reader)) === null || _a === void 0 ? void 0 : _a.object.setScrollLeft(scrollLeft);
        }));
        this._register((0, observable_1.autorun)(reader => {
            const ref = this._templateRef.read(reader);
            if (!ref) {
                return;
            }
            const isHidden = this._isHidden.read(reader);
            if (!isHidden) {
                return;
            }
            const isFocused = ref.object.isFocused.read(reader);
            if (isFocused) {
                return;
            }
            this._clear();
        }));
    }
    dispose() {
        this._clear();
        super.dispose();
    }
    toString() {
        var _a;
        return `VirtualViewItem(${(_a = this.viewModel.entry.value.modified) === null || _a === void 0 ? void 0 : _a.uri.toString()})`;
    }
    getKey() {
        return this.viewModel.getKey();
    }
    getViewState() {
        (0, base_1.transaction)(tx => {
            this._updateTemplateData(tx);
        });
        return {
            collapsed: this.viewModel.collapsed.get(),
            selections: this.viewModel.lastTemplateData.get().selections,
        };
    }
    setViewState(viewState, tx) {
        var _a;
        this.viewModel.collapsed.set(viewState.collapsed, tx);
        this._updateTemplateData(tx);
        const data = this.viewModel.lastTemplateData.get();
        const selections = (_a = viewState.selections) === null || _a === void 0 ? void 0 : _a.map(selection_1.Selection.liftSelection);
        this.viewModel.lastTemplateData.set({
            ...data,
            selections,
        }, tx);
        const ref = this._templateRef.get();
        if (ref) {
            if (selections) {
                ref.object.editor.setSelections(selections);
            }
        }
    }
    _updateTemplateData(tx) {
        var _a;
        const ref = this._templateRef.get();
        if (!ref) {
            return;
        }
        this.viewModel.lastTemplateData.set({
            contentHeight: ref.object.contentHeight.get(),
            selections: (_a = ref.object.editor.getSelections()) !== null && _a !== void 0 ? _a : undefined,
        }, tx);
    }
    _clear() {
        const ref = this._templateRef.get();
        if (!ref) {
            return;
        }
        (0, base_1.transaction)(tx => {
            this._updateTemplateData(tx);
            ref.object.hide();
            this._templateRef.set(undefined, tx);
        });
    }
    hide() {
        this._isHidden.set(true, undefined);
    }
    render(verticalSpace, offset, width, viewPort) {
        this._isHidden.set(false, undefined);
        let ref = this._templateRef.get();
        if (!ref) {
            ref = this._objectPool.getUnusedObj(new diffEditorItemTemplate_1.TemplateData(this.viewModel, this._deltaScrollVertical));
            this._templateRef.set(ref, undefined);
            const selections = this.viewModel.lastTemplateData.get().selections;
            if (selections) {
                ref.object.editor.setSelections(selections);
            }
        }
        ref.object.render(verticalSpace, width, offset, viewPort);
    }
}
//# sourceMappingURL=multiDiffEditorWidgetImpl.js.map