"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterWithPrevious = exports.bindContextKey = exports.translatePosition = exports.DisposableCancellationTokenSource = exports.applyViewZones = exports.observeHotReloadableExports = exports.readHotReloadableExport = exports.applyStyle = exports.ManagedOverlayWidget = exports.PlaceholderViewZone = exports.ViewZoneOverlayWidget = exports.deepMerge = exports.animatedObservable = exports.ObservableElementSizeObserver = exports.observableConfigValue = exports.appendRemoveOnDispose = exports.applyObservableDecorations = exports.joinCombine = void 0;
const arraysFind_1 = require("../../../../base/common/arraysFind");
const cancellation_1 = require("../../../../base/common/cancellation");
const hotReload_1 = require("../../../../base/common/hotReload");
const lifecycle_1 = require("../../../../base/common/lifecycle");
const observable_1 = require("../../../../base/common/observable");
const elementSizeObserver_1 = require("../../config/elementSizeObserver");
const position_1 = require("../../../common/core/position");
const range_1 = require("../../../common/core/range");
const length_1 = require("../../../common/model/bracketPairsTextModelPart/bracketPairsTree/length");
function joinCombine(arr1, arr2, keySelector, combine) {
    if (arr1.length === 0) {
        return arr2;
    }
    if (arr2.length === 0) {
        return arr1;
    }
    const result = [];
    let i = 0;
    let j = 0;
    while (i < arr1.length && j < arr2.length) {
        const val1 = arr1[i];
        const val2 = arr2[j];
        const key1 = keySelector(val1);
        const key2 = keySelector(val2);
        if (key1 < key2) {
            result.push(val1);
            i++;
        }
        else if (key1 > key2) {
            result.push(val2);
            j++;
        }
        else {
            result.push(combine(val1, val2));
            i++;
            j++;
        }
    }
    while (i < arr1.length) {
        result.push(arr1[i]);
        i++;
    }
    while (j < arr2.length) {
        result.push(arr2[j]);
        j++;
    }
    return result;
}
exports.joinCombine = joinCombine;
// TODO make utility
function applyObservableDecorations(editor, decorations) {
    const d = new lifecycle_1.DisposableStore();
    const decorationsCollection = editor.createDecorationsCollection();
    d.add((0, observable_1.autorunOpts)({ debugName: () => `Apply decorations from ${decorations.debugName}` }, reader => {
        const d = decorations.read(reader);
        decorationsCollection.set(d);
    }));
    d.add({
        dispose: () => {
            decorationsCollection.clear();
        }
    });
    return d;
}
exports.applyObservableDecorations = applyObservableDecorations;
function appendRemoveOnDispose(parent, child) {
    parent.appendChild(child);
    return (0, lifecycle_1.toDisposable)(() => {
        parent.removeChild(child);
    });
}
exports.appendRemoveOnDispose = appendRemoveOnDispose;
function observableConfigValue(key, defaultValue, configurationService) {
    return (0, observable_1.observableFromEvent)((handleChange) => configurationService.onDidChangeConfiguration(e => {
        if (e.affectsConfiguration(key)) {
            handleChange(e);
        }
    }), () => { var _a; return (_a = configurationService.getValue(key)) !== null && _a !== void 0 ? _a : defaultValue; });
}
exports.observableConfigValue = observableConfigValue;
class ObservableElementSizeObserver extends lifecycle_1.Disposable {
    get width() { return this._width; }
    get height() { return this._height; }
    constructor(element, dimension) {
        super();
        this.elementSizeObserver = this._register(new elementSizeObserver_1.ElementSizeObserver(element, dimension));
        this._width = (0, observable_1.observableValue)(this, this.elementSizeObserver.getWidth());
        this._height = (0, observable_1.observableValue)(this, this.elementSizeObserver.getHeight());
        this._register(this.elementSizeObserver.onDidChange(e => (0, observable_1.transaction)(tx => {
            /** @description Set width/height from elementSizeObserver */
            this._width.set(this.elementSizeObserver.getWidth(), tx);
            this._height.set(this.elementSizeObserver.getHeight(), tx);
        })));
    }
    observe(dimension) {
        this.elementSizeObserver.observe(dimension);
    }
    setAutomaticLayout(automaticLayout) {
        if (automaticLayout) {
            this.elementSizeObserver.startObserving();
        }
        else {
            this.elementSizeObserver.stopObserving();
        }
    }
}
exports.ObservableElementSizeObserver = ObservableElementSizeObserver;
function animatedObservable(targetWindow, base, store) {
    let targetVal = base.get();
    let startVal = targetVal;
    let curVal = targetVal;
    const result = (0, observable_1.observableValue)('animatedValue', targetVal);
    let animationStartMs = -1;
    const durationMs = 300;
    let animationFrame = undefined;
    store.add((0, observable_1.autorunHandleChanges)({
        createEmptyChangeSummary: () => ({ animate: false }),
        handleChange: (ctx, s) => {
            if (ctx.didChange(base)) {
                s.animate = s.animate || ctx.change;
            }
            return true;
        }
    }, (reader, s) => {
        /** @description update value */
        if (animationFrame !== undefined) {
            targetWindow.cancelAnimationFrame(animationFrame);
            animationFrame = undefined;
        }
        startVal = curVal;
        targetVal = base.read(reader);
        animationStartMs = Date.now() - (s.animate ? 0 : durationMs);
        update();
    }));
    function update() {
        const passedMs = Date.now() - animationStartMs;
        curVal = Math.floor(easeOutExpo(passedMs, startVal, targetVal - startVal, durationMs));
        if (passedMs < durationMs) {
            animationFrame = targetWindow.requestAnimationFrame(update);
        }
        else {
            curVal = targetVal;
        }
        result.set(curVal, undefined);
    }
    return result;
}
exports.animatedObservable = animatedObservable;
function easeOutExpo(t, b, c, d) {
    return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
}
function deepMerge(source1, source2) {
    const result = {};
    for (const key in source1) {
        result[key] = source1[key];
    }
    for (const key in source2) {
        const source2Value = source2[key];
        if (typeof result[key] === 'object' && source2Value && typeof source2Value === 'object') {
            result[key] = deepMerge(result[key], source2Value);
        }
        else {
            result[key] = source2Value;
        }
    }
    return result;
}
exports.deepMerge = deepMerge;
class ViewZoneOverlayWidget extends lifecycle_1.Disposable {
    constructor(editor, viewZone, htmlElement) {
        super();
        this._register(new ManagedOverlayWidget(editor, htmlElement));
        this._register(applyStyle(htmlElement, {
            height: viewZone.actualHeight,
            top: viewZone.actualTop,
        }));
    }
}
exports.ViewZoneOverlayWidget = ViewZoneOverlayWidget;
class PlaceholderViewZone {
    get afterLineNumber() { return this._afterLineNumber.get(); }
    constructor(_afterLineNumber, heightInPx) {
        this._afterLineNumber = _afterLineNumber;
        this.heightInPx = heightInPx;
        this.domNode = document.createElement('div');
        this._actualTop = (0, observable_1.observableValue)(this, undefined);
        this._actualHeight = (0, observable_1.observableValue)(this, undefined);
        this.actualTop = this._actualTop;
        this.actualHeight = this._actualHeight;
        this.showInHiddenAreas = true;
        this.onChange = this._afterLineNumber;
        this.onDomNodeTop = (top) => {
            this._actualTop.set(top, undefined);
        };
        this.onComputedHeight = (height) => {
            this._actualHeight.set(height, undefined);
        };
    }
}
exports.PlaceholderViewZone = PlaceholderViewZone;
class ManagedOverlayWidget {
    constructor(_editor, _domElement) {
        this._editor = _editor;
        this._domElement = _domElement;
        this._overlayWidgetId = `managedOverlayWidget-${ManagedOverlayWidget._counter++}`;
        this._overlayWidget = {
            getId: () => this._overlayWidgetId,
            getDomNode: () => this._domElement,
            getPosition: () => null
        };
        this._editor.addOverlayWidget(this._overlayWidget);
    }
    dispose() {
        this._editor.removeOverlayWidget(this._overlayWidget);
    }
}
exports.ManagedOverlayWidget = ManagedOverlayWidget;
ManagedOverlayWidget._counter = 0;
function applyStyle(domNode, style) {
    return (0, observable_1.autorun)(reader => {
        /** @description applyStyle */
        for (let [key, val] of Object.entries(style)) {
            if (val && typeof val === 'object' && 'read' in val) {
                val = val.read(reader);
            }
            if (typeof val === 'number') {
                val = `${val}px`;
            }
            key = key.replace(/[A-Z]/g, m => '-' + m.toLowerCase());
            domNode.style[key] = val;
        }
    });
}
exports.applyStyle = applyStyle;
function readHotReloadableExport(value, reader) {
    observeHotReloadableExports([value], reader);
    return value;
}
exports.readHotReloadableExport = readHotReloadableExport;
function observeHotReloadableExports(values, reader) {
    if ((0, hotReload_1.isHotReloadEnabled)()) {
        const o = (0, observable_1.observableSignalFromEvent)('reload', event => (0, hotReload_1.registerHotReloadHandler)(({ oldExports }) => {
            if (![...Object.values(oldExports)].some(v => values.includes(v))) {
                return undefined;
            }
            return (_newExports) => {
                event(undefined);
                return true;
            };
        }));
        o.read(reader);
    }
}
exports.observeHotReloadableExports = observeHotReloadableExports;
function applyViewZones(editor, viewZones, setIsUpdating, zoneIds) {
    const store = new lifecycle_1.DisposableStore();
    const lastViewZoneIds = [];
    store.add((0, observable_1.autorunWithStore)((reader, store) => {
        /** @description applyViewZones */
        const curViewZones = viewZones.read(reader);
        const viewZonIdsPerViewZone = new Map();
        const viewZoneIdPerOnChangeObservable = new Map();
        // Add/remove view zones
        if (setIsUpdating) {
            setIsUpdating(true);
        }
        editor.changeViewZones(a => {
            for (const id of lastViewZoneIds) {
                a.removeZone(id);
                zoneIds === null || zoneIds === void 0 ? void 0 : zoneIds.delete(id);
            }
            lastViewZoneIds.length = 0;
            for (const z of curViewZones) {
                const id = a.addZone(z);
                if (z.setZoneId) {
                    z.setZoneId(id);
                }
                lastViewZoneIds.push(id);
                zoneIds === null || zoneIds === void 0 ? void 0 : zoneIds.add(id);
                viewZonIdsPerViewZone.set(z, id);
            }
        });
        if (setIsUpdating) {
            setIsUpdating(false);
        }
        // Layout zone on change
        store.add((0, observable_1.autorunHandleChanges)({
            createEmptyChangeSummary() {
                return { zoneIds: [] };
            },
            handleChange(context, changeSummary) {
                const id = viewZoneIdPerOnChangeObservable.get(context.changedObservable);
                if (id !== undefined) {
                    changeSummary.zoneIds.push(id);
                }
                return true;
            },
        }, (reader, changeSummary) => {
            /** @description layoutZone on change */
            for (const vz of curViewZones) {
                if (vz.onChange) {
                    viewZoneIdPerOnChangeObservable.set(vz.onChange, viewZonIdsPerViewZone.get(vz));
                    vz.onChange.read(reader);
                }
            }
            if (setIsUpdating) {
                setIsUpdating(true);
            }
            editor.changeViewZones(a => { for (const id of changeSummary.zoneIds) {
                a.layoutZone(id);
            } });
            if (setIsUpdating) {
                setIsUpdating(false);
            }
        }));
    }));
    store.add({
        dispose() {
            if (setIsUpdating) {
                setIsUpdating(true);
            }
            editor.changeViewZones(a => { for (const id of lastViewZoneIds) {
                a.removeZone(id);
            } });
            zoneIds === null || zoneIds === void 0 ? void 0 : zoneIds.clear();
            if (setIsUpdating) {
                setIsUpdating(false);
            }
        }
    });
    return store;
}
exports.applyViewZones = applyViewZones;
class DisposableCancellationTokenSource extends cancellation_1.CancellationTokenSource {
    dispose() {
        super.dispose(true);
    }
}
exports.DisposableCancellationTokenSource = DisposableCancellationTokenSource;
function translatePosition(posInOriginal, mappings) {
    const mapping = (0, arraysFind_1.findLast)(mappings, m => m.original.startLineNumber <= posInOriginal.lineNumber);
    if (!mapping) {
        // No changes before the position
        return range_1.Range.fromPositions(posInOriginal);
    }
    if (mapping.original.endLineNumberExclusive <= posInOriginal.lineNumber) {
        const newLineNumber = posInOriginal.lineNumber - mapping.original.endLineNumberExclusive + mapping.modified.endLineNumberExclusive;
        return range_1.Range.fromPositions(new position_1.Position(newLineNumber, posInOriginal.column));
    }
    if (!mapping.innerChanges) {
        // Only for legacy algorithm
        return range_1.Range.fromPositions(new position_1.Position(mapping.modified.startLineNumber, 1));
    }
    const innerMapping = (0, arraysFind_1.findLast)(mapping.innerChanges, m => m.originalRange.getStartPosition().isBeforeOrEqual(posInOriginal));
    if (!innerMapping) {
        const newLineNumber = posInOriginal.lineNumber - mapping.original.startLineNumber + mapping.modified.startLineNumber;
        return range_1.Range.fromPositions(new position_1.Position(newLineNumber, posInOriginal.column));
    }
    if (innerMapping.originalRange.containsPosition(posInOriginal)) {
        return innerMapping.modifiedRange;
    }
    else {
        const l = lengthBetweenPositions(innerMapping.originalRange.getEndPosition(), posInOriginal);
        return range_1.Range.fromPositions(addLength(innerMapping.modifiedRange.getEndPosition(), l));
    }
}
exports.translatePosition = translatePosition;
function lengthBetweenPositions(position1, position2) {
    if (position1.lineNumber === position2.lineNumber) {
        return new length_1.LengthObj(0, position2.column - position1.column);
    }
    else {
        return new length_1.LengthObj(position2.lineNumber - position1.lineNumber, position2.column - 1);
    }
}
function addLength(position, length) {
    if (length.lineCount === 0) {
        return new position_1.Position(position.lineNumber, position.column + length.columnCount);
    }
    else {
        return new position_1.Position(position.lineNumber + length.lineCount, length.columnCount + 1);
    }
}
function bindContextKey(key, service, computeValue) {
    const boundKey = key.bindTo(service);
    return (0, observable_1.autorunOpts)({ debugName: () => `Set Context Key "${key.key}"` }, reader => {
        boundKey.set(computeValue(reader));
    });
}
exports.bindContextKey = bindContextKey;
function filterWithPrevious(arr, filter) {
    let prev;
    return arr.filter(cur => {
        const result = filter(cur, prev);
        prev = cur;
        return result;
    });
}
exports.filterWithPrevious = filterWithPrevious;
//# sourceMappingURL=utils.js.map