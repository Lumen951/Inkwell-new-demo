{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/editor/contrib/dropOrPasteInto/browser/edit.ts","vs/editor/contrib/dropOrPasteInto/browser/edit.ts"],"names":[],"mappings":"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","file":"edit.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri';\nimport { ResourceTextEdit } from '../../../browser/services/bulkEditService';\nimport { DropYieldTo, WorkspaceEdit } from '../../../common/languages';\nimport { Range } from '../../../common/core/range';\nimport { SnippetParser } from '../../snippet/browser/snippetParser';\n\nexport interface DropOrPasteEdit {\n\treadonly label: string;\n\treadonly insertText: string | { readonly snippet: string };\n\treadonly additionalEdit?: WorkspaceEdit;\n}\n\n/**\n * Given a {@link DropOrPasteEdit} and set of ranges, creates a {@link WorkspaceEdit} that applies the insert text from\n * the {@link DropOrPasteEdit} at each range plus any additional edits.\n */\nexport function createCombinedWorkspaceEdit(uri: URI, ranges: readonly Range[], edit: DropOrPasteEdit): WorkspaceEdit {\n\t// If the edit insert text is empty, skip applying at each range\n\tif (typeof edit.insertText === 'string' ? edit.insertText === '' : edit.insertText.snippet === '') {\n\t\treturn {\n\t\t\tedits: edit.additionalEdit?.edits ?? []\n\t\t};\n\t}\n\n\treturn {\n\t\tedits: [\n\t\t\t...ranges.map(range =>\n\t\t\t\tnew ResourceTextEdit(uri,\n\t\t\t\t\t{ range, text: typeof edit.insertText === 'string' ? SnippetParser.escape(edit.insertText) + '$0' : edit.insertText.snippet, insertAsSnippet: true }\n\t\t\t\t)),\n\t\t\t...(edit.additionalEdit?.edits ?? [])\n\t\t]\n\t};\n}\n\nexport function sortEditsByYieldTo<T extends {\n\treadonly providerId: string | undefined;\n\treadonly handledMimeType?: string;\n\treadonly yieldTo?: readonly DropYieldTo[];\n}>(edits: readonly T[]): T[] {\n\tfunction yieldsTo(yTo: DropYieldTo, other: T): boolean {\n\t\treturn ('providerId' in yTo && yTo.providerId === other.providerId)\n\t\t\t|| ('mimeType' in yTo && yTo.mimeType === other.handledMimeType);\n\t}\n\n\t// Build list of nodes each node yields to\n\tconst yieldsToMap = new Map<T, T[]>();\n\tfor (const edit of edits) {\n\t\tfor (const yTo of edit.yieldTo ?? []) {\n\t\t\tfor (const other of edits) {\n\t\t\t\tif (other === edit) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (yieldsTo(yTo, other)) {\n\t\t\t\t\tlet arr = yieldsToMap.get(edit);\n\t\t\t\t\tif (!arr) {\n\t\t\t\t\t\tarr = [];\n\t\t\t\t\t\tyieldsToMap.set(edit, arr);\n\t\t\t\t\t}\n\t\t\t\t\tarr.push(other);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!yieldsToMap.size) {\n\t\treturn Array.from(edits);\n\t}\n\n\t// Topological sort\n\tconst visited = new Set<T>();\n\tconst tempStack: T[] = [];\n\n\tfunction visit(nodes: T[]): T[] {\n\t\tif (!nodes.length) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst node = nodes[0];\n\t\tif (tempStack.includes(node)) {\n\t\t\tconsole.warn(`Yield to cycle detected for ${node.providerId}`);\n\t\t\treturn nodes;\n\t\t}\n\n\t\tif (visited.has(node)) {\n\t\t\treturn visit(nodes.slice(1));\n\t\t}\n\n\t\tlet pre: T[] = [];\n\t\tconst yTo = yieldsToMap.get(node);\n\t\tif (yTo) {\n\t\t\ttempStack.push(node);\n\t\t\tpre = visit(yTo);\n\t\t\ttempStack.pop();\n\t\t}\n\n\t\tvisited.add(node);\n\n\t\treturn [...pre, node, ...visit(nodes.slice(1))];\n\t}\n\n\treturn visit(Array.from(edits));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from '../../../../base/common/uri';\nimport { ResourceTextEdit } from '../../../browser/services/bulkEditService';\nimport { DropYieldTo, WorkspaceEdit } from '../../../common/languages';\nimport { Range } from '../../../common/core/range';\nimport { SnippetParser } from '../../snippet/browser/snippetParser';\n\nexport interface DropOrPasteEdit {\n\treadonly label: string;\n\treadonly insertText: string | { readonly snippet: string };\n\treadonly additionalEdit?: WorkspaceEdit;\n}\n\n/**\n * Given a {@link DropOrPasteEdit} and set of ranges, creates a {@link WorkspaceEdit} that applies the insert text from\n * the {@link DropOrPasteEdit} at each range plus any additional edits.\n */\nexport function createCombinedWorkspaceEdit(uri: URI, ranges: readonly Range[], edit: DropOrPasteEdit): WorkspaceEdit {\n\t// If the edit insert text is empty, skip applying at each range\n\tif (typeof edit.insertText === 'string' ? edit.insertText === '' : edit.insertText.snippet === '') {\n\t\treturn {\n\t\t\tedits: edit.additionalEdit?.edits ?? []\n\t\t};\n\t}\n\n\treturn {\n\t\tedits: [\n\t\t\t...ranges.map(range =>\n\t\t\t\tnew ResourceTextEdit(uri,\n\t\t\t\t\t{ range, text: typeof edit.insertText === 'string' ? SnippetParser.escape(edit.insertText) + '$0' : edit.insertText.snippet, insertAsSnippet: true }\n\t\t\t\t)),\n\t\t\t...(edit.additionalEdit?.edits ?? [])\n\t\t]\n\t};\n}\n\nexport function sortEditsByYieldTo<T extends {\n\treadonly providerId: string | undefined;\n\treadonly handledMimeType?: string;\n\treadonly yieldTo?: readonly DropYieldTo[];\n}>(edits: readonly T[]): T[] {\n\tfunction yieldsTo(yTo: DropYieldTo, other: T): boolean {\n\t\treturn ('providerId' in yTo && yTo.providerId === other.providerId)\n\t\t\t|| ('mimeType' in yTo && yTo.mimeType === other.handledMimeType);\n\t}\n\n\t// Build list of nodes each node yields to\n\tconst yieldsToMap = new Map<T, T[]>();\n\tfor (const edit of edits) {\n\t\tfor (const yTo of edit.yieldTo ?? []) {\n\t\t\tfor (const other of edits) {\n\t\t\t\tif (other === edit) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (yieldsTo(yTo, other)) {\n\t\t\t\t\tlet arr = yieldsToMap.get(edit);\n\t\t\t\t\tif (!arr) {\n\t\t\t\t\t\tarr = [];\n\t\t\t\t\t\tyieldsToMap.set(edit, arr);\n\t\t\t\t\t}\n\t\t\t\t\tarr.push(other);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!yieldsToMap.size) {\n\t\treturn Array.from(edits);\n\t}\n\n\t// Topological sort\n\tconst visited = new Set<T>();\n\tconst tempStack: T[] = [];\n\n\tfunction visit(nodes: T[]): T[] {\n\t\tif (!nodes.length) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst node = nodes[0];\n\t\tif (tempStack.includes(node)) {\n\t\t\tconsole.warn(`Yield to cycle detected for ${node.providerId}`);\n\t\t\treturn nodes;\n\t\t}\n\n\t\tif (visited.has(node)) {\n\t\t\treturn visit(nodes.slice(1));\n\t\t}\n\n\t\tlet pre: T[] = [];\n\t\tconst yTo = yieldsToMap.get(node);\n\t\tif (yTo) {\n\t\t\ttempStack.push(node);\n\t\t\tpre = visit(yTo);\n\t\t\ttempStack.pop();\n\t\t}\n\n\t\tvisited.add(node);\n\n\t\treturn [...pre, node, ...visit(nodes.slice(1))];\n\t}\n\n\treturn visit(Array.from(edits));\n}\n"]}