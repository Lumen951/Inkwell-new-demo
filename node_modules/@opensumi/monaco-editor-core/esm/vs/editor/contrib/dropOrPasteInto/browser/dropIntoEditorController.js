"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var DropIntoEditorController_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DropIntoEditorController = exports.dropWidgetVisibleCtx = exports.changeDropTypeCommandId = exports.defaultProviderConfig = void 0;
const arrays_1 = require("../../../../base/common/arrays");
const async_1 = require("../../../../base/common/async");
const dataTransfer_1 = require("../../../../base/common/dataTransfer");
const lifecycle_1 = require("../../../../base/common/lifecycle");
const dnd_1 = require("../../../browser/dnd");
const range_1 = require("../../../common/core/range");
const languageFeatures_1 = require("../../../common/services/languageFeatures");
const treeViewsDnd_1 = require("../../../common/services/treeViewsDnd");
const treeViewsDndService_1 = require("../../../common/services/treeViewsDndService");
const editorState_1 = require("../../editorState/browser/editorState");
const inlineProgress_1 = require("../../inlineProgress/browser/inlineProgress");
const nls_1 = require("../../../../nls");
const configuration_1 = require("../../../../platform/configuration/common/configuration");
const contextkey_1 = require("../../../../platform/contextkey/common/contextkey");
const dnd_2 = require("../../../../platform/dnd/browser/dnd");
const instantiation_1 = require("../../../../platform/instantiation/common/instantiation");
const edit_1 = require("./edit");
const postEditWidget_1 = require("./postEditWidget");
exports.defaultProviderConfig = 'editor.experimental.dropIntoEditor.defaultProvider';
exports.changeDropTypeCommandId = 'editor.changeDropType';
exports.dropWidgetVisibleCtx = new contextkey_1.RawContextKey('dropWidgetVisible', false, (0, nls_1.localize)("vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController",0, "Whether the drop widget is showing"));
let DropIntoEditorController = DropIntoEditorController_1 = class DropIntoEditorController extends lifecycle_1.Disposable {
    static get(editor) {
        return editor.getContribution(DropIntoEditorController_1.ID);
    }
    constructor(editor, instantiationService, _configService, _languageFeaturesService, _treeViewsDragAndDropService) {
        super();
        this._configService = _configService;
        this._languageFeaturesService = _languageFeaturesService;
        this._treeViewsDragAndDropService = _treeViewsDragAndDropService;
        this.treeItemsTransfer = dnd_2.LocalSelectionTransfer.getInstance();
        this._dropProgressManager = this._register(instantiationService.createInstance(inlineProgress_1.InlineProgressManager, 'dropIntoEditor', editor));
        this._postDropWidgetManager = this._register(instantiationService.createInstance(postEditWidget_1.PostEditWidgetManager, 'dropIntoEditor', editor, exports.dropWidgetVisibleCtx, { id: exports.changeDropTypeCommandId, label: (0, nls_1.localize)("vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController",1, "Show drop options...") }));
        this._register(editor.onDropIntoEditor(e => this.onDropIntoEditor(editor, e.position, e.event)));
    }
    clearWidgets() {
        this._postDropWidgetManager.clear();
    }
    changeDropType() {
        this._postDropWidgetManager.tryShowSelector();
    }
    async onDropIntoEditor(editor, position, dragEvent) {
        var _a;
        if (!dragEvent.dataTransfer || !editor.hasModel()) {
            return;
        }
        (_a = this._currentOperation) === null || _a === void 0 ? void 0 : _a.cancel();
        editor.focus();
        editor.setPosition(position);
        const p = (0, async_1.createCancelablePromise)(async (token) => {
            const tokenSource = new editorState_1.EditorStateCancellationTokenSource(editor, 1 /* CodeEditorStateFlag.Value */, undefined, token);
            try {
                const ourDataTransfer = await this.extractDataTransferData(dragEvent);
                if (ourDataTransfer.size === 0 || tokenSource.token.isCancellationRequested) {
                    return;
                }
                const model = editor.getModel();
                if (!model) {
                    return;
                }
                const providers = this._languageFeaturesService.documentOnDropEditProvider
                    .ordered(model)
                    .filter(provider => {
                    if (!provider.dropMimeTypes) {
                        // Keep all providers that don't specify mime types
                        return true;
                    }
                    return provider.dropMimeTypes.some(mime => ourDataTransfer.matches(mime));
                });
                const edits = await this.getDropEdits(providers, model, position, ourDataTransfer, tokenSource);
                if (tokenSource.token.isCancellationRequested) {
                    return;
                }
                if (edits.length) {
                    const activeEditIndex = this.getInitialActiveEditIndex(model, edits);
                    const canShowWidget = editor.getOption(36 /* EditorOption.dropIntoEditor */).showDropSelector === 'afterDrop';
                    // Pass in the parent token here as it tracks cancelling the entire drop operation
                    await this._postDropWidgetManager.applyEditAndShowIfNeeded([range_1.Range.fromPositions(position)], { activeEditIndex, allEdits: edits }, canShowWidget, token);
                }
            }
            finally {
                tokenSource.dispose();
                if (this._currentOperation === p) {
                    this._currentOperation = undefined;
                }
            }
        });
        this._dropProgressManager.showWhile(position, (0, nls_1.localize)("vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController",2, "Running drop handlers. Click to cancel"), p);
        this._currentOperation = p;
    }
    async getDropEdits(providers, model, position, dataTransfer, tokenSource) {
        const results = await (0, async_1.raceCancellation)(Promise.all(providers.map(async (provider) => {
            try {
                const edit = await provider.provideDocumentOnDropEdits(model, position, dataTransfer, tokenSource.token);
                if (edit) {
                    return { ...edit, providerId: provider.id };
                }
            }
            catch (err) {
                console.error(err);
            }
            return undefined;
        })), tokenSource.token);
        const edits = (0, arrays_1.coalesce)(results !== null && results !== void 0 ? results : []);
        return (0, edit_1.sortEditsByYieldTo)(edits);
    }
    getInitialActiveEditIndex(model, edits) {
        const preferredProviders = this._configService.getValue(exports.defaultProviderConfig, { resource: model.uri });
        for (const [configMime, desiredId] of Object.entries(preferredProviders)) {
            const editIndex = edits.findIndex(edit => desiredId === edit.providerId
                && edit.handledMimeType && (0, dataTransfer_1.matchesMimeType)(configMime, [edit.handledMimeType]));
            if (editIndex >= 0) {
                return editIndex;
            }
        }
        return 0;
    }
    async extractDataTransferData(dragEvent) {
        if (!dragEvent.dataTransfer) {
            return new dataTransfer_1.VSDataTransfer();
        }
        const dataTransfer = (0, dnd_1.toExternalVSDataTransfer)(dragEvent.dataTransfer);
        if (this.treeItemsTransfer.hasData(treeViewsDnd_1.DraggedTreeItemsIdentifier.prototype)) {
            const data = this.treeItemsTransfer.getData(treeViewsDnd_1.DraggedTreeItemsIdentifier.prototype);
            if (Array.isArray(data)) {
                for (const id of data) {
                    const treeDataTransfer = await this._treeViewsDragAndDropService.removeDragOperationTransfer(id.identifier);
                    if (treeDataTransfer) {
                        for (const [type, value] of treeDataTransfer) {
                            dataTransfer.replace(type, value);
                        }
                    }
                }
            }
        }
        return dataTransfer;
    }
};
exports.DropIntoEditorController = DropIntoEditorController;
DropIntoEditorController.ID = 'editor.contrib.dropIntoEditorController';
exports.DropIntoEditorController = DropIntoEditorController = DropIntoEditorController_1 = __decorate([
    __param(1, instantiation_1.IInstantiationService),
    __param(2, configuration_1.IConfigurationService),
    __param(3, languageFeatures_1.ILanguageFeaturesService),
    __param(4, treeViewsDndService_1.ITreeViewsDnDService)
], DropIntoEditorController);
//# sourceMappingURL=dropIntoEditorController.js.map