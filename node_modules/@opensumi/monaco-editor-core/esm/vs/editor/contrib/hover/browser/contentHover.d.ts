import * as dom from '../../../../base/browser/dom';
import { Disposable, DisposableStore } from '../../../../base/common/lifecycle';
import { ICodeEditor, IContentWidgetPosition, IEditorMouseEvent } from '../../../browser/editorBrowser';
import { Position } from '../../../common/core/position';
import { Range } from '../../../common/core/range';
import { HoverStartMode, HoverStartSource } from './hoverOperation';
import { IEditorHoverColorPickerWidget, IEditorHoverAction, IEditorHoverStatusBar, IHoverPart } from './hoverTypes';
import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation';
import { IKeybindingService } from '../../../../platform/keybinding/common/keybinding';
import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey';
import { ResizableContentWidget } from './resizableContentWidget';
import { IConfigurationService } from '../../../../platform/configuration/common/configuration';
import { IAccessibilityService } from '../../../../platform/accessibility/common/accessibility';
export declare class ContentHoverController extends Disposable {
    private readonly _editor;
    private readonly _instantiationService;
    private readonly _keybindingService;
    private _currentResult;
    private readonly _computer;
    private readonly _widget;
    private readonly _participants;
    private readonly _hoverOperation;
    constructor(_editor: ICodeEditor, _instantiationService: IInstantiationService, _keybindingService: IKeybindingService);
    /**
     * Returns true if the hover shows now or will show.
     */
    private _startShowingOrUpdateHover;
    private _startHoverOperationIfNecessary;
    private _setCurrentResult;
    private _addLoadingMessage;
    private _withResult;
    private _renderMessages;
    private static readonly _DECORATION_OPTIONS;
    static computeHoverRanges(editor: ICodeEditor, anchorRange: Range, messages: IHoverPart[]): {
        showAtPosition: Position;
        showAtSecondaryPosition: Position;
        highlightRange: Range;
    };
    /**
     * Returns true if the hover shows now or will show.
     */
    showsOrWillShow(mouseEvent: IEditorMouseEvent): boolean;
    startShowingAtRange(range: Range, mode: HoverStartMode, source: HoverStartSource, focus: boolean): void;
    getWidgetContent(): string | undefined;
    containsNode(node: Node | null | undefined): boolean;
    focus(): void;
    scrollUp(): void;
    scrollDown(): void;
    scrollLeft(): void;
    scrollRight(): void;
    pageUp(): void;
    pageDown(): void;
    goToTop(): void;
    goToBottom(): void;
    hide(): void;
    get isColorPickerVisible(): boolean;
    get isVisibleFromKeyboard(): boolean;
    get isVisible(): boolean;
    get isFocused(): boolean;
    get isResizing(): boolean;
    get widget(): ContentHoverWidget;
}
declare class ContentHoverVisibleData {
    initialMousePosX: number | undefined;
    initialMousePosY: number | undefined;
    readonly colorPicker: IEditorHoverColorPickerWidget | null;
    readonly showAtPosition: Position;
    readonly showAtSecondaryPosition: Position;
    readonly preferAbove: boolean;
    readonly stoleFocus: boolean;
    readonly source: HoverStartSource;
    readonly isBeforeContent: boolean;
    readonly disposables: DisposableStore;
    closestMouseDistance: number | undefined;
    constructor(initialMousePosX: number | undefined, initialMousePosY: number | undefined, colorPicker: IEditorHoverColorPickerWidget | null, showAtPosition: Position, showAtSecondaryPosition: Position, preferAbove: boolean, stoleFocus: boolean, source: HoverStartSource, isBeforeContent: boolean, disposables: DisposableStore);
}
export declare class ContentHoverWidget extends ResizableContentWidget {
    private readonly _configurationService;
    private readonly _accessibilityService;
    private readonly _keybindingService;
    static ID: string;
    private static _lastDimensions;
    private _visibleData;
    private _positionPreference;
    private _minimumSize;
    private _contentWidth;
    private readonly _hover;
    private readonly _hoverVisibleKey;
    private readonly _hoverFocusedKey;
    get isColorPickerVisible(): boolean;
    get isVisibleFromKeyboard(): boolean;
    get isVisible(): boolean;
    get isFocused(): boolean;
    constructor(editor: ICodeEditor, contextKeyService: IContextKeyService, _configurationService: IConfigurationService, _accessibilityService: IAccessibilityService, _keybindingService: IKeybindingService);
    dispose(): void;
    getId(): string;
    private static _applyDimensions;
    private _setContentsDomNodeDimensions;
    private _setContainerDomNodeDimensions;
    private _setHoverWidgetDimensions;
    private static _applyMaxDimensions;
    private _setHoverWidgetMaxDimensions;
    private _hasHorizontalScrollbar;
    private _adjustContentsBottomPadding;
    private _setAdjustedHoverWidgetDimensions;
    private _updateResizableNodeMaxDimensions;
    protected _resize(size: dom.Dimension): void;
    private _findAvailableSpaceVertically;
    private _findMaximumRenderingHeight;
    private _isHoverTextOverflowing;
    private _findMaximumRenderingWidth;
    isMouseGettingCloser(posx: number, posy: number): boolean;
    private _setHoverData;
    private _updateFont;
    private _updateContent;
    private _layoutContentWidget;
    private _updateMaxDimensions;
    private _render;
    getPosition(): IContentWidgetPosition | null;
    showAt(node: DocumentFragment, hoverData: ContentHoverVisibleData): void;
    hide(): void;
    private _removeConstraintsRenderNormally;
    private _adjustHoverHeightForScrollbar;
    setMinimumDimensions(dimensions: dom.Dimension): void;
    private _updateMinimumWidth;
    onContentsChanged(): void;
    focus(): void;
    scrollUp(): void;
    scrollDown(): void;
    scrollLeft(): void;
    scrollRight(): void;
    pageUp(): void;
    pageDown(): void;
    goToTop(): void;
    goToBottom(): void;
}
export declare class EditorHoverStatusBar extends Disposable implements IEditorHoverStatusBar {
    private readonly _keybindingService;
    readonly hoverElement: HTMLElement;
    private readonly actionsElement;
    private _hasContent;
    get hasContent(): boolean;
    constructor(_keybindingService: IKeybindingService);
    addAction(actionOptions: {
        label: string;
        iconClass?: string;
        run: (target: HTMLElement) => void;
        commandId: string;
    }): IEditorHoverAction;
    append(element: HTMLElement): HTMLElement;
}
export {};
