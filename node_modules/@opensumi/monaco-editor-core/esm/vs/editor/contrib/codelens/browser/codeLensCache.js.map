{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/editor/contrib/codelens/browser/codeLensCache.ts","vs/editor/contrib/codelens/browser/codeLensCache.ts"],"names":[],"mappings":"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","file":"codeLensCache.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event';\nimport { LRUCache } from '../../../../base/common/map';\nimport { Range } from '../../../common/core/range';\nimport { ITextModel } from '../../../common/model';\nimport { CodeLens, CodeLensList, CodeLensProvider } from '../../../common/languages';\nimport { CodeLensModel } from './codelens';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation';\nimport { IStorageService, StorageScope, StorageTarget, WillSaveStateReason } from '../../../../platform/storage/common/storage';\nimport { mainWindow } from '../../../../base/browser/window';\nimport { runWhenWindowIdle } from '../../../../base/browser/dom';\n\nexport const ICodeLensCache = createDecorator<ICodeLensCache>('ICodeLensCache');\n\nexport interface ICodeLensCache {\n\treadonly _serviceBrand: undefined;\n\tput(model: ITextModel, data: CodeLensModel): void;\n\tget(model: ITextModel): CodeLensModel | undefined;\n\tdelete(model: ITextModel): void;\n}\n\ninterface ISerializedCacheData {\n\tlineCount: number;\n\tlines: number[];\n}\n\nclass CacheItem {\n\n\tconstructor(\n\t\treadonly lineCount: number,\n\t\treadonly data: CodeLensModel\n\t) { }\n}\n\nexport class CodeLensCache implements ICodeLensCache {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _fakeProvider = new class implements CodeLensProvider {\n\t\tprovideCodeLenses(): CodeLensList {\n\t\t\tthrow new Error('not supported');\n\t\t}\n\t};\n\n\tprivate readonly _cache = new LRUCache<string, CacheItem>(20, 0.75);\n\n\tconstructor(@IStorageService storageService: IStorageService) {\n\n\t\t// remove old data\n\t\tconst oldkey = 'codelens/cache';\n\t\trunWhenWindowIdle(mainWindow, () => storageService.remove(oldkey, StorageScope.WORKSPACE));\n\n\t\t// restore lens data on start\n\t\tconst key = 'codelens/cache2';\n\t\tconst raw = storageService.get(key, StorageScope.WORKSPACE, '{}');\n\t\tthis._deserialize(raw);\n\n\t\t// store lens data on shutdown\n\t\tEvent.once(storageService.onWillSaveState)(e => {\n\t\t\tif (e.reason === WillSaveStateReason.SHUTDOWN) {\n\t\t\t\tstorageService.store(key, this._serialize(), StorageScope.WORKSPACE, StorageTarget.MACHINE);\n\t\t\t}\n\t\t});\n\t}\n\n\tput(model: ITextModel, data: CodeLensModel): void {\n\t\t// create a copy of the model that is without command-ids\n\t\t// but with comand-labels\n\t\tconst copyItems = data.lenses.map(item => {\n\t\t\treturn <CodeLens>{\n\t\t\t\trange: item.symbol.range,\n\t\t\t\tcommand: item.symbol.command && { id: '', title: item.symbol.command?.title },\n\t\t\t};\n\t\t});\n\t\tconst copyModel = new CodeLensModel();\n\t\tcopyModel.add({ lenses: copyItems, dispose: () => { } }, this._fakeProvider);\n\n\t\tconst item = new CacheItem(model.getLineCount(), copyModel);\n\t\tthis._cache.set(model.uri.toString(), item);\n\t}\n\n\tget(model: ITextModel) {\n\t\tconst item = this._cache.get(model.uri.toString());\n\t\treturn item && item.lineCount === model.getLineCount() ? item.data : undefined;\n\t}\n\n\tdelete(model: ITextModel): void {\n\t\tthis._cache.delete(model.uri.toString());\n\t}\n\n\t// --- persistence\n\n\tprivate _serialize(): string {\n\t\tconst data: Record<string, ISerializedCacheData> = Object.create(null);\n\t\tfor (const [key, value] of this._cache) {\n\t\t\tconst lines = new Set<number>();\n\t\t\tfor (const d of value.data.lenses) {\n\t\t\t\tlines.add(d.symbol.range.startLineNumber);\n\t\t\t}\n\t\t\tdata[key] = {\n\t\t\t\tlineCount: value.lineCount,\n\t\t\t\tlines: [...lines.values()]\n\t\t\t};\n\t\t}\n\t\treturn JSON.stringify(data);\n\t}\n\n\tprivate _deserialize(raw: string): void {\n\t\ttry {\n\t\t\tconst data: Record<string, ISerializedCacheData> = JSON.parse(raw);\n\t\t\tfor (const key in data) {\n\t\t\t\tconst element = data[key];\n\t\t\t\tconst lenses: CodeLens[] = [];\n\t\t\t\tfor (const line of element.lines) {\n\t\t\t\t\tlenses.push({ range: new Range(line, 1, line, 11) });\n\t\t\t\t}\n\n\t\t\t\tconst model = new CodeLensModel();\n\t\t\t\tmodel.add({ lenses, dispose() { } }, this._fakeProvider);\n\t\t\t\tthis._cache.set(key, new CacheItem(element.lineCount, model));\n\t\t\t}\n\t\t} catch {\n\t\t\t// ignore...\n\t\t}\n\t}\n}\n\nregisterSingleton(ICodeLensCache, CodeLensCache, InstantiationType.Delayed);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../../../base/common/event';\nimport { LRUCache } from '../../../../base/common/map';\nimport { Range } from '../../../common/core/range';\nimport { ITextModel } from '../../../common/model';\nimport { CodeLens, CodeLensList, CodeLensProvider } from '../../../common/languages';\nimport { CodeLensModel } from './codelens';\nimport { InstantiationType, registerSingleton } from '../../../../platform/instantiation/common/extensions';\nimport { createDecorator } from '../../../../platform/instantiation/common/instantiation';\nimport { IStorageService, StorageScope, StorageTarget, WillSaveStateReason } from '../../../../platform/storage/common/storage';\nimport { mainWindow } from '../../../../base/browser/window';\nimport { runWhenWindowIdle } from '../../../../base/browser/dom';\n\nexport const ICodeLensCache = createDecorator<ICodeLensCache>('ICodeLensCache');\n\nexport interface ICodeLensCache {\n\treadonly _serviceBrand: undefined;\n\tput(model: ITextModel, data: CodeLensModel): void;\n\tget(model: ITextModel): CodeLensModel | undefined;\n\tdelete(model: ITextModel): void;\n}\n\ninterface ISerializedCacheData {\n\tlineCount: number;\n\tlines: number[];\n}\n\nclass CacheItem {\n\n\tconstructor(\n\t\treadonly lineCount: number,\n\t\treadonly data: CodeLensModel\n\t) { }\n}\n\nexport class CodeLensCache implements ICodeLensCache {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _fakeProvider = new class implements CodeLensProvider {\n\t\tprovideCodeLenses(): CodeLensList {\n\t\t\tthrow new Error('not supported');\n\t\t}\n\t};\n\n\tprivate readonly _cache = new LRUCache<string, CacheItem>(20, 0.75);\n\n\tconstructor(@IStorageService storageService: IStorageService) {\n\n\t\t// remove old data\n\t\tconst oldkey = 'codelens/cache';\n\t\trunWhenWindowIdle(mainWindow, () => storageService.remove(oldkey, StorageScope.WORKSPACE));\n\n\t\t// restore lens data on start\n\t\tconst key = 'codelens/cache2';\n\t\tconst raw = storageService.get(key, StorageScope.WORKSPACE, '{}');\n\t\tthis._deserialize(raw);\n\n\t\t// store lens data on shutdown\n\t\tEvent.once(storageService.onWillSaveState)(e => {\n\t\t\tif (e.reason === WillSaveStateReason.SHUTDOWN) {\n\t\t\t\tstorageService.store(key, this._serialize(), StorageScope.WORKSPACE, StorageTarget.MACHINE);\n\t\t\t}\n\t\t});\n\t}\n\n\tput(model: ITextModel, data: CodeLensModel): void {\n\t\t// create a copy of the model that is without command-ids\n\t\t// but with comand-labels\n\t\tconst copyItems = data.lenses.map(item => {\n\t\t\treturn <CodeLens>{\n\t\t\t\trange: item.symbol.range,\n\t\t\t\tcommand: item.symbol.command && { id: '', title: item.symbol.command?.title },\n\t\t\t};\n\t\t});\n\t\tconst copyModel = new CodeLensModel();\n\t\tcopyModel.add({ lenses: copyItems, dispose: () => { } }, this._fakeProvider);\n\n\t\tconst item = new CacheItem(model.getLineCount(), copyModel);\n\t\tthis._cache.set(model.uri.toString(), item);\n\t}\n\n\tget(model: ITextModel) {\n\t\tconst item = this._cache.get(model.uri.toString());\n\t\treturn item && item.lineCount === model.getLineCount() ? item.data : undefined;\n\t}\n\n\tdelete(model: ITextModel): void {\n\t\tthis._cache.delete(model.uri.toString());\n\t}\n\n\t// --- persistence\n\n\tprivate _serialize(): string {\n\t\tconst data: Record<string, ISerializedCacheData> = Object.create(null);\n\t\tfor (const [key, value] of this._cache) {\n\t\t\tconst lines = new Set<number>();\n\t\t\tfor (const d of value.data.lenses) {\n\t\t\t\tlines.add(d.symbol.range.startLineNumber);\n\t\t\t}\n\t\t\tdata[key] = {\n\t\t\t\tlineCount: value.lineCount,\n\t\t\t\tlines: [...lines.values()]\n\t\t\t};\n\t\t}\n\t\treturn JSON.stringify(data);\n\t}\n\n\tprivate _deserialize(raw: string): void {\n\t\ttry {\n\t\t\tconst data: Record<string, ISerializedCacheData> = JSON.parse(raw);\n\t\t\tfor (const key in data) {\n\t\t\t\tconst element = data[key];\n\t\t\t\tconst lenses: CodeLens[] = [];\n\t\t\t\tfor (const line of element.lines) {\n\t\t\t\t\tlenses.push({ range: new Range(line, 1, line, 11) });\n\t\t\t\t}\n\n\t\t\t\tconst model = new CodeLensModel();\n\t\t\t\tmodel.add({ lenses, dispose() { } }, this._fakeProvider);\n\t\t\t\tthis._cache.set(key, new CacheItem(element.lineCount, model));\n\t\t\t}\n\t\t} catch {\n\t\t\t// ignore...\n\t\t}\n\t}\n}\n\nregisterSingleton(ICodeLensCache, CodeLensCache, InstantiationType.Delayed);\n"]}