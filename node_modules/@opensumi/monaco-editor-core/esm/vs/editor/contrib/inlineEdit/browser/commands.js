"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.RejectInlineEdit = exports.JumpBackInlineEdit = exports.JumpToInlineEdit = exports.TriggerInlineEdit = exports.AcceptInlineEdit = void 0;
const editorExtensions_1 = require("../../../browser/editorExtensions");
const editorContextKeys_1 = require("../../../common/editorContextKeys");
const commandIds_1 = require("./commandIds");
const inlineEditController_1 = require("./inlineEditController");
const actions_1 = require("../../../../platform/actions/common/actions");
const contextkey_1 = require("../../../../platform/contextkey/common/contextkey");
class AcceptInlineEdit extends editorExtensions_1.EditorAction {
    constructor() {
        super({
            id: commandIds_1.inlineEditAcceptId,
            label: 'Accept Inline Edit',
            alias: 'Accept Inline Edit',
            precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, inlineEditController_1.InlineEditController.inlineEditVisibleContext),
            kbOpts: [
                {
                    weight: 100 /* KeybindingWeight.EditorContrib */ + 1,
                    primary: 2 /* KeyCode.Tab */,
                    kbExpr: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, inlineEditController_1.InlineEditController.inlineEditVisibleContext, inlineEditController_1.InlineEditController.cursorAtInlineEditContext)
                }
            ],
            menuOpts: [{
                    menuId: actions_1.MenuId.InlineEditToolbar,
                    title: 'Accept',
                    group: 'primary',
                    order: 1,
                }],
        });
    }
    async run(accessor, editor) {
        const controller = inlineEditController_1.InlineEditController.get(editor);
        controller === null || controller === void 0 ? void 0 : controller.accept();
    }
}
exports.AcceptInlineEdit = AcceptInlineEdit;
class TriggerInlineEdit extends editorExtensions_1.EditorAction {
    constructor() {
        const activeExpr = contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, contextkey_1.ContextKeyExpr.not(inlineEditController_1.InlineEditController.inlineEditVisibleKey));
        super({
            id: 'editor.action.inlineEdit.trigger',
            label: 'Trigger Inline Edit',
            alias: 'Trigger Inline Edit',
            precondition: activeExpr,
            kbOpts: {
                weight: 100 /* KeybindingWeight.EditorContrib */ + 1,
                primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 86 /* KeyCode.Equal */,
                kbExpr: activeExpr
            },
        });
    }
    async run(accessor, editor) {
        const controller = inlineEditController_1.InlineEditController.get(editor);
        controller === null || controller === void 0 ? void 0 : controller.trigger();
    }
}
exports.TriggerInlineEdit = TriggerInlineEdit;
class JumpToInlineEdit extends editorExtensions_1.EditorAction {
    constructor() {
        const activeExpr = contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, inlineEditController_1.InlineEditController.inlineEditVisibleContext, contextkey_1.ContextKeyExpr.not(inlineEditController_1.InlineEditController.cursorAtInlineEditKey));
        super({
            id: commandIds_1.inlineEditJumpToId,
            label: 'Jump to Inline Edit',
            alias: 'Jump to Inline Edit',
            precondition: activeExpr,
            kbOpts: {
                weight: 100 /* KeybindingWeight.EditorContrib */ + 1,
                primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 86 /* KeyCode.Equal */,
                kbExpr: activeExpr
            },
            menuOpts: [{
                    menuId: actions_1.MenuId.InlineEditToolbar,
                    title: 'Jump To Edit',
                    group: 'primary',
                    order: 3,
                    when: activeExpr
                }],
        });
    }
    async run(accessor, editor) {
        const controller = inlineEditController_1.InlineEditController.get(editor);
        controller === null || controller === void 0 ? void 0 : controller.jumpToCurrent();
    }
}
exports.JumpToInlineEdit = JumpToInlineEdit;
class JumpBackInlineEdit extends editorExtensions_1.EditorAction {
    constructor() {
        const activeExpr = contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, inlineEditController_1.InlineEditController.cursorAtInlineEditContext);
        super({
            id: commandIds_1.inlineEditJumpBackId,
            label: 'Jump Back from Inline Edit',
            alias: 'Jump Back from Inline Edit',
            precondition: activeExpr,
            kbOpts: {
                weight: 100 /* KeybindingWeight.EditorContrib */ + 10,
                primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 86 /* KeyCode.Equal */,
                kbExpr: activeExpr
            },
            menuOpts: [{
                    menuId: actions_1.MenuId.InlineEditToolbar,
                    title: 'Jump Back',
                    group: 'primary',
                    order: 3,
                    when: activeExpr
                }],
        });
    }
    async run(accessor, editor) {
        const controller = inlineEditController_1.InlineEditController.get(editor);
        controller === null || controller === void 0 ? void 0 : controller.jumpBack();
    }
}
exports.JumpBackInlineEdit = JumpBackInlineEdit;
class RejectInlineEdit extends editorExtensions_1.EditorAction {
    constructor() {
        const activeExpr = contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, inlineEditController_1.InlineEditController.inlineEditVisibleContext);
        super({
            id: commandIds_1.inlineEditRejectId,
            label: 'Reject Inline Edit',
            alias: 'Reject Inline Edit',
            precondition: activeExpr,
            kbOpts: {
                weight: 100 /* KeybindingWeight.EditorContrib */,
                primary: 9 /* KeyCode.Escape */,
                kbExpr: activeExpr
            },
            menuOpts: [{
                    menuId: actions_1.MenuId.InlineEditToolbar,
                    title: 'Reject',
                    group: 'secondary',
                    order: 2,
                }],
        });
    }
    async run(accessor, editor) {
        const controller = inlineEditController_1.InlineEditController.get(editor);
        controller === null || controller === void 0 ? void 0 : controller.clear();
    }
}
exports.RejectInlineEdit = RejectInlineEdit;
//# sourceMappingURL=commands.js.map