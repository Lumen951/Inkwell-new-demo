{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/editor/contrib/stickyScroll/browser/stickyScrollModelProvider.ts","vs/editor/contrib/stickyScroll/browser/stickyScrollModelProvider.ts"],"names":[],"mappings":"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","file":"stickyScrollModelProvider.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle';\nimport { ICodeEditor } from '../../../browser/editorBrowser';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures';\nimport { OutlineElement, OutlineGroup, OutlineModel } from '../../documentSymbols/browser/outlineModel';\nimport { CancellationToken } from '../../../../base/common/cancellation';\nimport { CancelablePromise, createCancelablePromise, Delayer } from '../../../../base/common/async';\nimport { FoldingController, RangesLimitReporter } from '../../folding/browser/folding';\nimport { ITextModel } from '../../../common/model';\nimport { SyntaxRangeProvider } from '../../folding/browser/syntaxRangeProvider';\nimport { IndentRangeProvider } from '../../folding/browser/indentRangeProvider';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry';\nimport { FoldingRegions } from '../../folding/browser/foldingRanges';\nimport { onUnexpectedError } from '../../../../base/common/errors';\nimport { TextModel } from '../../../common/model/textModel';\nimport { StickyElement, StickyModel, StickyRange } from './stickyScrollElement';\nimport { Iterable } from '../../../../base/common/iterator';\nimport { LanguageFeatureRegistry } from '../../../common/languageFeatureRegistry';\n\nenum ModelProvider {\n\tOUTLINE_MODEL = 'outlineModel',\n\tFOLDING_PROVIDER_MODEL = 'foldingProviderModel',\n\tINDENTATION_MODEL = 'indentationModel'\n}\n\nenum Status {\n\tVALID,\n\tINVALID,\n\tCANCELED\n}\n\nexport interface IStickyModelProvider {\n\n\t/**\n\t * Method which updates the sticky model\n\t * @param textModel text-model of the editor\n\t * @param textModelVersionId text-model version ID\n\t * @param token cancellation token\n\t * @returns the sticky model\n\t */\n\tupdate(textModel: ITextModel, textModelVersionId: number, token: CancellationToken): Promise<StickyModel | null>;\n}\n\nexport class StickyModelProvider extends Disposable implements IStickyModelProvider {\n\n\tprivate _modelProviders: IStickyModelCandidateProvider<any>[] = [];\n\tprivate _modelPromise: CancelablePromise<any | null> | null = null;\n\tprivate _updateScheduler: Delayer<StickyModel | null> = this._register(new Delayer<StickyModel | null>(300));\n\tprivate readonly _updateOperation: DisposableStore = this._register(new DisposableStore());\n\n\tconstructor(\n\t\tprivate readonly _editor: ICodeEditor,\n\t\t@ILanguageConfigurationService readonly _languageConfigurationService: ILanguageConfigurationService,\n\t\t@ILanguageFeaturesService readonly _languageFeaturesService: ILanguageFeaturesService,\n\t\tdefaultModel: string\n\t) {\n\t\tsuper();\n\n\t\tconst stickyModelFromCandidateOutlineProvider = new StickyModelFromCandidateOutlineProvider(_languageFeaturesService);\n\t\tconst stickyModelFromSyntaxFoldingProvider = new StickyModelFromCandidateSyntaxFoldingProvider(this._editor, _languageFeaturesService);\n\t\tconst stickyModelFromIndentationFoldingProvider = new StickyModelFromCandidateIndentationFoldingProvider(this._editor, _languageConfigurationService);\n\n\t\tswitch (defaultModel) {\n\t\t\tcase ModelProvider.OUTLINE_MODEL:\n\t\t\t\tthis._modelProviders.push(stickyModelFromCandidateOutlineProvider);\n\t\t\t\tthis._modelProviders.push(stickyModelFromSyntaxFoldingProvider);\n\t\t\t\tthis._modelProviders.push(stickyModelFromIndentationFoldingProvider);\n\t\t\t\tbreak;\n\t\t\tcase ModelProvider.FOLDING_PROVIDER_MODEL:\n\t\t\t\tthis._modelProviders.push(stickyModelFromSyntaxFoldingProvider);\n\t\t\t\tthis._modelProviders.push(stickyModelFromIndentationFoldingProvider);\n\t\t\t\tbreak;\n\t\t\tcase ModelProvider.INDENTATION_MODEL:\n\t\t\t\tthis._modelProviders.push(stickyModelFromIndentationFoldingProvider);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate _cancelModelPromise(): void {\n\t\tif (this._modelPromise) {\n\t\t\tthis._modelPromise.cancel();\n\t\t\tthis._modelPromise = null;\n\t\t}\n\t}\n\n\tpublic async update(textModel: ITextModel, textModelVersionId: number, token: CancellationToken): Promise<StickyModel | null> {\n\n\t\tthis._updateOperation.clear();\n\t\tthis._updateOperation.add({\n\t\t\tdispose: () => {\n\t\t\t\tthis._cancelModelPromise();\n\t\t\t\tthis._updateScheduler.cancel();\n\t\t\t}\n\t\t});\n\t\tthis._cancelModelPromise();\n\n\t\treturn await this._updateScheduler.trigger(async () => {\n\n\t\t\tfor (const modelProvider of this._modelProviders) {\n\t\t\t\tconst { statusPromise, modelPromise } = modelProvider.computeStickyModel(\n\t\t\t\t\ttextModel,\n\t\t\t\t\ttextModelVersionId,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tthis._modelPromise = modelPromise;\n\t\t\t\tconst status = await statusPromise;\n\t\t\t\tif (this._modelPromise !== modelPromise) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tswitch (status) {\n\t\t\t\t\tcase Status.CANCELED:\n\t\t\t\t\t\tthis._updateOperation.clear();\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tcase Status.VALID:\n\t\t\t\t\t\treturn modelProvider.stickyModel;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}).catch((error) => {\n\t\t\tonUnexpectedError(error);\n\t\t\treturn null;\n\t\t});\n\t}\n}\n\ninterface IStickyModelCandidateProvider<T> {\n\tget stickyModel(): StickyModel | null;\n\n\tget provider(): LanguageFeatureRegistry<object> | null;\n\n\t/**\n\t * Method which computes the sticky model and returns a status to signal whether the sticky model has been successfully found\n\t * @param textmodel text-model of the editor\n\t * @param modelVersionId version ID of the text-model\n\t * @param token cancellation token\n\t * @returns a promise of a status indicating whether the sticky model has been successfully found as well as the model promise\n\t */\n\tcomputeStickyModel(textmodel: ITextModel, modelVersionId: number, token: CancellationToken): { statusPromise: Promise<Status> | Status; modelPromise: CancelablePromise<T | null> | null };\n}\n\nabstract class StickyModelCandidateProvider<T> implements IStickyModelCandidateProvider<T> {\n\n\tprotected _stickyModel: StickyModel | null = null;\n\n\tconstructor() { }\n\n\tget stickyModel(): StickyModel | null {\n\t\treturn this._stickyModel;\n\t}\n\n\tprivate _invalid(): Status {\n\t\tthis._stickyModel = null;\n\t\treturn Status.INVALID;\n\t}\n\n\tpublic abstract get provider(): LanguageFeatureRegistry<object> | null;\n\n\tpublic computeStickyModel(textModel: ITextModel, modelVersionId: number, token: CancellationToken): { statusPromise: Promise<Status> | Status; modelPromise: CancelablePromise<T | null> | null } {\n\t\tif (token.isCancellationRequested || !this.isProviderValid(textModel)) {\n\t\t\treturn { statusPromise: this._invalid(), modelPromise: null };\n\t\t}\n\t\tconst providerModelPromise = createCancelablePromise(token => this.createModelFromProvider(textModel, modelVersionId, token));\n\n\t\treturn {\n\t\t\tstatusPromise: providerModelPromise.then(providerModel => {\n\t\t\t\tif (!this.isModelValid(providerModel)) {\n\t\t\t\t\treturn this._invalid();\n\n\t\t\t\t}\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\treturn Status.CANCELED;\n\t\t\t\t}\n\t\t\t\tthis._stickyModel = this.createStickyModel(textModel, modelVersionId, token, providerModel);\n\t\t\t\treturn Status.VALID;\n\t\t\t}).then(undefined, (err) => {\n\t\t\t\tonUnexpectedError(err);\n\t\t\t\treturn Status.CANCELED;\n\t\t\t}),\n\t\t\tmodelPromise: providerModelPromise\n\t\t};\n\t}\n\n\t/**\n\t * Method which checks whether the model returned by the provider is valid and can be used to compute a sticky model.\n\t * This method by default returns true.\n\t * @param model model returned by the provider\n\t * @returns boolean indicating whether the model is valid\n\t */\n\tprotected isModelValid(model: any): boolean {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Method which checks whether the provider is valid before applying it to find the provider model.\n\t * This method by default returns true.\n\t * @param textModel text-model of the editor\n\t * @returns boolean indicating whether the provider is valid\n\t */\n\tprotected isProviderValid(textModel: ITextModel): boolean {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Abstract method which creates the model from the provider and returns the provider model\n\t * @param textModel\ttext-model of the editor\n\t * @param textModelVersionId text-model version ID\n\t * @param token cancellation token\n\t * @returns the model returned by the provider\n\t */\n\tprotected abstract createModelFromProvider(textModel: ITextModel, textModelVersionId: number, token: CancellationToken): Promise<T>;\n\n\t/**\n\t * Abstract method which computes the sticky model from the model returned by the provider and returns the sticky model\n\t * @param textModel text-model of the editor\n\t * @param textModelVersionId text-model version ID\n\t * @param token cancellation token\n\t * @param model model returned by the provider\n\t * @returns the sticky model\n\t */\n\tprotected abstract createStickyModel(textModel: ITextModel, textModelVersionId: number, token: CancellationToken, model: T): StickyModel;\n}\n\nclass StickyModelFromCandidateOutlineProvider extends StickyModelCandidateProvider<OutlineModel> {\n\n\tconstructor(@ILanguageFeaturesService private readonly _languageFeaturesService: ILanguageFeaturesService) {\n\t\tsuper();\n\t}\n\n\tpublic get provider(): LanguageFeatureRegistry<object> | null {\n\t\treturn this._languageFeaturesService.documentSymbolProvider;\n\t}\n\n\tprotected createModelFromProvider(textModel: ITextModel, modelVersionId: number, token: CancellationToken): Promise<OutlineModel> {\n\t\treturn OutlineModel.create(this._languageFeaturesService.documentSymbolProvider, textModel, token);\n\t}\n\n\tprotected createStickyModel(textModel: TextModel, modelVersionId: number, token: CancellationToken, model: OutlineModel): StickyModel {\n\t\tconst { stickyOutlineElement, providerID } = this._stickyModelFromOutlineModel(model, this._stickyModel?.outlineProviderId);\n\t\treturn new StickyModel(textModel.uri, modelVersionId, stickyOutlineElement, providerID);\n\t}\n\n\tprotected override isModelValid(model: OutlineModel): boolean {\n\t\treturn model && model.children.size > 0;\n\t}\n\n\tprivate _stickyModelFromOutlineModel(outlineModel: OutlineModel, preferredProvider: string | undefined): { stickyOutlineElement: StickyElement; providerID: string | undefined } {\n\n\t\tlet outlineElements: Map<string, OutlineElement>;\n\t\t// When several possible outline providers\n\t\tif (Iterable.first(outlineModel.children.values()) instanceof OutlineGroup) {\n\t\t\tconst provider = Iterable.find(outlineModel.children.values(), outlineGroupOfModel => outlineGroupOfModel.id === preferredProvider);\n\t\t\tif (provider) {\n\t\t\t\toutlineElements = provider.children;\n\t\t\t} else {\n\t\t\t\tlet tempID = '';\n\t\t\t\tlet maxTotalSumOfRanges = -1;\n\t\t\t\tlet optimalOutlineGroup = undefined;\n\t\t\t\tfor (const [_key, outlineGroup] of outlineModel.children.entries()) {\n\t\t\t\t\tconst totalSumRanges = this._findSumOfRangesOfGroup(outlineGroup);\n\t\t\t\t\tif (totalSumRanges > maxTotalSumOfRanges) {\n\t\t\t\t\t\toptimalOutlineGroup = outlineGroup;\n\t\t\t\t\t\tmaxTotalSumOfRanges = totalSumRanges;\n\t\t\t\t\t\ttempID = outlineGroup.id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpreferredProvider = tempID;\n\t\t\t\toutlineElements = optimalOutlineGroup!.children;\n\t\t\t}\n\t\t} else {\n\t\t\toutlineElements = outlineModel.children as Map<string, OutlineElement>;\n\t\t}\n\t\tconst stickyChildren: StickyElement[] = [];\n\t\tconst outlineElementsArray = Array.from(outlineElements.values()).sort((element1, element2) => {\n\t\t\tconst range1: StickyRange = new StickyRange(element1.symbol.range.startLineNumber, element1.symbol.range.endLineNumber);\n\t\t\tconst range2: StickyRange = new StickyRange(element2.symbol.range.startLineNumber, element2.symbol.range.endLineNumber);\n\t\t\treturn this._comparator(range1, range2);\n\t\t});\n\t\tfor (const outlineElement of outlineElementsArray) {\n\t\t\tstickyChildren.push(this._stickyModelFromOutlineElement(outlineElement, outlineElement.symbol.selectionRange.startLineNumber));\n\t\t}\n\t\tconst stickyOutlineElement = new StickyElement(undefined, stickyChildren, undefined);\n\n\t\treturn {\n\t\t\tstickyOutlineElement: stickyOutlineElement,\n\t\t\tproviderID: preferredProvider\n\t\t};\n\t}\n\n\tprivate _stickyModelFromOutlineElement(outlineElement: OutlineElement, previousStartLine: number): StickyElement {\n\t\tconst children: StickyElement[] = [];\n\t\tfor (const child of outlineElement.children.values()) {\n\t\t\tif (child.symbol.selectionRange.startLineNumber !== child.symbol.range.endLineNumber) {\n\t\t\t\tif (child.symbol.selectionRange.startLineNumber !== previousStartLine) {\n\t\t\t\t\tchildren.push(this._stickyModelFromOutlineElement(child, child.symbol.selectionRange.startLineNumber));\n\t\t\t\t} else {\n\t\t\t\t\tfor (const subchild of child.children.values()) {\n\t\t\t\t\t\tchildren.push(this._stickyModelFromOutlineElement(subchild, child.symbol.selectionRange.startLineNumber));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchildren.sort((child1, child2) => this._comparator(child1.range!, child2.range!));\n\t\tconst range = new StickyRange(outlineElement.symbol.selectionRange.startLineNumber, outlineElement.symbol.range.endLineNumber);\n\t\treturn new StickyElement(range, children, undefined);\n\t}\n\n\tprivate _comparator(range1: StickyRange, range2: StickyRange): number {\n\t\tif (range1.startLineNumber !== range2.startLineNumber) {\n\t\t\treturn range1.startLineNumber - range2.startLineNumber;\n\t\t} else {\n\t\t\treturn range2.endLineNumber - range1.endLineNumber;\n\t\t}\n\t}\n\n\tprivate _findSumOfRangesOfGroup(outline: OutlineGroup | OutlineElement): number {\n\t\tlet res = 0;\n\t\tfor (const child of outline.children.values()) {\n\t\t\tres += this._findSumOfRangesOfGroup(child);\n\t\t}\n\t\tif (outline instanceof OutlineElement) {\n\t\t\treturn res + outline.symbol.range.endLineNumber - outline.symbol.selectionRange.startLineNumber;\n\t\t} else {\n\t\t\treturn res;\n\t\t}\n\t}\n\n}\n\nabstract class StickyModelFromCandidateFoldingProvider extends StickyModelCandidateProvider<FoldingRegions | null> {\n\n\tprotected _foldingLimitReporter: RangesLimitReporter;\n\n\tconstructor(editor: ICodeEditor) {\n\t\tsuper();\n\t\tthis._foldingLimitReporter = new RangesLimitReporter(editor);\n\t}\n\n\tprotected createStickyModel(textModel: ITextModel, modelVersionId: number, token: CancellationToken, model: FoldingRegions): StickyModel {\n\t\tconst foldingElement = this._fromFoldingRegions(model);\n\t\treturn new StickyModel(textModel.uri, modelVersionId, foldingElement, undefined);\n\t}\n\n\tprotected override isModelValid(model: FoldingRegions): boolean {\n\t\treturn model !== null;\n\t}\n\n\n\tprivate _fromFoldingRegions(foldingRegions: FoldingRegions): StickyElement {\n\t\tconst length = foldingRegions.length;\n\t\tconst orderedStickyElements: StickyElement[] = [];\n\n\t\t// The root sticky outline element\n\t\tconst stickyOutlineElement = new StickyElement(\n\t\t\tundefined,\n\t\t\t[],\n\t\t\tundefined\n\t\t);\n\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\t// Finding the parent index of the current range\n\t\t\tconst parentIndex = foldingRegions.getParentIndex(i);\n\n\t\t\tlet parentNode;\n\t\t\tif (parentIndex !== -1) {\n\t\t\t\t// Access the reference of the parent node\n\t\t\t\tparentNode = orderedStickyElements[parentIndex];\n\t\t\t} else {\n\t\t\t\t// In that case the parent node is the root node\n\t\t\t\tparentNode = stickyOutlineElement;\n\t\t\t}\n\n\t\t\tconst child = new StickyElement(\n\t\t\t\tnew StickyRange(foldingRegions.getStartLineNumber(i), foldingRegions.getEndLineNumber(i) + 1),\n\t\t\t\t[],\n\t\t\t\tparentNode\n\t\t\t);\n\t\t\tparentNode.children.push(child);\n\t\t\torderedStickyElements.push(child);\n\t\t}\n\t\treturn stickyOutlineElement;\n\t}\n}\n\nclass StickyModelFromCandidateIndentationFoldingProvider extends StickyModelFromCandidateFoldingProvider {\n\n\tconstructor(\n\t\teditor: ICodeEditor,\n\t\t@ILanguageConfigurationService private readonly _languageConfigurationService: ILanguageConfigurationService) {\n\t\tsuper(editor);\n\t}\n\n\tpublic get provider(): LanguageFeatureRegistry<object> | null {\n\t\treturn null;\n\t}\n\n\tprotected createModelFromProvider(textModel: TextModel, modelVersionId: number, token: CancellationToken): Promise<FoldingRegions> {\n\t\tconst provider = new IndentRangeProvider(textModel, this._languageConfigurationService, this._foldingLimitReporter);\n\t\treturn provider.compute(token);\n\t}\n}\n\nclass StickyModelFromCandidateSyntaxFoldingProvider extends StickyModelFromCandidateFoldingProvider {\n\n\tconstructor(editor: ICodeEditor,\n\t\t@ILanguageFeaturesService private readonly _languageFeaturesService: ILanguageFeaturesService) {\n\t\tsuper(editor);\n\t}\n\n\tpublic get provider(): LanguageFeatureRegistry<object> | null {\n\t\treturn this._languageFeaturesService.foldingRangeProvider;\n\t}\n\n\tprotected override isProviderValid(textModel: TextModel): boolean {\n\t\tconst selectedProviders = FoldingController.getFoldingRangeProviders(this._languageFeaturesService, textModel);\n\t\treturn selectedProviders.length > 0;\n\t}\n\n\tprotected createModelFromProvider(textModel: TextModel, modelVersionId: number, token: CancellationToken): Promise<FoldingRegions | null> {\n\t\tconst selectedProviders = FoldingController.getFoldingRangeProviders(this._languageFeaturesService, textModel);\n\t\tconst provider = new SyntaxRangeProvider(textModel, selectedProviders, () => this.createModelFromProvider(textModel, modelVersionId, token), this._foldingLimitReporter, undefined);\n\t\treturn provider.compute(token);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle';\nimport { ICodeEditor } from '../../../browser/editorBrowser';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures';\nimport { OutlineElement, OutlineGroup, OutlineModel } from '../../documentSymbols/browser/outlineModel';\nimport { CancellationToken } from '../../../../base/common/cancellation';\nimport { CancelablePromise, createCancelablePromise, Delayer } from '../../../../base/common/async';\nimport { FoldingController, RangesLimitReporter } from '../../folding/browser/folding';\nimport { ITextModel } from '../../../common/model';\nimport { SyntaxRangeProvider } from '../../folding/browser/syntaxRangeProvider';\nimport { IndentRangeProvider } from '../../folding/browser/indentRangeProvider';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry';\nimport { FoldingRegions } from '../../folding/browser/foldingRanges';\nimport { onUnexpectedError } from '../../../../base/common/errors';\nimport { TextModel } from '../../../common/model/textModel';\nimport { StickyElement, StickyModel, StickyRange } from './stickyScrollElement';\nimport { Iterable } from '../../../../base/common/iterator';\nimport { LanguageFeatureRegistry } from '../../../common/languageFeatureRegistry';\n\nenum ModelProvider {\n\tOUTLINE_MODEL = 'outlineModel',\n\tFOLDING_PROVIDER_MODEL = 'foldingProviderModel',\n\tINDENTATION_MODEL = 'indentationModel'\n}\n\nenum Status {\n\tVALID,\n\tINVALID,\n\tCANCELED\n}\n\nexport interface IStickyModelProvider {\n\n\t/**\n\t * Method which updates the sticky model\n\t * @param textModel text-model of the editor\n\t * @param textModelVersionId text-model version ID\n\t * @param token cancellation token\n\t * @returns the sticky model\n\t */\n\tupdate(textModel: ITextModel, textModelVersionId: number, token: CancellationToken): Promise<StickyModel | null>;\n}\n\nexport class StickyModelProvider extends Disposable implements IStickyModelProvider {\n\n\tprivate _modelProviders: IStickyModelCandidateProvider<any>[] = [];\n\tprivate _modelPromise: CancelablePromise<any | null> | null = null;\n\tprivate _updateScheduler: Delayer<StickyModel | null> = this._register(new Delayer<StickyModel | null>(300));\n\tprivate readonly _updateOperation: DisposableStore = this._register(new DisposableStore());\n\n\tconstructor(\n\t\tprivate readonly _editor: ICodeEditor,\n\t\t@ILanguageConfigurationService readonly _languageConfigurationService: ILanguageConfigurationService,\n\t\t@ILanguageFeaturesService readonly _languageFeaturesService: ILanguageFeaturesService,\n\t\tdefaultModel: string\n\t) {\n\t\tsuper();\n\n\t\tconst stickyModelFromCandidateOutlineProvider = new StickyModelFromCandidateOutlineProvider(_languageFeaturesService);\n\t\tconst stickyModelFromSyntaxFoldingProvider = new StickyModelFromCandidateSyntaxFoldingProvider(this._editor, _languageFeaturesService);\n\t\tconst stickyModelFromIndentationFoldingProvider = new StickyModelFromCandidateIndentationFoldingProvider(this._editor, _languageConfigurationService);\n\n\t\tswitch (defaultModel) {\n\t\t\tcase ModelProvider.OUTLINE_MODEL:\n\t\t\t\tthis._modelProviders.push(stickyModelFromCandidateOutlineProvider);\n\t\t\t\tthis._modelProviders.push(stickyModelFromSyntaxFoldingProvider);\n\t\t\t\tthis._modelProviders.push(stickyModelFromIndentationFoldingProvider);\n\t\t\t\tbreak;\n\t\t\tcase ModelProvider.FOLDING_PROVIDER_MODEL:\n\t\t\t\tthis._modelProviders.push(stickyModelFromSyntaxFoldingProvider);\n\t\t\t\tthis._modelProviders.push(stickyModelFromIndentationFoldingProvider);\n\t\t\t\tbreak;\n\t\t\tcase ModelProvider.INDENTATION_MODEL:\n\t\t\t\tthis._modelProviders.push(stickyModelFromIndentationFoldingProvider);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate _cancelModelPromise(): void {\n\t\tif (this._modelPromise) {\n\t\t\tthis._modelPromise.cancel();\n\t\t\tthis._modelPromise = null;\n\t\t}\n\t}\n\n\tpublic async update(textModel: ITextModel, textModelVersionId: number, token: CancellationToken): Promise<StickyModel | null> {\n\n\t\tthis._updateOperation.clear();\n\t\tthis._updateOperation.add({\n\t\t\tdispose: () => {\n\t\t\t\tthis._cancelModelPromise();\n\t\t\t\tthis._updateScheduler.cancel();\n\t\t\t}\n\t\t});\n\t\tthis._cancelModelPromise();\n\n\t\treturn await this._updateScheduler.trigger(async () => {\n\n\t\t\tfor (const modelProvider of this._modelProviders) {\n\t\t\t\tconst { statusPromise, modelPromise } = modelProvider.computeStickyModel(\n\t\t\t\t\ttextModel,\n\t\t\t\t\ttextModelVersionId,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tthis._modelPromise = modelPromise;\n\t\t\t\tconst status = await statusPromise;\n\t\t\t\tif (this._modelPromise !== modelPromise) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tswitch (status) {\n\t\t\t\t\tcase Status.CANCELED:\n\t\t\t\t\t\tthis._updateOperation.clear();\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tcase Status.VALID:\n\t\t\t\t\t\treturn modelProvider.stickyModel;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}).catch((error) => {\n\t\t\tonUnexpectedError(error);\n\t\t\treturn null;\n\t\t});\n\t}\n}\n\ninterface IStickyModelCandidateProvider<T> {\n\tget stickyModel(): StickyModel | null;\n\n\tget provider(): LanguageFeatureRegistry<object> | null;\n\n\t/**\n\t * Method which computes the sticky model and returns a status to signal whether the sticky model has been successfully found\n\t * @param textmodel text-model of the editor\n\t * @param modelVersionId version ID of the text-model\n\t * @param token cancellation token\n\t * @returns a promise of a status indicating whether the sticky model has been successfully found as well as the model promise\n\t */\n\tcomputeStickyModel(textmodel: ITextModel, modelVersionId: number, token: CancellationToken): { statusPromise: Promise<Status> | Status; modelPromise: CancelablePromise<T | null> | null };\n}\n\nabstract class StickyModelCandidateProvider<T> implements IStickyModelCandidateProvider<T> {\n\n\tprotected _stickyModel: StickyModel | null = null;\n\n\tconstructor() { }\n\n\tget stickyModel(): StickyModel | null {\n\t\treturn this._stickyModel;\n\t}\n\n\tprivate _invalid(): Status {\n\t\tthis._stickyModel = null;\n\t\treturn Status.INVALID;\n\t}\n\n\tpublic abstract get provider(): LanguageFeatureRegistry<object> | null;\n\n\tpublic computeStickyModel(textModel: ITextModel, modelVersionId: number, token: CancellationToken): { statusPromise: Promise<Status> | Status; modelPromise: CancelablePromise<T | null> | null } {\n\t\tif (token.isCancellationRequested || !this.isProviderValid(textModel)) {\n\t\t\treturn { statusPromise: this._invalid(), modelPromise: null };\n\t\t}\n\t\tconst providerModelPromise = createCancelablePromise(token => this.createModelFromProvider(textModel, modelVersionId, token));\n\n\t\treturn {\n\t\t\tstatusPromise: providerModelPromise.then(providerModel => {\n\t\t\t\tif (!this.isModelValid(providerModel)) {\n\t\t\t\t\treturn this._invalid();\n\n\t\t\t\t}\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\treturn Status.CANCELED;\n\t\t\t\t}\n\t\t\t\tthis._stickyModel = this.createStickyModel(textModel, modelVersionId, token, providerModel);\n\t\t\t\treturn Status.VALID;\n\t\t\t}).then(undefined, (err) => {\n\t\t\t\tonUnexpectedError(err);\n\t\t\t\treturn Status.CANCELED;\n\t\t\t}),\n\t\t\tmodelPromise: providerModelPromise\n\t\t};\n\t}\n\n\t/**\n\t * Method which checks whether the model returned by the provider is valid and can be used to compute a sticky model.\n\t * This method by default returns true.\n\t * @param model model returned by the provider\n\t * @returns boolean indicating whether the model is valid\n\t */\n\tprotected isModelValid(model: any): boolean {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Method which checks whether the provider is valid before applying it to find the provider model.\n\t * This method by default returns true.\n\t * @param textModel text-model of the editor\n\t * @returns boolean indicating whether the provider is valid\n\t */\n\tprotected isProviderValid(textModel: ITextModel): boolean {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Abstract method which creates the model from the provider and returns the provider model\n\t * @param textModel\ttext-model of the editor\n\t * @param textModelVersionId text-model version ID\n\t * @param token cancellation token\n\t * @returns the model returned by the provider\n\t */\n\tprotected abstract createModelFromProvider(textModel: ITextModel, textModelVersionId: number, token: CancellationToken): Promise<T>;\n\n\t/**\n\t * Abstract method which computes the sticky model from the model returned by the provider and returns the sticky model\n\t * @param textModel text-model of the editor\n\t * @param textModelVersionId text-model version ID\n\t * @param token cancellation token\n\t * @param model model returned by the provider\n\t * @returns the sticky model\n\t */\n\tprotected abstract createStickyModel(textModel: ITextModel, textModelVersionId: number, token: CancellationToken, model: T): StickyModel;\n}\n\nclass StickyModelFromCandidateOutlineProvider extends StickyModelCandidateProvider<OutlineModel> {\n\n\tconstructor(@ILanguageFeaturesService private readonly _languageFeaturesService: ILanguageFeaturesService) {\n\t\tsuper();\n\t}\n\n\tpublic get provider(): LanguageFeatureRegistry<object> | null {\n\t\treturn this._languageFeaturesService.documentSymbolProvider;\n\t}\n\n\tprotected createModelFromProvider(textModel: ITextModel, modelVersionId: number, token: CancellationToken): Promise<OutlineModel> {\n\t\treturn OutlineModel.create(this._languageFeaturesService.documentSymbolProvider, textModel, token);\n\t}\n\n\tprotected createStickyModel(textModel: TextModel, modelVersionId: number, token: CancellationToken, model: OutlineModel): StickyModel {\n\t\tconst { stickyOutlineElement, providerID } = this._stickyModelFromOutlineModel(model, this._stickyModel?.outlineProviderId);\n\t\treturn new StickyModel(textModel.uri, modelVersionId, stickyOutlineElement, providerID);\n\t}\n\n\tprotected override isModelValid(model: OutlineModel): boolean {\n\t\treturn model && model.children.size > 0;\n\t}\n\n\tprivate _stickyModelFromOutlineModel(outlineModel: OutlineModel, preferredProvider: string | undefined): { stickyOutlineElement: StickyElement; providerID: string | undefined } {\n\n\t\tlet outlineElements: Map<string, OutlineElement>;\n\t\t// When several possible outline providers\n\t\tif (Iterable.first(outlineModel.children.values()) instanceof OutlineGroup) {\n\t\t\tconst provider = Iterable.find(outlineModel.children.values(), outlineGroupOfModel => outlineGroupOfModel.id === preferredProvider);\n\t\t\tif (provider) {\n\t\t\t\toutlineElements = provider.children;\n\t\t\t} else {\n\t\t\t\tlet tempID = '';\n\t\t\t\tlet maxTotalSumOfRanges = -1;\n\t\t\t\tlet optimalOutlineGroup = undefined;\n\t\t\t\tfor (const [_key, outlineGroup] of outlineModel.children.entries()) {\n\t\t\t\t\tconst totalSumRanges = this._findSumOfRangesOfGroup(outlineGroup);\n\t\t\t\t\tif (totalSumRanges > maxTotalSumOfRanges) {\n\t\t\t\t\t\toptimalOutlineGroup = outlineGroup;\n\t\t\t\t\t\tmaxTotalSumOfRanges = totalSumRanges;\n\t\t\t\t\t\ttempID = outlineGroup.id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpreferredProvider = tempID;\n\t\t\t\toutlineElements = optimalOutlineGroup!.children;\n\t\t\t}\n\t\t} else {\n\t\t\toutlineElements = outlineModel.children as Map<string, OutlineElement>;\n\t\t}\n\t\tconst stickyChildren: StickyElement[] = [];\n\t\tconst outlineElementsArray = Array.from(outlineElements.values()).sort((element1, element2) => {\n\t\t\tconst range1: StickyRange = new StickyRange(element1.symbol.range.startLineNumber, element1.symbol.range.endLineNumber);\n\t\t\tconst range2: StickyRange = new StickyRange(element2.symbol.range.startLineNumber, element2.symbol.range.endLineNumber);\n\t\t\treturn this._comparator(range1, range2);\n\t\t});\n\t\tfor (const outlineElement of outlineElementsArray) {\n\t\t\tstickyChildren.push(this._stickyModelFromOutlineElement(outlineElement, outlineElement.symbol.selectionRange.startLineNumber));\n\t\t}\n\t\tconst stickyOutlineElement = new StickyElement(undefined, stickyChildren, undefined);\n\n\t\treturn {\n\t\t\tstickyOutlineElement: stickyOutlineElement,\n\t\t\tproviderID: preferredProvider\n\t\t};\n\t}\n\n\tprivate _stickyModelFromOutlineElement(outlineElement: OutlineElement, previousStartLine: number): StickyElement {\n\t\tconst children: StickyElement[] = [];\n\t\tfor (const child of outlineElement.children.values()) {\n\t\t\tif (child.symbol.selectionRange.startLineNumber !== child.symbol.range.endLineNumber) {\n\t\t\t\tif (child.symbol.selectionRange.startLineNumber !== previousStartLine) {\n\t\t\t\t\tchildren.push(this._stickyModelFromOutlineElement(child, child.symbol.selectionRange.startLineNumber));\n\t\t\t\t} else {\n\t\t\t\t\tfor (const subchild of child.children.values()) {\n\t\t\t\t\t\tchildren.push(this._stickyModelFromOutlineElement(subchild, child.symbol.selectionRange.startLineNumber));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchildren.sort((child1, child2) => this._comparator(child1.range!, child2.range!));\n\t\tconst range = new StickyRange(outlineElement.symbol.selectionRange.startLineNumber, outlineElement.symbol.range.endLineNumber);\n\t\treturn new StickyElement(range, children, undefined);\n\t}\n\n\tprivate _comparator(range1: StickyRange, range2: StickyRange): number {\n\t\tif (range1.startLineNumber !== range2.startLineNumber) {\n\t\t\treturn range1.startLineNumber - range2.startLineNumber;\n\t\t} else {\n\t\t\treturn range2.endLineNumber - range1.endLineNumber;\n\t\t}\n\t}\n\n\tprivate _findSumOfRangesOfGroup(outline: OutlineGroup | OutlineElement): number {\n\t\tlet res = 0;\n\t\tfor (const child of outline.children.values()) {\n\t\t\tres += this._findSumOfRangesOfGroup(child);\n\t\t}\n\t\tif (outline instanceof OutlineElement) {\n\t\t\treturn res + outline.symbol.range.endLineNumber - outline.symbol.selectionRange.startLineNumber;\n\t\t} else {\n\t\t\treturn res;\n\t\t}\n\t}\n\n}\n\nabstract class StickyModelFromCandidateFoldingProvider extends StickyModelCandidateProvider<FoldingRegions | null> {\n\n\tprotected _foldingLimitReporter: RangesLimitReporter;\n\n\tconstructor(editor: ICodeEditor) {\n\t\tsuper();\n\t\tthis._foldingLimitReporter = new RangesLimitReporter(editor);\n\t}\n\n\tprotected createStickyModel(textModel: ITextModel, modelVersionId: number, token: CancellationToken, model: FoldingRegions): StickyModel {\n\t\tconst foldingElement = this._fromFoldingRegions(model);\n\t\treturn new StickyModel(textModel.uri, modelVersionId, foldingElement, undefined);\n\t}\n\n\tprotected override isModelValid(model: FoldingRegions): boolean {\n\t\treturn model !== null;\n\t}\n\n\n\tprivate _fromFoldingRegions(foldingRegions: FoldingRegions): StickyElement {\n\t\tconst length = foldingRegions.length;\n\t\tconst orderedStickyElements: StickyElement[] = [];\n\n\t\t// The root sticky outline element\n\t\tconst stickyOutlineElement = new StickyElement(\n\t\t\tundefined,\n\t\t\t[],\n\t\t\tundefined\n\t\t);\n\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\t// Finding the parent index of the current range\n\t\t\tconst parentIndex = foldingRegions.getParentIndex(i);\n\n\t\t\tlet parentNode;\n\t\t\tif (parentIndex !== -1) {\n\t\t\t\t// Access the reference of the parent node\n\t\t\t\tparentNode = orderedStickyElements[parentIndex];\n\t\t\t} else {\n\t\t\t\t// In that case the parent node is the root node\n\t\t\t\tparentNode = stickyOutlineElement;\n\t\t\t}\n\n\t\t\tconst child = new StickyElement(\n\t\t\t\tnew StickyRange(foldingRegions.getStartLineNumber(i), foldingRegions.getEndLineNumber(i) + 1),\n\t\t\t\t[],\n\t\t\t\tparentNode\n\t\t\t);\n\t\t\tparentNode.children.push(child);\n\t\t\torderedStickyElements.push(child);\n\t\t}\n\t\treturn stickyOutlineElement;\n\t}\n}\n\nclass StickyModelFromCandidateIndentationFoldingProvider extends StickyModelFromCandidateFoldingProvider {\n\n\tconstructor(\n\t\teditor: ICodeEditor,\n\t\t@ILanguageConfigurationService private readonly _languageConfigurationService: ILanguageConfigurationService) {\n\t\tsuper(editor);\n\t}\n\n\tpublic get provider(): LanguageFeatureRegistry<object> | null {\n\t\treturn null;\n\t}\n\n\tprotected createModelFromProvider(textModel: TextModel, modelVersionId: number, token: CancellationToken): Promise<FoldingRegions> {\n\t\tconst provider = new IndentRangeProvider(textModel, this._languageConfigurationService, this._foldingLimitReporter);\n\t\treturn provider.compute(token);\n\t}\n}\n\nclass StickyModelFromCandidateSyntaxFoldingProvider extends StickyModelFromCandidateFoldingProvider {\n\n\tconstructor(editor: ICodeEditor,\n\t\t@ILanguageFeaturesService private readonly _languageFeaturesService: ILanguageFeaturesService) {\n\t\tsuper(editor);\n\t}\n\n\tpublic get provider(): LanguageFeatureRegistry<object> | null {\n\t\treturn this._languageFeaturesService.foldingRangeProvider;\n\t}\n\n\tprotected override isProviderValid(textModel: TextModel): boolean {\n\t\tconst selectedProviders = FoldingController.getFoldingRangeProviders(this._languageFeaturesService, textModel);\n\t\treturn selectedProviders.length > 0;\n\t}\n\n\tprotected createModelFromProvider(textModel: TextModel, modelVersionId: number, token: CancellationToken): Promise<FoldingRegions | null> {\n\t\tconst selectedProviders = FoldingController.getFoldingRangeProviders(this._languageFeaturesService, textModel);\n\t\tconst provider = new SyntaxRangeProvider(textModel, selectedProviders, () => this.createModelFromProvider(textModel, modelVersionId, token), this._foldingLimitReporter, undefined);\n\t\treturn provider.compute(token);\n\t}\n}\n"]}