{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/editor/contrib/inlineCompletions/browser/utils.ts","vs/editor/contrib/inlineCompletions/browser/utils.ts"],"names":[],"mappings":"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","file":"utils.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy } from '../../../../base/common/arrays';\nimport { BugIndicatingError } from '../../../../base/common/errors';\nimport { DisposableStore, IDisposable } from '../../../../base/common/lifecycle';\nimport { IObservable, autorunOpts } from '../../../../base/common/observable';\nimport { ICodeEditor } from '../../../browser/editorBrowser';\nimport { ISingleEditOperation } from '../../../common/core/editOperation';\nimport { Position } from '../../../common/core/position';\nimport { IRange, Range } from '../../../common/core/range';\nimport { IModelDeltaDecoration } from '../../../common/model';\nimport { TextModel } from '../../../common/model/textModel';\n\nexport function applyEdits(text: string, edits: { range: IRange; text: string }[]): string {\n\tconst transformer = new PositionOffsetTransformer(text);\n\tconst offsetEdits = edits.map(e => {\n\t\tconst range = Range.lift(e.range);\n\t\treturn ({\n\t\t\tstartOffset: transformer.getOffset(range.getStartPosition()),\n\t\t\tendOffset: transformer.getOffset(range.getEndPosition()),\n\t\t\ttext: e.text\n\t\t});\n\t});\n\n\toffsetEdits.sort((a, b) => b.startOffset - a.startOffset);\n\n\tfor (const edit of offsetEdits) {\n\t\ttext = text.substring(0, edit.startOffset) + edit.text + text.substring(edit.endOffset);\n\t}\n\n\treturn text;\n}\n\nclass PositionOffsetTransformer {\n\tprivate readonly lineStartOffsetByLineIdx: number[];\n\n\tconstructor(text: string) {\n\t\tthis.lineStartOffsetByLineIdx = [];\n\t\tthis.lineStartOffsetByLineIdx.push(0);\n\t\tfor (let i = 0; i < text.length; i++) {\n\t\t\tif (text.charAt(i) === '\\n') {\n\t\t\t\tthis.lineStartOffsetByLineIdx.push(i + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetOffset(position: Position): number {\n\t\treturn this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;\n\t}\n}\n\nconst array: ReadonlyArray<any> = [];\nexport function getReadonlyEmptyArray<T>(): readonly T[] {\n\treturn array;\n}\n\nexport class ColumnRange {\n\tconstructor(\n\t\tpublic readonly startColumn: number,\n\t\tpublic readonly endColumnExclusive: number,\n\t) {\n\t\tif (startColumn > endColumnExclusive) {\n\t\t\tthrow new BugIndicatingError(`startColumn ${startColumn} cannot be after endColumnExclusive ${endColumnExclusive}`);\n\t\t}\n\t}\n\n\ttoRange(lineNumber: number): Range {\n\t\treturn new Range(lineNumber, this.startColumn, lineNumber, this.endColumnExclusive);\n\t}\n\n\tequals(other: ColumnRange): boolean {\n\t\treturn this.startColumn === other.startColumn\n\t\t\t&& this.endColumnExclusive === other.endColumnExclusive;\n\t}\n}\n\nexport function applyObservableDecorations(editor: ICodeEditor, decorations: IObservable<IModelDeltaDecoration[]>): IDisposable {\n\tconst d = new DisposableStore();\n\tconst decorationsCollection = editor.createDecorationsCollection();\n\td.add(autorunOpts({ debugName: () => `Apply decorations from ${decorations.debugName}` }, reader => {\n\t\tconst d = decorations.read(reader);\n\t\tdecorationsCollection.set(d);\n\t}));\n\td.add({\n\t\tdispose: () => {\n\t\t\tdecorationsCollection.clear();\n\t\t}\n\t});\n\treturn d;\n}\n\nexport function addPositions(pos1: Position, pos2: Position): Position {\n\treturn new Position(pos1.lineNumber + pos2.lineNumber - 1, pos2.lineNumber === 1 ? pos1.column + pos2.column - 1 : pos2.column);\n}\n\nexport function subtractPositions(pos1: Position, pos2: Position): Position {\n\treturn new Position(pos1.lineNumber - pos2.lineNumber + 1, pos1.lineNumber - pos2.lineNumber === 0 ? pos1.column - pos2.column + 1 : pos1.column);\n}\n\nexport function lengthOfText(text: string): Position {\n\tlet line = 1;\n\tlet column = 1;\n\tfor (const c of text) {\n\t\tif (c === '\\n') {\n\t\t\tline++;\n\t\t\tcolumn = 1;\n\t\t} else {\n\t\t\tcolumn++;\n\t\t}\n\t}\n\treturn new Position(line, column);\n}\n\n/**\n * Given some text edits, this function finds the new ranges of the editted text post application of all edits.\n * Assumes that the edit ranges are disjoint and they are sorted in the order of the ranges\n * @param edits edits applied\n * @returns new ranges post edits for every edit\n */\nexport function getNewRanges(edits: ISingleEditOperation[]): Range[] {\n\tconst newRanges: Range[] = [];\n\tlet previousEditEndLineNumber = 0;\n\tlet lineOffset = 0;\n\tlet columnOffset = 0;\n\n\tfor (const edit of edits) {\n\t\tconst text = edit.text ?? '';\n\t\tconst textLength = lengthOfText(text);\n\t\tconst newRangeStart = Position.lift({\n\t\t\tlineNumber: edit.range.startLineNumber + lineOffset,\n\t\t\tcolumn: edit.range.startColumn + (edit.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n\t\t});\n\t\tconst newRangeEnd = addPositions(\n\t\t\tnewRangeStart,\n\t\t\ttextLength\n\t\t);\n\t\tnewRanges.push(Range.fromPositions(newRangeStart, newRangeEnd));\n\t\tlineOffset += textLength.lineNumber - edit.range.endLineNumber + edit.range.startLineNumber - 1;\n\t\tcolumnOffset = newRangeEnd.column - edit.range.endColumn;\n\t\tpreviousEditEndLineNumber = edit.range.endLineNumber;\n\t}\n\treturn newRanges;\n}\n\n/**\n * Given a text model and edits, this function finds the inverse text edits\n * @param model model on which to apply the edits\n * @param edits edits applied\n * @returns inverse edits\n */\nexport function inverseEdits(model: TextModel, edits: ISingleEditOperation[]): ISingleEditOperation[] {\n\tconst sortPerm = Permutation.createSortPermutation(edits, compareBy(e => e.range, Range.compareRangesUsingStarts));\n\tconst sortedRanges = getNewRanges(sortPerm.apply(edits));\n\tconst newRanges = sortPerm.inverse().apply(sortedRanges);\n\tconst inverseEdits: ISingleEditOperation[] = [];\n\tfor (let i = 0; i < edits.length; i++) {\n\t\tinverseEdits.push({ range: newRanges[i], text: model.getValueInRange(edits[i].range) });\n\t}\n\treturn inverseEdits;\n}\n\nexport class Permutation {\n\tconstructor(private readonly _indexMap: number[]) { }\n\n\tpublic static createSortPermutation<T>(arr: readonly T[], compareFn: (a: T, b: T) => number): Permutation {\n\t\tconst sortIndices = Array.from(arr.keys()).sort((index1, index2) => compareFn(arr[index1], arr[index2]));\n\t\treturn new Permutation(sortIndices);\n\t}\n\n\tapply<T>(arr: readonly T[]): T[] {\n\t\treturn arr.map((_, index) => arr[this._indexMap[index]]);\n\t}\n\n\tinverse(): Permutation {\n\t\tconst inverseIndexMap = this._indexMap.slice();\n\t\tfor (let i = 0; i < this._indexMap.length; i++) {\n\t\t\tinverseIndexMap[this._indexMap[i]] = i;\n\t\t}\n\t\treturn new Permutation(inverseIndexMap);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy } from '../../../../base/common/arrays';\nimport { BugIndicatingError } from '../../../../base/common/errors';\nimport { DisposableStore, IDisposable } from '../../../../base/common/lifecycle';\nimport { IObservable, autorunOpts } from '../../../../base/common/observable';\nimport { ICodeEditor } from '../../../browser/editorBrowser';\nimport { ISingleEditOperation } from '../../../common/core/editOperation';\nimport { Position } from '../../../common/core/position';\nimport { IRange, Range } from '../../../common/core/range';\nimport { IModelDeltaDecoration } from '../../../common/model';\nimport { TextModel } from '../../../common/model/textModel';\n\nexport function applyEdits(text: string, edits: { range: IRange; text: string }[]): string {\n\tconst transformer = new PositionOffsetTransformer(text);\n\tconst offsetEdits = edits.map(e => {\n\t\tconst range = Range.lift(e.range);\n\t\treturn ({\n\t\t\tstartOffset: transformer.getOffset(range.getStartPosition()),\n\t\t\tendOffset: transformer.getOffset(range.getEndPosition()),\n\t\t\ttext: e.text\n\t\t});\n\t});\n\n\toffsetEdits.sort((a, b) => b.startOffset - a.startOffset);\n\n\tfor (const edit of offsetEdits) {\n\t\ttext = text.substring(0, edit.startOffset) + edit.text + text.substring(edit.endOffset);\n\t}\n\n\treturn text;\n}\n\nclass PositionOffsetTransformer {\n\tprivate readonly lineStartOffsetByLineIdx: number[];\n\n\tconstructor(text: string) {\n\t\tthis.lineStartOffsetByLineIdx = [];\n\t\tthis.lineStartOffsetByLineIdx.push(0);\n\t\tfor (let i = 0; i < text.length; i++) {\n\t\t\tif (text.charAt(i) === '\\n') {\n\t\t\t\tthis.lineStartOffsetByLineIdx.push(i + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetOffset(position: Position): number {\n\t\treturn this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;\n\t}\n}\n\nconst array: ReadonlyArray<any> = [];\nexport function getReadonlyEmptyArray<T>(): readonly T[] {\n\treturn array;\n}\n\nexport class ColumnRange {\n\tconstructor(\n\t\tpublic readonly startColumn: number,\n\t\tpublic readonly endColumnExclusive: number,\n\t) {\n\t\tif (startColumn > endColumnExclusive) {\n\t\t\tthrow new BugIndicatingError(`startColumn ${startColumn} cannot be after endColumnExclusive ${endColumnExclusive}`);\n\t\t}\n\t}\n\n\ttoRange(lineNumber: number): Range {\n\t\treturn new Range(lineNumber, this.startColumn, lineNumber, this.endColumnExclusive);\n\t}\n\n\tequals(other: ColumnRange): boolean {\n\t\treturn this.startColumn === other.startColumn\n\t\t\t&& this.endColumnExclusive === other.endColumnExclusive;\n\t}\n}\n\nexport function applyObservableDecorations(editor: ICodeEditor, decorations: IObservable<IModelDeltaDecoration[]>): IDisposable {\n\tconst d = new DisposableStore();\n\tconst decorationsCollection = editor.createDecorationsCollection();\n\td.add(autorunOpts({ debugName: () => `Apply decorations from ${decorations.debugName}` }, reader => {\n\t\tconst d = decorations.read(reader);\n\t\tdecorationsCollection.set(d);\n\t}));\n\td.add({\n\t\tdispose: () => {\n\t\t\tdecorationsCollection.clear();\n\t\t}\n\t});\n\treturn d;\n}\n\nexport function addPositions(pos1: Position, pos2: Position): Position {\n\treturn new Position(pos1.lineNumber + pos2.lineNumber - 1, pos2.lineNumber === 1 ? pos1.column + pos2.column - 1 : pos2.column);\n}\n\nexport function subtractPositions(pos1: Position, pos2: Position): Position {\n\treturn new Position(pos1.lineNumber - pos2.lineNumber + 1, pos1.lineNumber - pos2.lineNumber === 0 ? pos1.column - pos2.column + 1 : pos1.column);\n}\n\nexport function lengthOfText(text: string): Position {\n\tlet line = 1;\n\tlet column = 1;\n\tfor (const c of text) {\n\t\tif (c === '\\n') {\n\t\t\tline++;\n\t\t\tcolumn = 1;\n\t\t} else {\n\t\t\tcolumn++;\n\t\t}\n\t}\n\treturn new Position(line, column);\n}\n\n/**\n * Given some text edits, this function finds the new ranges of the editted text post application of all edits.\n * Assumes that the edit ranges are disjoint and they are sorted in the order of the ranges\n * @param edits edits applied\n * @returns new ranges post edits for every edit\n */\nexport function getNewRanges(edits: ISingleEditOperation[]): Range[] {\n\tconst newRanges: Range[] = [];\n\tlet previousEditEndLineNumber = 0;\n\tlet lineOffset = 0;\n\tlet columnOffset = 0;\n\n\tfor (const edit of edits) {\n\t\tconst text = edit.text ?? '';\n\t\tconst textLength = lengthOfText(text);\n\t\tconst newRangeStart = Position.lift({\n\t\t\tlineNumber: edit.range.startLineNumber + lineOffset,\n\t\t\tcolumn: edit.range.startColumn + (edit.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n\t\t});\n\t\tconst newRangeEnd = addPositions(\n\t\t\tnewRangeStart,\n\t\t\ttextLength\n\t\t);\n\t\tnewRanges.push(Range.fromPositions(newRangeStart, newRangeEnd));\n\t\tlineOffset += textLength.lineNumber - edit.range.endLineNumber + edit.range.startLineNumber - 1;\n\t\tcolumnOffset = newRangeEnd.column - edit.range.endColumn;\n\t\tpreviousEditEndLineNumber = edit.range.endLineNumber;\n\t}\n\treturn newRanges;\n}\n\n/**\n * Given a text model and edits, this function finds the inverse text edits\n * @param model model on which to apply the edits\n * @param edits edits applied\n * @returns inverse edits\n */\nexport function inverseEdits(model: TextModel, edits: ISingleEditOperation[]): ISingleEditOperation[] {\n\tconst sortPerm = Permutation.createSortPermutation(edits, compareBy(e => e.range, Range.compareRangesUsingStarts));\n\tconst sortedRanges = getNewRanges(sortPerm.apply(edits));\n\tconst newRanges = sortPerm.inverse().apply(sortedRanges);\n\tconst inverseEdits: ISingleEditOperation[] = [];\n\tfor (let i = 0; i < edits.length; i++) {\n\t\tinverseEdits.push({ range: newRanges[i], text: model.getValueInRange(edits[i].range) });\n\t}\n\treturn inverseEdits;\n}\n\nexport class Permutation {\n\tconstructor(private readonly _indexMap: number[]) { }\n\n\tpublic static createSortPermutation<T>(arr: readonly T[], compareFn: (a: T, b: T) => number): Permutation {\n\t\tconst sortIndices = Array.from(arr.keys()).sort((index1, index2) => compareFn(arr[index1], arr[index2]));\n\t\treturn new Permutation(sortIndices);\n\t}\n\n\tapply<T>(arr: readonly T[]): T[] {\n\t\treturn arr.map((_, index) => arr[this._indexMap[index]]);\n\t}\n\n\tinverse(): Permutation {\n\t\tconst inverseIndexMap = this._indexMap.slice();\n\t\tfor (let i = 0; i < this._indexMap.length; i++) {\n\t\t\tinverseIndexMap[this._indexMap[i]] = i;\n\t\t}\n\t\treturn new Permutation(inverseIndexMap);\n\t}\n}\n"]}