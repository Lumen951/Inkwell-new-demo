"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Permutation = exports.inverseEdits = exports.getNewRanges = exports.lengthOfText = exports.subtractPositions = exports.addPositions = exports.applyObservableDecorations = exports.ColumnRange = exports.getReadonlyEmptyArray = exports.applyEdits = void 0;
const arrays_1 = require("../../../../base/common/arrays");
const errors_1 = require("../../../../base/common/errors");
const lifecycle_1 = require("../../../../base/common/lifecycle");
const observable_1 = require("../../../../base/common/observable");
const position_1 = require("../../../common/core/position");
const range_1 = require("../../../common/core/range");
function applyEdits(text, edits) {
    const transformer = new PositionOffsetTransformer(text);
    const offsetEdits = edits.map(e => {
        const range = range_1.Range.lift(e.range);
        return ({
            startOffset: transformer.getOffset(range.getStartPosition()),
            endOffset: transformer.getOffset(range.getEndPosition()),
            text: e.text
        });
    });
    offsetEdits.sort((a, b) => b.startOffset - a.startOffset);
    for (const edit of offsetEdits) {
        text = text.substring(0, edit.startOffset) + edit.text + text.substring(edit.endOffset);
    }
    return text;
}
exports.applyEdits = applyEdits;
class PositionOffsetTransformer {
    constructor(text) {
        this.lineStartOffsetByLineIdx = [];
        this.lineStartOffsetByLineIdx.push(0);
        for (let i = 0; i < text.length; i++) {
            if (text.charAt(i) === '\n') {
                this.lineStartOffsetByLineIdx.push(i + 1);
            }
        }
    }
    getOffset(position) {
        return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;
    }
}
const array = [];
function getReadonlyEmptyArray() {
    return array;
}
exports.getReadonlyEmptyArray = getReadonlyEmptyArray;
class ColumnRange {
    constructor(startColumn, endColumnExclusive) {
        this.startColumn = startColumn;
        this.endColumnExclusive = endColumnExclusive;
        if (startColumn > endColumnExclusive) {
            throw new errors_1.BugIndicatingError(`startColumn ${startColumn} cannot be after endColumnExclusive ${endColumnExclusive}`);
        }
    }
    toRange(lineNumber) {
        return new range_1.Range(lineNumber, this.startColumn, lineNumber, this.endColumnExclusive);
    }
    equals(other) {
        return this.startColumn === other.startColumn
            && this.endColumnExclusive === other.endColumnExclusive;
    }
}
exports.ColumnRange = ColumnRange;
function applyObservableDecorations(editor, decorations) {
    const d = new lifecycle_1.DisposableStore();
    const decorationsCollection = editor.createDecorationsCollection();
    d.add((0, observable_1.autorunOpts)({ debugName: () => `Apply decorations from ${decorations.debugName}` }, reader => {
        const d = decorations.read(reader);
        decorationsCollection.set(d);
    }));
    d.add({
        dispose: () => {
            decorationsCollection.clear();
        }
    });
    return d;
}
exports.applyObservableDecorations = applyObservableDecorations;
function addPositions(pos1, pos2) {
    return new position_1.Position(pos1.lineNumber + pos2.lineNumber - 1, pos2.lineNumber === 1 ? pos1.column + pos2.column - 1 : pos2.column);
}
exports.addPositions = addPositions;
function subtractPositions(pos1, pos2) {
    return new position_1.Position(pos1.lineNumber - pos2.lineNumber + 1, pos1.lineNumber - pos2.lineNumber === 0 ? pos1.column - pos2.column + 1 : pos1.column);
}
exports.subtractPositions = subtractPositions;
function lengthOfText(text) {
    let line = 1;
    let column = 1;
    for (const c of text) {
        if (c === '\n') {
            line++;
            column = 1;
        }
        else {
            column++;
        }
    }
    return new position_1.Position(line, column);
}
exports.lengthOfText = lengthOfText;
/**
 * Given some text edits, this function finds the new ranges of the editted text post application of all edits.
 * Assumes that the edit ranges are disjoint and they are sorted in the order of the ranges
 * @param edits edits applied
 * @returns new ranges post edits for every edit
 */
function getNewRanges(edits) {
    var _a;
    const newRanges = [];
    let previousEditEndLineNumber = 0;
    let lineOffset = 0;
    let columnOffset = 0;
    for (const edit of edits) {
        const text = (_a = edit.text) !== null && _a !== void 0 ? _a : '';
        const textLength = lengthOfText(text);
        const newRangeStart = position_1.Position.lift({
            lineNumber: edit.range.startLineNumber + lineOffset,
            column: edit.range.startColumn + (edit.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)
        });
        const newRangeEnd = addPositions(newRangeStart, textLength);
        newRanges.push(range_1.Range.fromPositions(newRangeStart, newRangeEnd));
        lineOffset += textLength.lineNumber - edit.range.endLineNumber + edit.range.startLineNumber - 1;
        columnOffset = newRangeEnd.column - edit.range.endColumn;
        previousEditEndLineNumber = edit.range.endLineNumber;
    }
    return newRanges;
}
exports.getNewRanges = getNewRanges;
/**
 * Given a text model and edits, this function finds the inverse text edits
 * @param model model on which to apply the edits
 * @param edits edits applied
 * @returns inverse edits
 */
function inverseEdits(model, edits) {
    const sortPerm = Permutation.createSortPermutation(edits, (0, arrays_1.compareBy)(e => e.range, range_1.Range.compareRangesUsingStarts));
    const sortedRanges = getNewRanges(sortPerm.apply(edits));
    const newRanges = sortPerm.inverse().apply(sortedRanges);
    const inverseEdits = [];
    for (let i = 0; i < edits.length; i++) {
        inverseEdits.push({ range: newRanges[i], text: model.getValueInRange(edits[i].range) });
    }
    return inverseEdits;
}
exports.inverseEdits = inverseEdits;
class Permutation {
    constructor(_indexMap) {
        this._indexMap = _indexMap;
    }
    static createSortPermutation(arr, compareFn) {
        const sortIndices = Array.from(arr.keys()).sort((index1, index2) => compareFn(arr[index1], arr[index2]));
        return new Permutation(sortIndices);
    }
    apply(arr) {
        return arr.map((_, index) => arr[this._indexMap[index]]);
    }
    inverse() {
        const inverseIndexMap = this._indexMap.slice();
        for (let i = 0; i < this._indexMap.length; i++) {
            inverseIndexMap[this._indexMap[i]] = i;
        }
        return new Permutation(inverseIndexMap);
    }
}
exports.Permutation = Permutation;
//# sourceMappingURL=utils.js.map