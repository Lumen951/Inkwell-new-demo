import { Disposable } from '../../../../base/common/lifecycle';
import { ITransaction } from '../../../../base/common/observable';
import { ICodeEditor } from '../../../browser/editorBrowser';
import { Range } from '../../../common/core/range';
import { ILanguageFeatureDebounceService } from '../../../common/services/languageFeatureDebounce';
import { ILanguageFeaturesService } from '../../../common/services/languageFeatures';
import { InlineCompletionsModel } from './inlineCompletionsModel';
import { IAccessibilitySignalService } from '../../../../platform/accessibilitySignal/browser/accessibilitySignalService';
import { ICommandService } from '../../../../platform/commands/common/commands';
import { IConfigurationService } from '../../../../platform/configuration/common/configuration';
import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey';
import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation';
import { IKeybindingService } from '../../../../platform/keybinding/common/keybinding';
import { ISettableObservable } from '../../../../base/common/observableInternal/base';
export declare class InlineCompletionsController extends Disposable {
    readonly editor: ICodeEditor;
    private readonly _instantiationService;
    private readonly _contextKeyService;
    private readonly _configurationService;
    private readonly _commandService;
    private readonly _debounceService;
    private readonly _languageFeaturesService;
    private readonly _accessibilitySignalService;
    private readonly _keybindingService;
    static ID: string;
    static get(editor: ICodeEditor): InlineCompletionsController | null;
    readonly model: ISettableObservable<InlineCompletionsModel | undefined, void> & import("../../../../base/common/lifecycle").IDisposable;
    private readonly _textModelVersionId;
    private readonly _positions;
    private readonly _suggestWidgetAdaptor;
    private readonly _enabled;
    private readonly _fontFamily;
    private readonly _ghostTexts;
    private readonly _stablizedGhostTexts;
    private readonly _ghostTextWidgets;
    private readonly _debounceValue;
    private readonly _playAccessibilitySignal;
    private readonly _isReadonly;
    private readonly _textModel;
    private readonly _textModelIfWritable;
    constructor(editor: ICodeEditor, _instantiationService: IInstantiationService, _contextKeyService: IContextKeyService, _configurationService: IConfigurationService, _commandService: ICommandService, _debounceService: ILanguageFeatureDebounceService, _languageFeaturesService: ILanguageFeaturesService, _accessibilitySignalService: IAccessibilitySignalService, _keybindingService: IKeybindingService);
    playAccessibilitySignal(tx: ITransaction): void;
    private provideScreenReaderUpdate;
    /**
     * Copies over the relevant state from the text model to observables.
     * This solves all kind of eventing issues, as we make sure we always operate on the latest state,
     * regardless of who calls into us.
     */
    private updateObservables;
    shouldShowHoverAt(range: Range): boolean;
    shouldShowHoverAtViewZone(viewZoneId: string): boolean;
    hide(): void;
}
