import { Disposable, IDisposable } from '../../../../base/common/lifecycle';
import { IObservable, IReader, ITransaction } from '../../../../base/common/observable';
import { Position } from '../../../common/core/position';
import { Range } from '../../../common/core/range';
import { InlineCompletionContext } from '../../../common/languages';
import { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry';
import { ITextModel } from '../../../common/model';
import { IFeatureDebounceInformation } from '../../../common/services/languageFeatureDebounce';
import { ILanguageFeaturesService } from '../../../common/services/languageFeatures';
import { InlineCompletionItem, InlineCompletionProviderResult } from './provideInlineCompletions';
import { SingleTextEdit } from './singleTextEdit';
export declare class InlineCompletionsSource extends Disposable {
    private readonly textModel;
    private readonly versionId;
    private readonly _debounceValue;
    private readonly languageFeaturesService;
    private readonly languageConfigurationService;
    private readonly _updateOperation;
    readonly inlineCompletions: import("../../../../base/common/observable").ISettableObservable<UpToDateInlineCompletions | undefined, void> & IDisposable;
    readonly suggestWidgetInlineCompletions: import("../../../../base/common/observable").ISettableObservable<UpToDateInlineCompletions | undefined, void> & IDisposable;
    constructor(textModel: ITextModel, versionId: IObservable<number>, _debounceValue: IFeatureDebounceInformation, languageFeaturesService: ILanguageFeaturesService, languageConfigurationService: ILanguageConfigurationService);
    fetch(position: Position, context: InlineCompletionContext, activeInlineCompletion: InlineCompletionWithUpdatedRange | undefined): Promise<boolean>;
    clear(tx: ITransaction): void;
    clearSuggestWidgetInlineCompletions(tx: ITransaction): void;
    cancelUpdate(): void;
}
declare class UpdateRequest {
    readonly position: Position;
    readonly context: InlineCompletionContext;
    readonly versionId: number;
    constructor(position: Position, context: InlineCompletionContext, versionId: number);
    satisfies(other: UpdateRequest): boolean;
}
export declare class UpToDateInlineCompletions implements IDisposable {
    private readonly inlineCompletionProviderResult;
    readonly request: UpdateRequest;
    private readonly textModel;
    private readonly versionId;
    private readonly _inlineCompletions;
    get inlineCompletions(): ReadonlyArray<InlineCompletionWithUpdatedRange>;
    private _refCount;
    private readonly _prependedInlineCompletionItems;
    private _rangeVersionIdValue;
    private readonly _rangeVersionId;
    constructor(inlineCompletionProviderResult: InlineCompletionProviderResult, request: UpdateRequest, textModel: ITextModel, versionId: IObservable<number>);
    clone(): this;
    dispose(): void;
    prepend(inlineCompletion: InlineCompletionItem, range: Range, addRefToSource: boolean): void;
}
export declare class InlineCompletionWithUpdatedRange {
    readonly inlineCompletion: InlineCompletionItem;
    readonly decorationId: string;
    private readonly rangeVersion;
    readonly semanticId: string;
    private _updatedRange;
    private _isValid;
    get forwardStable(): boolean;
    constructor(inlineCompletion: InlineCompletionItem, decorationId: string, rangeVersion: IObservable<number>, initialRange?: Range);
    toInlineCompletion(reader: IReader | undefined): InlineCompletionItem;
    toSingleTextEdit(reader: IReader | undefined): SingleTextEdit;
    isVisible(model: ITextModel, cursorPosition: Position, reader: IReader | undefined): boolean;
    canBeReused(model: ITextModel, position: Position): boolean;
    private _toFilterTextReplacement;
    private _isSmallerThanOriginal;
    private _getUpdatedRange;
    _updateRange(textModel: ITextModel): boolean;
}
export {};
