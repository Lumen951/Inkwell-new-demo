import { IDisposable } from '../../../../base/common/lifecycle';
import { IObservable } from '../../../../base/common/observable';
import { ICodeEditor } from '../../../browser/editorBrowser';
import { ISingleEditOperation } from '../../../common/core/editOperation';
import { Position } from '../../../common/core/position';
import { IRange, Range } from '../../../common/core/range';
import { IModelDeltaDecoration } from '../../../common/model';
import { TextModel } from '../../../common/model/textModel';
export declare function applyEdits(text: string, edits: {
    range: IRange;
    text: string;
}[]): string;
export declare function getReadonlyEmptyArray<T>(): readonly T[];
export declare class ColumnRange {
    readonly startColumn: number;
    readonly endColumnExclusive: number;
    constructor(startColumn: number, endColumnExclusive: number);
    toRange(lineNumber: number): Range;
    equals(other: ColumnRange): boolean;
}
export declare function applyObservableDecorations(editor: ICodeEditor, decorations: IObservable<IModelDeltaDecoration[]>): IDisposable;
export declare function addPositions(pos1: Position, pos2: Position): Position;
export declare function subtractPositions(pos1: Position, pos2: Position): Position;
export declare function lengthOfText(text: string): Position;
/**
 * Given some text edits, this function finds the new ranges of the editted text post application of all edits.
 * Assumes that the edit ranges are disjoint and they are sorted in the order of the ranges
 * @param edits edits applied
 * @returns new ranges post edits for every edit
 */
export declare function getNewRanges(edits: ISingleEditOperation[]): Range[];
/**
 * Given a text model and edits, this function finds the inverse text edits
 * @param model model on which to apply the edits
 * @param edits edits applied
 * @returns inverse edits
 */
export declare function inverseEdits(model: TextModel, edits: ISingleEditOperation[]): ISingleEditOperation[];
export declare class Permutation {
    private readonly _indexMap;
    constructor(_indexMap: number[]);
    static createSortPermutation<T>(arr: readonly T[], compareFn: (a: T, b: T) => number): Permutation;
    apply<T>(arr: readonly T[]): T[];
    inverse(): Permutation;
}
