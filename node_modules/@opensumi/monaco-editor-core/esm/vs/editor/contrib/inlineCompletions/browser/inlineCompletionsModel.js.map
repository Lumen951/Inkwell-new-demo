{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsModel.ts","vs/editor/contrib/inlineCompletions/browser/inlineCompletionsModel.ts"],"names":[],"mappings":"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","file":"inlineCompletionsModel.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { mapFindFirst } from '../../../../base/common/arraysFind';\nimport { BugIndicatingError, onUnexpectedError, onUnexpectedExternalError } from '../../../../base/common/errors';\nimport { Disposable } from '../../../../base/common/lifecycle';\nimport { IObservable, IReader, ITransaction, autorun, derived, derivedHandleChanges, derivedOpts, recomputeInitiallyAndOnChange, observableSignal, observableValue, subtransaction, transaction } from '../../../../base/common/observable';\nimport { commonPrefixLength, splitLinesIncludeSeparators } from '../../../../base/common/strings';\nimport { isDefined } from '../../../../base/common/types';\nimport { ICodeEditor } from '../../../browser/editorBrowser';\nimport { EditOperation } from '../../../common/core/editOperation';\nimport { Position } from '../../../common/core/position';\nimport { Range } from '../../../common/core/range';\nimport { Selection } from '../../../common/core/selection';\nimport { InlineCompletionContext, InlineCompletionTriggerKind } from '../../../common/languages';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry';\nimport { EndOfLinePreference, ITextModel } from '../../../common/model';\nimport { IFeatureDebounceInformation } from '../../../common/services/languageFeatureDebounce';\nimport { GhostText, GhostTextOrReplacement, ghostTextOrReplacementEquals, ghostTextsOrReplacementsEqual } from './ghostText';\nimport { InlineCompletionWithUpdatedRange, InlineCompletionsSource } from './inlineCompletionsSource';\nimport { SingleTextEdit } from './singleTextEdit';\nimport { SuggestItemInfo } from './suggestWidgetInlineCompletionProvider';\nimport { Permutation, addPositions, getNewRanges, lengthOfText, subtractPositions } from './utils';\nimport { SnippetController2 } from '../../snippet/browser/snippetController2';\nimport { ICommandService } from '../../../../platform/commands/common/commands';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation';\n\nexport enum VersionIdChangeReason {\n\tUndo,\n\tRedo,\n\tAcceptWord,\n\tOther,\n}\n\nexport class InlineCompletionsModel extends Disposable {\n\tprivate readonly _source = this._register(this._instantiationService.createInstance(InlineCompletionsSource, this.textModel, this.textModelVersionId, this._debounceValue));\n\tprivate readonly _isActive = observableValue<boolean, InlineCompletionTriggerKind | void>(this, false);\n\treadonly _forceUpdateSignal = observableSignal<InlineCompletionTriggerKind>('forceUpdate');\n\n\t// We use a semantic id to keep the same inline completion selected even if the provider reorders the completions.\n\tprivate readonly _selectedInlineCompletionId = observableValue<string | undefined>(this, undefined);\n\tprivate readonly _primaryPosition = derived(this, reader => this._positions.read(reader)[0] ?? new Position(1, 1));\n\n\tprivate _isAcceptingPartially = false;\n\tpublic get isAcceptingPartially() { return this._isAcceptingPartially; }\n\n\tconstructor(\n\t\tpublic readonly textModel: ITextModel,\n\t\tpublic readonly selectedSuggestItem: IObservable<SuggestItemInfo | undefined>,\n\t\tpublic readonly textModelVersionId: IObservable<number, VersionIdChangeReason>,\n\t\tprivate readonly _positions: IObservable<readonly Position[]>,\n\t\tprivate readonly _debounceValue: IFeatureDebounceInformation,\n\t\tprivate readonly _suggestPreviewEnabled: IObservable<boolean>,\n\t\tprivate readonly _suggestPreviewMode: IObservable<'prefix' | 'subword' | 'subwordSmart'>,\n\t\tprivate readonly _inlineSuggestMode: IObservable<'prefix' | 'subword' | 'subwordSmart'>,\n\t\tprivate readonly _enabled: IObservable<boolean>,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@ICommandService private readonly _commandService: ICommandService,\n\t\t@ILanguageConfigurationService private readonly _languageConfigurationService: ILanguageConfigurationService,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(recomputeInitiallyAndOnChange(this._fetchInlineCompletions));\n\n\t\tlet lastItem: InlineCompletionWithUpdatedRange | undefined = undefined;\n\t\tthis._register(autorun(reader => {\n\t\t\t/** @description call handleItemDidShow */\n\t\t\tconst item = this.state.read(reader);\n\t\t\tconst completion = item?.inlineCompletion;\n\t\t\tif (completion?.semanticId !== lastItem?.semanticId) {\n\t\t\t\tlastItem = completion;\n\t\t\t\tif (completion) {\n\t\t\t\t\tconst i = completion.inlineCompletion;\n\t\t\t\t\tconst src = i.source;\n\t\t\t\t\tsrc.provider.handleItemDidShow?.(src.inlineCompletions, i.sourceInlineCompletion, i.insertText);\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate readonly _preserveCurrentCompletionReasons = new Set([\n\t\tVersionIdChangeReason.Redo,\n\t\tVersionIdChangeReason.Undo,\n\t\tVersionIdChangeReason.AcceptWord,\n\t]);\n\tprivate readonly _fetchInlineCompletions = derivedHandleChanges({\n\t\towner: this,\n\t\tcreateEmptyChangeSummary: () => ({\n\t\t\tpreserveCurrentCompletion: false,\n\t\t\tinlineCompletionTriggerKind: InlineCompletionTriggerKind.Automatic\n\t\t}),\n\t\thandleChange: (ctx, changeSummary) => {\n\t\t\t/** @description fetch inline completions */\n\t\t\tif (ctx.didChange(this.textModelVersionId) && this._preserveCurrentCompletionReasons.has(ctx.change)) {\n\t\t\t\tchangeSummary.preserveCurrentCompletion = true;\n\t\t\t} else if (ctx.didChange(this._forceUpdateSignal)) {\n\t\t\t\tchangeSummary.inlineCompletionTriggerKind = ctx.change;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t}, (reader, changeSummary) => {\n\t\tthis._forceUpdateSignal.read(reader);\n\t\tconst shouldUpdate = (this._enabled.read(reader) && this.selectedSuggestItem.read(reader)) || this._isActive.read(reader);\n\t\tif (!shouldUpdate) {\n\t\t\tthis._source.cancelUpdate();\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis.textModelVersionId.read(reader); // Refetch on text change\n\n\t\tconst itemToPreserveCandidate = this.selectedInlineCompletion.get();\n\t\tconst itemToPreserve = changeSummary.preserveCurrentCompletion || itemToPreserveCandidate?.forwardStable\n\t\t\t? itemToPreserveCandidate : undefined;\n\n\t\tconst suggestWidgetInlineCompletions = this._source.suggestWidgetInlineCompletions.get();\n\t\tconst suggestItem = this.selectedSuggestItem.read(reader);\n\t\tif (suggestWidgetInlineCompletions && !suggestItem) {\n\t\t\tconst inlineCompletions = this._source.inlineCompletions.get();\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description Seed inline completions with (newer) suggest widget inline completions */\n\t\t\t\tif (!inlineCompletions || suggestWidgetInlineCompletions.request.versionId > inlineCompletions.request.versionId) {\n\t\t\t\t\tthis._source.inlineCompletions.set(suggestWidgetInlineCompletions.clone(), tx);\n\t\t\t\t}\n\t\t\t\tthis._source.clearSuggestWidgetInlineCompletions(tx);\n\t\t\t});\n\t\t}\n\n\t\tconst cursorPosition = this._primaryPosition.read(reader);\n\t\tconst context: InlineCompletionContext = {\n\t\t\ttriggerKind: changeSummary.inlineCompletionTriggerKind,\n\t\t\tselectedSuggestionInfo: suggestItem?.toSelectedSuggestionInfo(),\n\t\t};\n\t\treturn this._source.fetch(cursorPosition, context, itemToPreserve);\n\t});\n\n\tpublic async trigger(tx?: ITransaction): Promise<void> {\n\t\tthis._isActive.set(true, tx);\n\t\tawait this._fetchInlineCompletions.get();\n\t}\n\n\tpublic async triggerExplicitly(tx?: ITransaction): Promise<void> {\n\t\tsubtransaction(tx, tx => {\n\t\t\tthis._isActive.set(true, tx);\n\t\t\tthis._forceUpdateSignal.trigger(tx, InlineCompletionTriggerKind.Explicit);\n\t\t});\n\t\tawait this._fetchInlineCompletions.get();\n\t}\n\n\tpublic stop(tx?: ITransaction): void {\n\t\tsubtransaction(tx, tx => {\n\t\t\tthis._isActive.set(false, tx);\n\t\t\tthis._source.clear(tx);\n\t\t});\n\t}\n\n\tprivate readonly _filteredInlineCompletionItems = derived(this, reader => {\n\t\tconst c = this._source.inlineCompletions.read(reader);\n\t\tif (!c) { return []; }\n\t\tconst cursorPosition = this._primaryPosition.read(reader);\n\t\tconst filteredCompletions = c.inlineCompletions.filter(c => c.isVisible(this.textModel, cursorPosition, reader));\n\t\treturn filteredCompletions;\n\t});\n\n\tpublic readonly selectedInlineCompletionIndex = derived<number>(this, (reader) => {\n\t\tconst selectedInlineCompletionId = this._selectedInlineCompletionId.read(reader);\n\t\tconst filteredCompletions = this._filteredInlineCompletionItems.read(reader);\n\t\tconst idx = this._selectedInlineCompletionId === undefined ? -1\n\t\t\t: filteredCompletions.findIndex(v => v.semanticId === selectedInlineCompletionId);\n\t\tif (idx === -1) {\n\t\t\t// Reset the selection so that the selection does not jump back when it appears again\n\t\t\tthis._selectedInlineCompletionId.set(undefined, undefined);\n\t\t\treturn 0;\n\t\t}\n\t\treturn idx;\n\t});\n\n\tpublic readonly selectedInlineCompletion = derived<InlineCompletionWithUpdatedRange | undefined>(this, (reader) => {\n\t\tconst filteredCompletions = this._filteredInlineCompletionItems.read(reader);\n\t\tconst idx = this.selectedInlineCompletionIndex.read(reader);\n\t\treturn filteredCompletions[idx];\n\t});\n\n\tpublic readonly lastTriggerKind: IObservable<InlineCompletionTriggerKind | undefined>\n\t\t= this._source.inlineCompletions.map(this, v => v?.request.context.triggerKind);\n\n\tpublic readonly inlineCompletionsCount = derived<number | undefined>(this, reader => {\n\t\tif (this.lastTriggerKind.read(reader) === InlineCompletionTriggerKind.Explicit) {\n\t\t\treturn this._filteredInlineCompletionItems.read(reader).length;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t});\n\n\tpublic readonly state = derivedOpts<{\n\t\tedits: readonly SingleTextEdit[];\n\t\tprimaryGhostText: GhostTextOrReplacement;\n\t\tghostTexts: readonly GhostTextOrReplacement[];\n\t\tsuggestItem: SuggestItemInfo | undefined;\n\t\tinlineCompletion: InlineCompletionWithUpdatedRange | undefined;\n\t} | undefined>({\n\t\towner: this,\n\t\tequalityComparer: (a, b) => {\n\t\t\tif (!a || !b) { return a === b; }\n\t\t\treturn ghostTextsOrReplacementsEqual(a.ghostTexts, b.ghostTexts)\n\t\t\t\t&& a.inlineCompletion === b.inlineCompletion\n\t\t\t\t&& a.suggestItem === b.suggestItem;\n\t\t}\n\t}, (reader) => {\n\t\tconst model = this.textModel;\n\n\t\tconst suggestItem = this.selectedSuggestItem.read(reader);\n\t\tif (suggestItem) {\n\t\t\tconst suggestCompletionEdit = suggestItem.toSingleTextEdit().removeCommonPrefix(model);\n\t\t\tconst augmentation = this._computeAugmentation(suggestCompletionEdit, reader);\n\n\t\t\tconst isSuggestionPreviewEnabled = this._suggestPreviewEnabled.read(reader);\n\t\t\tif (!isSuggestionPreviewEnabled && !augmentation) { return undefined; }\n\n\t\t\tconst fullEdit = augmentation?.edit ?? suggestCompletionEdit;\n\t\t\tconst fullEditPreviewLength = augmentation ? augmentation.edit.text.length - suggestCompletionEdit.text.length : 0;\n\n\t\t\tconst mode = this._suggestPreviewMode.read(reader);\n\t\t\tconst positions = this._positions.read(reader);\n\t\t\tconst edits = [fullEdit, ...getSecondaryEdits(this.textModel, positions, fullEdit)];\n\t\t\tconst ghostTexts = edits\n\t\t\t\t.map((edit, idx) => edit.computeGhostText(model, mode, positions[idx], fullEditPreviewLength))\n\t\t\t\t.filter(isDefined);\n\t\t\tconst primaryGhostText = ghostTexts[0] ?? new GhostText(fullEdit.range.endLineNumber, []);\n\t\t\treturn { edits, primaryGhostText, ghostTexts, inlineCompletion: augmentation?.completion, suggestItem };\n\t\t} else {\n\t\t\tif (!this._isActive.read(reader)) { return undefined; }\n\t\t\tconst inlineCompletion = this.selectedInlineCompletion.read(reader);\n\t\t\tif (!inlineCompletion) { return undefined; }\n\n\t\t\tconst replacement = inlineCompletion.toSingleTextEdit(reader);\n\t\t\tconst mode = this._inlineSuggestMode.read(reader);\n\t\t\tconst positions = this._positions.read(reader);\n\t\t\tconst edits = [replacement, ...getSecondaryEdits(this.textModel, positions, replacement)];\n\t\t\tconst ghostTexts = edits\n\t\t\t\t.map((edit, idx) => edit.computeGhostText(model, mode, positions[idx], 0))\n\t\t\t\t.filter(isDefined);\n\t\t\tif (!ghostTexts[0]) { return undefined; }\n\t\t\treturn { edits, primaryGhostText: ghostTexts[0], ghostTexts, inlineCompletion, suggestItem: undefined };\n\t\t}\n\t});\n\n\tprivate _computeAugmentation(suggestCompletion: SingleTextEdit, reader: IReader | undefined) {\n\t\tconst model = this.textModel;\n\t\tconst suggestWidgetInlineCompletions = this._source.suggestWidgetInlineCompletions.read(reader);\n\t\tconst candidateInlineCompletions = suggestWidgetInlineCompletions\n\t\t\t? suggestWidgetInlineCompletions.inlineCompletions\n\t\t\t: [this.selectedInlineCompletion.read(reader)].filter(isDefined);\n\n\t\tconst augmentedCompletion = mapFindFirst(candidateInlineCompletions, completion => {\n\t\t\tlet r = completion.toSingleTextEdit(reader);\n\t\t\tr = r.removeCommonPrefix(model, Range.fromPositions(r.range.getStartPosition(), suggestCompletion.range.getEndPosition()));\n\t\t\treturn r.augments(suggestCompletion) ? { completion, edit: r } : undefined;\n\t\t});\n\n\t\treturn augmentedCompletion;\n\t}\n\n\tpublic readonly ghostTexts = derivedOpts({\n\t\towner: this,\n\t\tequalityComparer: ghostTextsOrReplacementsEqual\n\t}, reader => {\n\t\tconst v = this.state.read(reader);\n\t\tif (!v) { return undefined; }\n\t\treturn v.ghostTexts;\n\t});\n\n\tpublic readonly primaryGhostText = derivedOpts({\n\t\towner: this,\n\t\tequalityComparer: ghostTextOrReplacementEquals\n\t}, reader => {\n\t\tconst v = this.state.read(reader);\n\t\tif (!v) { return undefined; }\n\t\treturn v?.primaryGhostText;\n\t});\n\n\tprivate async _deltaSelectedInlineCompletionIndex(delta: 1 | -1): Promise<void> {\n\t\tawait this.triggerExplicitly();\n\n\t\tconst completions = this._filteredInlineCompletionItems.get() || [];\n\t\tif (completions.length > 0) {\n\t\t\tconst newIdx = (this.selectedInlineCompletionIndex.get() + delta + completions.length) % completions.length;\n\t\t\tthis._selectedInlineCompletionId.set(completions[newIdx].semanticId, undefined);\n\t\t} else {\n\t\t\tthis._selectedInlineCompletionId.set(undefined, undefined);\n\t\t}\n\t}\n\n\tpublic async next(): Promise<void> {\n\t\tawait this._deltaSelectedInlineCompletionIndex(1);\n\t}\n\n\tpublic async previous(): Promise<void> {\n\t\tawait this._deltaSelectedInlineCompletionIndex(-1);\n\t}\n\n\tpublic async accept(editor: ICodeEditor): Promise<void> {\n\t\tif (editor.getModel() !== this.textModel) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\n\t\tconst state = this.state.get();\n\t\tif (!state || state.primaryGhostText.isEmpty() || !state.inlineCompletion) {\n\t\t\treturn;\n\t\t}\n\t\tconst completion = state.inlineCompletion.toInlineCompletion(undefined);\n\n\t\teditor.pushUndoStop();\n\t\tif (completion.snippetInfo) {\n\t\t\teditor.executeEdits(\n\t\t\t\t'inlineSuggestion.accept',\n\t\t\t\t[\n\t\t\t\t\tEditOperation.replaceMove(completion.range, ''),\n\t\t\t\t\t...completion.additionalTextEdits\n\t\t\t\t]\n\t\t\t);\n\t\t\teditor.setPosition(completion.snippetInfo.range.getStartPosition(), 'inlineCompletionAccept');\n\t\t\tSnippetController2.get(editor)?.insert(completion.snippetInfo.snippet, { undoStopBefore: false });\n\t\t} else {\n\t\t\tconst edits = state.edits;\n\t\t\tconst selections = getEndPositionsAfterApplying(edits).map(p => Selection.fromPositions(p));\n\t\t\teditor.executeEdits('inlineSuggestion.accept', [\n\t\t\t\t...edits.map(edit => EditOperation.replaceMove(edit.range, edit.text)),\n\t\t\t\t...completion.additionalTextEdits\n\t\t\t]);\n\t\t\teditor.setSelections(selections, 'inlineCompletionAccept');\n\t\t}\n\n\t\tif (completion.command) {\n\t\t\t// Make sure the completion list will not be disposed.\n\t\t\tcompletion.source.addRef();\n\t\t}\n\n\t\t// Reset before invoking the command, since the command might cause a follow up trigger.\n\t\ttransaction(tx => {\n\t\t\tthis._source.clear(tx);\n\t\t\t// Potentially, isActive will get set back to true by the typing or accept inline suggest event\n\t\t\t// if automatic inline suggestions are enabled.\n\t\t\tthis._isActive.set(false, tx);\n\t\t});\n\n\t\tif (completion.command) {\n\t\t\tawait this._commandService\n\t\t\t\t.executeCommand(completion.command.id, ...(completion.command.arguments || []))\n\t\t\t\t.then(undefined, onUnexpectedExternalError);\n\t\t\tcompletion.source.removeRef();\n\t\t}\n\t}\n\n\tpublic async acceptNextWord(editor: ICodeEditor): Promise<void> {\n\t\tawait this._acceptNext(editor, (pos, text) => {\n\t\t\tconst langId = this.textModel.getLanguageIdAtPosition(pos.lineNumber, pos.column);\n\t\t\tconst config = this._languageConfigurationService.getLanguageConfiguration(langId);\n\t\t\tconst wordRegExp = new RegExp(config.wordDefinition.source, config.wordDefinition.flags.replace('g', ''));\n\n\t\t\tconst m1 = text.match(wordRegExp);\n\t\t\tlet acceptUntilIndexExclusive = 0;\n\t\t\tif (m1 && m1.index !== undefined) {\n\t\t\t\tif (m1.index === 0) {\n\t\t\t\t\tacceptUntilIndexExclusive = m1[0].length;\n\t\t\t\t} else {\n\t\t\t\t\tacceptUntilIndexExclusive = m1.index;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tacceptUntilIndexExclusive = text.length;\n\t\t\t}\n\n\t\t\tconst wsRegExp = /\\s+/g;\n\t\t\tconst m2 = wsRegExp.exec(text);\n\t\t\tif (m2 && m2.index !== undefined) {\n\t\t\t\tif (m2.index + m2[0].length < acceptUntilIndexExclusive) {\n\t\t\t\t\tacceptUntilIndexExclusive = m2.index + m2[0].length;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn acceptUntilIndexExclusive;\n\t\t});\n\t}\n\n\tpublic async acceptNextLine(editor: ICodeEditor): Promise<void> {\n\t\tawait this._acceptNext(editor, (pos, text) => {\n\t\t\tconst m = text.match(/\\n/);\n\t\t\tif (m && m.index !== undefined) {\n\t\t\t\treturn m.index + 1;\n\t\t\t}\n\t\t\treturn text.length;\n\t\t});\n\t}\n\n\tprivate async _acceptNext(editor: ICodeEditor, getAcceptUntilIndex: (position: Position, text: string) => number): Promise<void> {\n\t\tif (editor.getModel() !== this.textModel) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\n\t\tconst state = this.state.get();\n\t\tif (!state || state.primaryGhostText.isEmpty() || !state.inlineCompletion) {\n\t\t\treturn;\n\t\t}\n\t\tconst ghostText = state.primaryGhostText;\n\t\tconst completion = state.inlineCompletion.toInlineCompletion(undefined);\n\n\t\tif (completion.snippetInfo || completion.filterText !== completion.insertText) {\n\t\t\t// not in WYSIWYG mode, partial commit might change completion, thus it is not supported\n\t\t\tawait this.accept(editor);\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstPart = ghostText.parts[0];\n\t\tconst ghostTextPos = new Position(ghostText.lineNumber, firstPart.column);\n\t\tconst ghostTextVal = firstPart.text;\n\t\tconst acceptUntilIndexExclusive = getAcceptUntilIndex(ghostTextPos, ghostTextVal);\n\t\tif (acceptUntilIndexExclusive === ghostTextVal.length && ghostText.parts.length === 1) {\n\t\t\tthis.accept(editor);\n\t\t\treturn;\n\t\t}\n\t\tconst partialGhostTextVal = ghostTextVal.substring(0, acceptUntilIndexExclusive);\n\n\t\tconst positions = this._positions.get();\n\t\tconst cursorPosition = positions[0];\n\n\t\t// Executing the edit might free the completion, so we have to hold a reference on it.\n\t\tcompletion.source.addRef();\n\t\ttry {\n\t\t\tthis._isAcceptingPartially = true;\n\t\t\ttry {\n\t\t\t\teditor.pushUndoStop();\n\t\t\t\tconst replaceRange = Range.fromPositions(cursorPosition, ghostTextPos);\n\t\t\t\tconst newText = editor.getModel()!.getValueInRange(replaceRange) + partialGhostTextVal;\n\t\t\t\tconst primaryEdit = new SingleTextEdit(replaceRange, newText);\n\t\t\t\tconst edits = [primaryEdit, ...getSecondaryEdits(this.textModel, positions, primaryEdit)];\n\t\t\t\tconst selections = getEndPositionsAfterApplying(edits).map(p => Selection.fromPositions(p));\n\t\t\t\teditor.executeEdits('inlineSuggestion.accept', edits.map(edit => EditOperation.replaceMove(edit.range, edit.text)));\n\t\t\t\teditor.setSelections(selections, 'inlineCompletionPartialAccept');\n\t\t\t} finally {\n\t\t\t\tthis._isAcceptingPartially = false;\n\t\t\t}\n\n\t\t\tif (completion.source.provider.handlePartialAccept) {\n\t\t\t\tconst acceptedRange = Range.fromPositions(completion.range.getStartPosition(), addPositions(ghostTextPos, lengthOfText(partialGhostTextVal)));\n\t\t\t\t// This assumes that the inline completion and the model use the same EOL style.\n\t\t\t\tconst text = editor.getModel()!.getValueInRange(acceptedRange, EndOfLinePreference.LF);\n\t\t\t\tcompletion.source.provider.handlePartialAccept(\n\t\t\t\t\tcompletion.source.inlineCompletions,\n\t\t\t\t\tcompletion.sourceInlineCompletion,\n\t\t\t\t\ttext.length,\n\t\t\t\t);\n\t\t\t}\n\t\t} finally {\n\t\t\tcompletion.source.removeRef();\n\t\t}\n\t}\n\n\tpublic handleSuggestAccepted(item: SuggestItemInfo) {\n\t\tconst itemEdit = item.toSingleTextEdit().removeCommonPrefix(this.textModel);\n\t\tconst augmentedCompletion = this._computeAugmentation(itemEdit, undefined);\n\t\tif (!augmentedCompletion) { return; }\n\n\t\tconst inlineCompletion = augmentedCompletion.completion.inlineCompletion;\n\t\tinlineCompletion.source.provider.handlePartialAccept?.(\n\t\t\tinlineCompletion.source.inlineCompletions,\n\t\t\tinlineCompletion.sourceInlineCompletion,\n\t\t\titemEdit.text.length,\n\t\t);\n\t}\n}\n\nexport function getSecondaryEdits(textModel: ITextModel, positions: readonly Position[], primaryEdit: SingleTextEdit): SingleTextEdit[] {\n\tif (positions.length === 1) {\n\t\t// No secondary cursor positions\n\t\treturn [];\n\t}\n\tconst primaryPosition = positions[0];\n\tconst secondaryPositions = positions.slice(1);\n\tconst primaryEditStartPosition = primaryEdit.range.getStartPosition();\n\tconst primaryEditEndPosition = primaryEdit.range.getEndPosition();\n\tconst replacedTextAfterPrimaryCursor = textModel.getValueInRange(\n\t\tRange.fromPositions(primaryPosition, primaryEditEndPosition)\n\t);\n\tconst positionWithinTextEdit = subtractPositions(primaryPosition, primaryEditStartPosition);\n\tif (positionWithinTextEdit.lineNumber < 1) {\n\t\tonUnexpectedError(new BugIndicatingError(\n\t\t\t`positionWithinTextEdit line number should be bigger than 0.\n\t\t\tInvalid subtraction between ${primaryPosition.toString()} and ${primaryEditStartPosition.toString()}`\n\t\t));\n\t\treturn [];\n\t}\n\tconst secondaryEditText = substringPos(primaryEdit.text, positionWithinTextEdit);\n\treturn secondaryPositions.map(pos => {\n\t\tconst posEnd = addPositions(subtractPositions(pos, primaryEditStartPosition), primaryEditEndPosition);\n\t\tconst textAfterSecondaryCursor = textModel.getValueInRange(\n\t\t\tRange.fromPositions(pos, posEnd)\n\t\t);\n\t\tconst l = commonPrefixLength(replacedTextAfterPrimaryCursor, textAfterSecondaryCursor);\n\t\tconst range = Range.fromPositions(pos, pos.delta(0, l));\n\t\treturn new SingleTextEdit(range, secondaryEditText);\n\t});\n}\n\nfunction substringPos(text: string, pos: Position): string {\n\tlet subtext = '';\n\tconst lines = splitLinesIncludeSeparators(text);\n\tfor (let i = pos.lineNumber - 1; i < lines.length; i++) {\n\t\tsubtext += lines[i].substring(i === pos.lineNumber - 1 ? pos.column - 1 : 0);\n\t}\n\treturn subtext;\n}\n\nfunction getEndPositionsAfterApplying(edits: readonly SingleTextEdit[]): Position[] {\n\tconst sortPerm = Permutation.createSortPermutation(edits, (edit1, edit2) => Range.compareRangesUsingStarts(edit1.range, edit2.range));\n\tconst sortedNewRanges = getNewRanges(sortPerm.apply(edits));\n\tconst newRanges = sortPerm.inverse().apply(sortedNewRanges);\n\treturn newRanges.map(range => range.getEndPosition());\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { mapFindFirst } from '../../../../base/common/arraysFind';\nimport { BugIndicatingError, onUnexpectedError, onUnexpectedExternalError } from '../../../../base/common/errors';\nimport { Disposable } from '../../../../base/common/lifecycle';\nimport { IObservable, IReader, ITransaction, autorun, derived, derivedHandleChanges, derivedOpts, recomputeInitiallyAndOnChange, observableSignal, observableValue, subtransaction, transaction } from '../../../../base/common/observable';\nimport { commonPrefixLength, splitLinesIncludeSeparators } from '../../../../base/common/strings';\nimport { isDefined } from '../../../../base/common/types';\nimport { ICodeEditor } from '../../../browser/editorBrowser';\nimport { EditOperation } from '../../../common/core/editOperation';\nimport { Position } from '../../../common/core/position';\nimport { Range } from '../../../common/core/range';\nimport { Selection } from '../../../common/core/selection';\nimport { InlineCompletionContext, InlineCompletionTriggerKind } from '../../../common/languages';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry';\nimport { EndOfLinePreference, ITextModel } from '../../../common/model';\nimport { IFeatureDebounceInformation } from '../../../common/services/languageFeatureDebounce';\nimport { GhostText, GhostTextOrReplacement, ghostTextOrReplacementEquals, ghostTextsOrReplacementsEqual } from './ghostText';\nimport { InlineCompletionWithUpdatedRange, InlineCompletionsSource } from './inlineCompletionsSource';\nimport { SingleTextEdit } from './singleTextEdit';\nimport { SuggestItemInfo } from './suggestWidgetInlineCompletionProvider';\nimport { Permutation, addPositions, getNewRanges, lengthOfText, subtractPositions } from './utils';\nimport { SnippetController2 } from '../../snippet/browser/snippetController2';\nimport { ICommandService } from '../../../../platform/commands/common/commands';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation';\n\nexport enum VersionIdChangeReason {\n\tUndo,\n\tRedo,\n\tAcceptWord,\n\tOther,\n}\n\nexport class InlineCompletionsModel extends Disposable {\n\tprivate readonly _source = this._register(this._instantiationService.createInstance(InlineCompletionsSource, this.textModel, this.textModelVersionId, this._debounceValue));\n\tprivate readonly _isActive = observableValue<boolean, InlineCompletionTriggerKind | void>(this, false);\n\treadonly _forceUpdateSignal = observableSignal<InlineCompletionTriggerKind>('forceUpdate');\n\n\t// We use a semantic id to keep the same inline completion selected even if the provider reorders the completions.\n\tprivate readonly _selectedInlineCompletionId = observableValue<string | undefined>(this, undefined);\n\tprivate readonly _primaryPosition = derived(this, reader => this._positions.read(reader)[0] ?? new Position(1, 1));\n\n\tprivate _isAcceptingPartially = false;\n\tpublic get isAcceptingPartially() { return this._isAcceptingPartially; }\n\n\tconstructor(\n\t\tpublic readonly textModel: ITextModel,\n\t\tpublic readonly selectedSuggestItem: IObservable<SuggestItemInfo | undefined>,\n\t\tpublic readonly textModelVersionId: IObservable<number, VersionIdChangeReason>,\n\t\tprivate readonly _positions: IObservable<readonly Position[]>,\n\t\tprivate readonly _debounceValue: IFeatureDebounceInformation,\n\t\tprivate readonly _suggestPreviewEnabled: IObservable<boolean>,\n\t\tprivate readonly _suggestPreviewMode: IObservable<'prefix' | 'subword' | 'subwordSmart'>,\n\t\tprivate readonly _inlineSuggestMode: IObservable<'prefix' | 'subword' | 'subwordSmart'>,\n\t\tprivate readonly _enabled: IObservable<boolean>,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@ICommandService private readonly _commandService: ICommandService,\n\t\t@ILanguageConfigurationService private readonly _languageConfigurationService: ILanguageConfigurationService,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(recomputeInitiallyAndOnChange(this._fetchInlineCompletions));\n\n\t\tlet lastItem: InlineCompletionWithUpdatedRange | undefined = undefined;\n\t\tthis._register(autorun(reader => {\n\t\t\t/** @description call handleItemDidShow */\n\t\t\tconst item = this.state.read(reader);\n\t\t\tconst completion = item?.inlineCompletion;\n\t\t\tif (completion?.semanticId !== lastItem?.semanticId) {\n\t\t\t\tlastItem = completion;\n\t\t\t\tif (completion) {\n\t\t\t\t\tconst i = completion.inlineCompletion;\n\t\t\t\t\tconst src = i.source;\n\t\t\t\t\tsrc.provider.handleItemDidShow?.(src.inlineCompletions, i.sourceInlineCompletion, i.insertText);\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate readonly _preserveCurrentCompletionReasons = new Set([\n\t\tVersionIdChangeReason.Redo,\n\t\tVersionIdChangeReason.Undo,\n\t\tVersionIdChangeReason.AcceptWord,\n\t]);\n\tprivate readonly _fetchInlineCompletions = derivedHandleChanges({\n\t\towner: this,\n\t\tcreateEmptyChangeSummary: () => ({\n\t\t\tpreserveCurrentCompletion: false,\n\t\t\tinlineCompletionTriggerKind: InlineCompletionTriggerKind.Automatic\n\t\t}),\n\t\thandleChange: (ctx, changeSummary) => {\n\t\t\t/** @description fetch inline completions */\n\t\t\tif (ctx.didChange(this.textModelVersionId) && this._preserveCurrentCompletionReasons.has(ctx.change)) {\n\t\t\t\tchangeSummary.preserveCurrentCompletion = true;\n\t\t\t} else if (ctx.didChange(this._forceUpdateSignal)) {\n\t\t\t\tchangeSummary.inlineCompletionTriggerKind = ctx.change;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t}, (reader, changeSummary) => {\n\t\tthis._forceUpdateSignal.read(reader);\n\t\tconst shouldUpdate = (this._enabled.read(reader) && this.selectedSuggestItem.read(reader)) || this._isActive.read(reader);\n\t\tif (!shouldUpdate) {\n\t\t\tthis._source.cancelUpdate();\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis.textModelVersionId.read(reader); // Refetch on text change\n\n\t\tconst itemToPreserveCandidate = this.selectedInlineCompletion.get();\n\t\tconst itemToPreserve = changeSummary.preserveCurrentCompletion || itemToPreserveCandidate?.forwardStable\n\t\t\t? itemToPreserveCandidate : undefined;\n\n\t\tconst suggestWidgetInlineCompletions = this._source.suggestWidgetInlineCompletions.get();\n\t\tconst suggestItem = this.selectedSuggestItem.read(reader);\n\t\tif (suggestWidgetInlineCompletions && !suggestItem) {\n\t\t\tconst inlineCompletions = this._source.inlineCompletions.get();\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description Seed inline completions with (newer) suggest widget inline completions */\n\t\t\t\tif (!inlineCompletions || suggestWidgetInlineCompletions.request.versionId > inlineCompletions.request.versionId) {\n\t\t\t\t\tthis._source.inlineCompletions.set(suggestWidgetInlineCompletions.clone(), tx);\n\t\t\t\t}\n\t\t\t\tthis._source.clearSuggestWidgetInlineCompletions(tx);\n\t\t\t});\n\t\t}\n\n\t\tconst cursorPosition = this._primaryPosition.read(reader);\n\t\tconst context: InlineCompletionContext = {\n\t\t\ttriggerKind: changeSummary.inlineCompletionTriggerKind,\n\t\t\tselectedSuggestionInfo: suggestItem?.toSelectedSuggestionInfo(),\n\t\t};\n\t\treturn this._source.fetch(cursorPosition, context, itemToPreserve);\n\t});\n\n\tpublic async trigger(tx?: ITransaction): Promise<void> {\n\t\tthis._isActive.set(true, tx);\n\t\tawait this._fetchInlineCompletions.get();\n\t}\n\n\tpublic async triggerExplicitly(tx?: ITransaction): Promise<void> {\n\t\tsubtransaction(tx, tx => {\n\t\t\tthis._isActive.set(true, tx);\n\t\t\tthis._forceUpdateSignal.trigger(tx, InlineCompletionTriggerKind.Explicit);\n\t\t});\n\t\tawait this._fetchInlineCompletions.get();\n\t}\n\n\tpublic stop(tx?: ITransaction): void {\n\t\tsubtransaction(tx, tx => {\n\t\t\tthis._isActive.set(false, tx);\n\t\t\tthis._source.clear(tx);\n\t\t});\n\t}\n\n\tprivate readonly _filteredInlineCompletionItems = derived(this, reader => {\n\t\tconst c = this._source.inlineCompletions.read(reader);\n\t\tif (!c) { return []; }\n\t\tconst cursorPosition = this._primaryPosition.read(reader);\n\t\tconst filteredCompletions = c.inlineCompletions.filter(c => c.isVisible(this.textModel, cursorPosition, reader));\n\t\treturn filteredCompletions;\n\t});\n\n\tpublic readonly selectedInlineCompletionIndex = derived<number>(this, (reader) => {\n\t\tconst selectedInlineCompletionId = this._selectedInlineCompletionId.read(reader);\n\t\tconst filteredCompletions = this._filteredInlineCompletionItems.read(reader);\n\t\tconst idx = this._selectedInlineCompletionId === undefined ? -1\n\t\t\t: filteredCompletions.findIndex(v => v.semanticId === selectedInlineCompletionId);\n\t\tif (idx === -1) {\n\t\t\t// Reset the selection so that the selection does not jump back when it appears again\n\t\t\tthis._selectedInlineCompletionId.set(undefined, undefined);\n\t\t\treturn 0;\n\t\t}\n\t\treturn idx;\n\t});\n\n\tpublic readonly selectedInlineCompletion = derived<InlineCompletionWithUpdatedRange | undefined>(this, (reader) => {\n\t\tconst filteredCompletions = this._filteredInlineCompletionItems.read(reader);\n\t\tconst idx = this.selectedInlineCompletionIndex.read(reader);\n\t\treturn filteredCompletions[idx];\n\t});\n\n\tpublic readonly lastTriggerKind: IObservable<InlineCompletionTriggerKind | undefined>\n\t\t= this._source.inlineCompletions.map(this, v => v?.request.context.triggerKind);\n\n\tpublic readonly inlineCompletionsCount = derived<number | undefined>(this, reader => {\n\t\tif (this.lastTriggerKind.read(reader) === InlineCompletionTriggerKind.Explicit) {\n\t\t\treturn this._filteredInlineCompletionItems.read(reader).length;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t});\n\n\tpublic readonly state = derivedOpts<{\n\t\tedits: readonly SingleTextEdit[];\n\t\tprimaryGhostText: GhostTextOrReplacement;\n\t\tghostTexts: readonly GhostTextOrReplacement[];\n\t\tsuggestItem: SuggestItemInfo | undefined;\n\t\tinlineCompletion: InlineCompletionWithUpdatedRange | undefined;\n\t} | undefined>({\n\t\towner: this,\n\t\tequalityComparer: (a, b) => {\n\t\t\tif (!a || !b) { return a === b; }\n\t\t\treturn ghostTextsOrReplacementsEqual(a.ghostTexts, b.ghostTexts)\n\t\t\t\t&& a.inlineCompletion === b.inlineCompletion\n\t\t\t\t&& a.suggestItem === b.suggestItem;\n\t\t}\n\t}, (reader) => {\n\t\tconst model = this.textModel;\n\n\t\tconst suggestItem = this.selectedSuggestItem.read(reader);\n\t\tif (suggestItem) {\n\t\t\tconst suggestCompletionEdit = suggestItem.toSingleTextEdit().removeCommonPrefix(model);\n\t\t\tconst augmentation = this._computeAugmentation(suggestCompletionEdit, reader);\n\n\t\t\tconst isSuggestionPreviewEnabled = this._suggestPreviewEnabled.read(reader);\n\t\t\tif (!isSuggestionPreviewEnabled && !augmentation) { return undefined; }\n\n\t\t\tconst fullEdit = augmentation?.edit ?? suggestCompletionEdit;\n\t\t\tconst fullEditPreviewLength = augmentation ? augmentation.edit.text.length - suggestCompletionEdit.text.length : 0;\n\n\t\t\tconst mode = this._suggestPreviewMode.read(reader);\n\t\t\tconst positions = this._positions.read(reader);\n\t\t\tconst edits = [fullEdit, ...getSecondaryEdits(this.textModel, positions, fullEdit)];\n\t\t\tconst ghostTexts = edits\n\t\t\t\t.map((edit, idx) => edit.computeGhostText(model, mode, positions[idx], fullEditPreviewLength))\n\t\t\t\t.filter(isDefined);\n\t\t\tconst primaryGhostText = ghostTexts[0] ?? new GhostText(fullEdit.range.endLineNumber, []);\n\t\t\treturn { edits, primaryGhostText, ghostTexts, inlineCompletion: augmentation?.completion, suggestItem };\n\t\t} else {\n\t\t\tif (!this._isActive.read(reader)) { return undefined; }\n\t\t\tconst inlineCompletion = this.selectedInlineCompletion.read(reader);\n\t\t\tif (!inlineCompletion) { return undefined; }\n\n\t\t\tconst replacement = inlineCompletion.toSingleTextEdit(reader);\n\t\t\tconst mode = this._inlineSuggestMode.read(reader);\n\t\t\tconst positions = this._positions.read(reader);\n\t\t\tconst edits = [replacement, ...getSecondaryEdits(this.textModel, positions, replacement)];\n\t\t\tconst ghostTexts = edits\n\t\t\t\t.map((edit, idx) => edit.computeGhostText(model, mode, positions[idx], 0))\n\t\t\t\t.filter(isDefined);\n\t\t\tif (!ghostTexts[0]) { return undefined; }\n\t\t\treturn { edits, primaryGhostText: ghostTexts[0], ghostTexts, inlineCompletion, suggestItem: undefined };\n\t\t}\n\t});\n\n\tprivate _computeAugmentation(suggestCompletion: SingleTextEdit, reader: IReader | undefined) {\n\t\tconst model = this.textModel;\n\t\tconst suggestWidgetInlineCompletions = this._source.suggestWidgetInlineCompletions.read(reader);\n\t\tconst candidateInlineCompletions = suggestWidgetInlineCompletions\n\t\t\t? suggestWidgetInlineCompletions.inlineCompletions\n\t\t\t: [this.selectedInlineCompletion.read(reader)].filter(isDefined);\n\n\t\tconst augmentedCompletion = mapFindFirst(candidateInlineCompletions, completion => {\n\t\t\tlet r = completion.toSingleTextEdit(reader);\n\t\t\tr = r.removeCommonPrefix(model, Range.fromPositions(r.range.getStartPosition(), suggestCompletion.range.getEndPosition()));\n\t\t\treturn r.augments(suggestCompletion) ? { completion, edit: r } : undefined;\n\t\t});\n\n\t\treturn augmentedCompletion;\n\t}\n\n\tpublic readonly ghostTexts = derivedOpts({\n\t\towner: this,\n\t\tequalityComparer: ghostTextsOrReplacementsEqual\n\t}, reader => {\n\t\tconst v = this.state.read(reader);\n\t\tif (!v) { return undefined; }\n\t\treturn v.ghostTexts;\n\t});\n\n\tpublic readonly primaryGhostText = derivedOpts({\n\t\towner: this,\n\t\tequalityComparer: ghostTextOrReplacementEquals\n\t}, reader => {\n\t\tconst v = this.state.read(reader);\n\t\tif (!v) { return undefined; }\n\t\treturn v?.primaryGhostText;\n\t});\n\n\tprivate async _deltaSelectedInlineCompletionIndex(delta: 1 | -1): Promise<void> {\n\t\tawait this.triggerExplicitly();\n\n\t\tconst completions = this._filteredInlineCompletionItems.get() || [];\n\t\tif (completions.length > 0) {\n\t\t\tconst newIdx = (this.selectedInlineCompletionIndex.get() + delta + completions.length) % completions.length;\n\t\t\tthis._selectedInlineCompletionId.set(completions[newIdx].semanticId, undefined);\n\t\t} else {\n\t\t\tthis._selectedInlineCompletionId.set(undefined, undefined);\n\t\t}\n\t}\n\n\tpublic async next(): Promise<void> {\n\t\tawait this._deltaSelectedInlineCompletionIndex(1);\n\t}\n\n\tpublic async previous(): Promise<void> {\n\t\tawait this._deltaSelectedInlineCompletionIndex(-1);\n\t}\n\n\tpublic async accept(editor: ICodeEditor): Promise<void> {\n\t\tif (editor.getModel() !== this.textModel) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\n\t\tconst state = this.state.get();\n\t\tif (!state || state.primaryGhostText.isEmpty() || !state.inlineCompletion) {\n\t\t\treturn;\n\t\t}\n\t\tconst completion = state.inlineCompletion.toInlineCompletion(undefined);\n\n\t\teditor.pushUndoStop();\n\t\tif (completion.snippetInfo) {\n\t\t\teditor.executeEdits(\n\t\t\t\t'inlineSuggestion.accept',\n\t\t\t\t[\n\t\t\t\t\tEditOperation.replaceMove(completion.range, ''),\n\t\t\t\t\t...completion.additionalTextEdits\n\t\t\t\t]\n\t\t\t);\n\t\t\teditor.setPosition(completion.snippetInfo.range.getStartPosition(), 'inlineCompletionAccept');\n\t\t\tSnippetController2.get(editor)?.insert(completion.snippetInfo.snippet, { undoStopBefore: false });\n\t\t} else {\n\t\t\tconst edits = state.edits;\n\t\t\tconst selections = getEndPositionsAfterApplying(edits).map(p => Selection.fromPositions(p));\n\t\t\teditor.executeEdits('inlineSuggestion.accept', [\n\t\t\t\t...edits.map(edit => EditOperation.replaceMove(edit.range, edit.text)),\n\t\t\t\t...completion.additionalTextEdits\n\t\t\t]);\n\t\t\teditor.setSelections(selections, 'inlineCompletionAccept');\n\t\t}\n\n\t\tif (completion.command) {\n\t\t\t// Make sure the completion list will not be disposed.\n\t\t\tcompletion.source.addRef();\n\t\t}\n\n\t\t// Reset before invoking the command, since the command might cause a follow up trigger.\n\t\ttransaction(tx => {\n\t\t\tthis._source.clear(tx);\n\t\t\t// Potentially, isActive will get set back to true by the typing or accept inline suggest event\n\t\t\t// if automatic inline suggestions are enabled.\n\t\t\tthis._isActive.set(false, tx);\n\t\t});\n\n\t\tif (completion.command) {\n\t\t\tawait this._commandService\n\t\t\t\t.executeCommand(completion.command.id, ...(completion.command.arguments || []))\n\t\t\t\t.then(undefined, onUnexpectedExternalError);\n\t\t\tcompletion.source.removeRef();\n\t\t}\n\t}\n\n\tpublic async acceptNextWord(editor: ICodeEditor): Promise<void> {\n\t\tawait this._acceptNext(editor, (pos, text) => {\n\t\t\tconst langId = this.textModel.getLanguageIdAtPosition(pos.lineNumber, pos.column);\n\t\t\tconst config = this._languageConfigurationService.getLanguageConfiguration(langId);\n\t\t\tconst wordRegExp = new RegExp(config.wordDefinition.source, config.wordDefinition.flags.replace('g', ''));\n\n\t\t\tconst m1 = text.match(wordRegExp);\n\t\t\tlet acceptUntilIndexExclusive = 0;\n\t\t\tif (m1 && m1.index !== undefined) {\n\t\t\t\tif (m1.index === 0) {\n\t\t\t\t\tacceptUntilIndexExclusive = m1[0].length;\n\t\t\t\t} else {\n\t\t\t\t\tacceptUntilIndexExclusive = m1.index;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tacceptUntilIndexExclusive = text.length;\n\t\t\t}\n\n\t\t\tconst wsRegExp = /\\s+/g;\n\t\t\tconst m2 = wsRegExp.exec(text);\n\t\t\tif (m2 && m2.index !== undefined) {\n\t\t\t\tif (m2.index + m2[0].length < acceptUntilIndexExclusive) {\n\t\t\t\t\tacceptUntilIndexExclusive = m2.index + m2[0].length;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn acceptUntilIndexExclusive;\n\t\t});\n\t}\n\n\tpublic async acceptNextLine(editor: ICodeEditor): Promise<void> {\n\t\tawait this._acceptNext(editor, (pos, text) => {\n\t\t\tconst m = text.match(/\\n/);\n\t\t\tif (m && m.index !== undefined) {\n\t\t\t\treturn m.index + 1;\n\t\t\t}\n\t\t\treturn text.length;\n\t\t});\n\t}\n\n\tprivate async _acceptNext(editor: ICodeEditor, getAcceptUntilIndex: (position: Position, text: string) => number): Promise<void> {\n\t\tif (editor.getModel() !== this.textModel) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\n\t\tconst state = this.state.get();\n\t\tif (!state || state.primaryGhostText.isEmpty() || !state.inlineCompletion) {\n\t\t\treturn;\n\t\t}\n\t\tconst ghostText = state.primaryGhostText;\n\t\tconst completion = state.inlineCompletion.toInlineCompletion(undefined);\n\n\t\tif (completion.snippetInfo || completion.filterText !== completion.insertText) {\n\t\t\t// not in WYSIWYG mode, partial commit might change completion, thus it is not supported\n\t\t\tawait this.accept(editor);\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstPart = ghostText.parts[0];\n\t\tconst ghostTextPos = new Position(ghostText.lineNumber, firstPart.column);\n\t\tconst ghostTextVal = firstPart.text;\n\t\tconst acceptUntilIndexExclusive = getAcceptUntilIndex(ghostTextPos, ghostTextVal);\n\t\tif (acceptUntilIndexExclusive === ghostTextVal.length && ghostText.parts.length === 1) {\n\t\t\tthis.accept(editor);\n\t\t\treturn;\n\t\t}\n\t\tconst partialGhostTextVal = ghostTextVal.substring(0, acceptUntilIndexExclusive);\n\n\t\tconst positions = this._positions.get();\n\t\tconst cursorPosition = positions[0];\n\n\t\t// Executing the edit might free the completion, so we have to hold a reference on it.\n\t\tcompletion.source.addRef();\n\t\ttry {\n\t\t\tthis._isAcceptingPartially = true;\n\t\t\ttry {\n\t\t\t\teditor.pushUndoStop();\n\t\t\t\tconst replaceRange = Range.fromPositions(cursorPosition, ghostTextPos);\n\t\t\t\tconst newText = editor.getModel()!.getValueInRange(replaceRange) + partialGhostTextVal;\n\t\t\t\tconst primaryEdit = new SingleTextEdit(replaceRange, newText);\n\t\t\t\tconst edits = [primaryEdit, ...getSecondaryEdits(this.textModel, positions, primaryEdit)];\n\t\t\t\tconst selections = getEndPositionsAfterApplying(edits).map(p => Selection.fromPositions(p));\n\t\t\t\teditor.executeEdits('inlineSuggestion.accept', edits.map(edit => EditOperation.replaceMove(edit.range, edit.text)));\n\t\t\t\teditor.setSelections(selections, 'inlineCompletionPartialAccept');\n\t\t\t} finally {\n\t\t\t\tthis._isAcceptingPartially = false;\n\t\t\t}\n\n\t\t\tif (completion.source.provider.handlePartialAccept) {\n\t\t\t\tconst acceptedRange = Range.fromPositions(completion.range.getStartPosition(), addPositions(ghostTextPos, lengthOfText(partialGhostTextVal)));\n\t\t\t\t// This assumes that the inline completion and the model use the same EOL style.\n\t\t\t\tconst text = editor.getModel()!.getValueInRange(acceptedRange, EndOfLinePreference.LF);\n\t\t\t\tcompletion.source.provider.handlePartialAccept(\n\t\t\t\t\tcompletion.source.inlineCompletions,\n\t\t\t\t\tcompletion.sourceInlineCompletion,\n\t\t\t\t\ttext.length,\n\t\t\t\t);\n\t\t\t}\n\t\t} finally {\n\t\t\tcompletion.source.removeRef();\n\t\t}\n\t}\n\n\tpublic handleSuggestAccepted(item: SuggestItemInfo) {\n\t\tconst itemEdit = item.toSingleTextEdit().removeCommonPrefix(this.textModel);\n\t\tconst augmentedCompletion = this._computeAugmentation(itemEdit, undefined);\n\t\tif (!augmentedCompletion) { return; }\n\n\t\tconst inlineCompletion = augmentedCompletion.completion.inlineCompletion;\n\t\tinlineCompletion.source.provider.handlePartialAccept?.(\n\t\t\tinlineCompletion.source.inlineCompletions,\n\t\t\tinlineCompletion.sourceInlineCompletion,\n\t\t\titemEdit.text.length,\n\t\t);\n\t}\n}\n\nexport function getSecondaryEdits(textModel: ITextModel, positions: readonly Position[], primaryEdit: SingleTextEdit): SingleTextEdit[] {\n\tif (positions.length === 1) {\n\t\t// No secondary cursor positions\n\t\treturn [];\n\t}\n\tconst primaryPosition = positions[0];\n\tconst secondaryPositions = positions.slice(1);\n\tconst primaryEditStartPosition = primaryEdit.range.getStartPosition();\n\tconst primaryEditEndPosition = primaryEdit.range.getEndPosition();\n\tconst replacedTextAfterPrimaryCursor = textModel.getValueInRange(\n\t\tRange.fromPositions(primaryPosition, primaryEditEndPosition)\n\t);\n\tconst positionWithinTextEdit = subtractPositions(primaryPosition, primaryEditStartPosition);\n\tif (positionWithinTextEdit.lineNumber < 1) {\n\t\tonUnexpectedError(new BugIndicatingError(\n\t\t\t`positionWithinTextEdit line number should be bigger than 0.\n\t\t\tInvalid subtraction between ${primaryPosition.toString()} and ${primaryEditStartPosition.toString()}`\n\t\t));\n\t\treturn [];\n\t}\n\tconst secondaryEditText = substringPos(primaryEdit.text, positionWithinTextEdit);\n\treturn secondaryPositions.map(pos => {\n\t\tconst posEnd = addPositions(subtractPositions(pos, primaryEditStartPosition), primaryEditEndPosition);\n\t\tconst textAfterSecondaryCursor = textModel.getValueInRange(\n\t\t\tRange.fromPositions(pos, posEnd)\n\t\t);\n\t\tconst l = commonPrefixLength(replacedTextAfterPrimaryCursor, textAfterSecondaryCursor);\n\t\tconst range = Range.fromPositions(pos, pos.delta(0, l));\n\t\treturn new SingleTextEdit(range, secondaryEditText);\n\t});\n}\n\nfunction substringPos(text: string, pos: Position): string {\n\tlet subtext = '';\n\tconst lines = splitLinesIncludeSeparators(text);\n\tfor (let i = pos.lineNumber - 1; i < lines.length; i++) {\n\t\tsubtext += lines[i].substring(i === pos.lineNumber - 1 ? pos.column - 1 : 0);\n\t}\n\treturn subtext;\n}\n\nfunction getEndPositionsAfterApplying(edits: readonly SingleTextEdit[]): Position[] {\n\tconst sortPerm = Permutation.createSortPermutation(edits, (edit1, edit2) => Range.compareRangesUsingStarts(edit1.range, edit2.range));\n\tconst sortedNewRanges = getNewRanges(sortPerm.apply(edits));\n\tconst newRanges = sortPerm.inverse().apply(sortedNewRanges);\n\treturn newRanges.map(range => range.getEndPosition());\n}\n"]}