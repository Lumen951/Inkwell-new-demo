import { Disposable } from '../../../../base/common/lifecycle';
import { IObservable, ITransaction } from '../../../../base/common/observable';
import { ICodeEditor } from '../../../browser/editorBrowser';
import { Position } from '../../../common/core/position';
import { InlineCompletionTriggerKind } from '../../../common/languages';
import { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry';
import { ITextModel } from '../../../common/model';
import { IFeatureDebounceInformation } from '../../../common/services/languageFeatureDebounce';
import { GhostTextOrReplacement } from './ghostText';
import { InlineCompletionWithUpdatedRange } from './inlineCompletionsSource';
import { SingleTextEdit } from './singleTextEdit';
import { SuggestItemInfo } from './suggestWidgetInlineCompletionProvider';
import { ICommandService } from '../../../../platform/commands/common/commands';
import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation';
export declare enum VersionIdChangeReason {
    Undo = 0,
    Redo = 1,
    AcceptWord = 2,
    Other = 3
}
export declare class InlineCompletionsModel extends Disposable {
    readonly textModel: ITextModel;
    readonly selectedSuggestItem: IObservable<SuggestItemInfo | undefined>;
    readonly textModelVersionId: IObservable<number, VersionIdChangeReason>;
    private readonly _positions;
    private readonly _debounceValue;
    private readonly _suggestPreviewEnabled;
    private readonly _suggestPreviewMode;
    private readonly _inlineSuggestMode;
    private readonly _enabled;
    private readonly _instantiationService;
    private readonly _commandService;
    private readonly _languageConfigurationService;
    private readonly _source;
    private readonly _isActive;
    readonly _forceUpdateSignal: import("../../../../base/common/observable").IObservableSignal<InlineCompletionTriggerKind>;
    private readonly _selectedInlineCompletionId;
    private readonly _primaryPosition;
    private _isAcceptingPartially;
    get isAcceptingPartially(): boolean;
    constructor(textModel: ITextModel, selectedSuggestItem: IObservable<SuggestItemInfo | undefined>, textModelVersionId: IObservable<number, VersionIdChangeReason>, _positions: IObservable<readonly Position[]>, _debounceValue: IFeatureDebounceInformation, _suggestPreviewEnabled: IObservable<boolean>, _suggestPreviewMode: IObservable<'prefix' | 'subword' | 'subwordSmart'>, _inlineSuggestMode: IObservable<'prefix' | 'subword' | 'subwordSmart'>, _enabled: IObservable<boolean>, _instantiationService: IInstantiationService, _commandService: ICommandService, _languageConfigurationService: ILanguageConfigurationService);
    private readonly _preserveCurrentCompletionReasons;
    private readonly _fetchInlineCompletions;
    trigger(tx?: ITransaction): Promise<void>;
    triggerExplicitly(tx?: ITransaction): Promise<void>;
    stop(tx?: ITransaction): void;
    private readonly _filteredInlineCompletionItems;
    readonly selectedInlineCompletionIndex: IObservable<number, unknown>;
    readonly selectedInlineCompletion: IObservable<InlineCompletionWithUpdatedRange | undefined, unknown>;
    readonly lastTriggerKind: IObservable<InlineCompletionTriggerKind | undefined>;
    readonly inlineCompletionsCount: IObservable<number | undefined, unknown>;
    readonly state: IObservable<{
        edits: readonly SingleTextEdit[];
        primaryGhostText: GhostTextOrReplacement;
        ghostTexts: readonly GhostTextOrReplacement[];
        suggestItem: SuggestItemInfo | undefined;
        inlineCompletion: InlineCompletionWithUpdatedRange | undefined;
    } | undefined, unknown>;
    private _computeAugmentation;
    readonly ghostTexts: IObservable<readonly GhostTextOrReplacement[] | undefined, unknown>;
    readonly primaryGhostText: IObservable<GhostTextOrReplacement | undefined, unknown>;
    private _deltaSelectedInlineCompletionIndex;
    next(): Promise<void>;
    previous(): Promise<void>;
    accept(editor: ICodeEditor): Promise<void>;
    acceptNextWord(editor: ICodeEditor): Promise<void>;
    acceptNextLine(editor: ICodeEditor): Promise<void>;
    private _acceptNext;
    handleSuggestAccepted(item: SuggestItemInfo): void;
}
export declare function getSecondaryEdits(textModel: ITextModel, positions: readonly Position[], primaryEdit: SingleTextEdit): SingleTextEdit[];
