"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ttPolicy = exports.AdditionalLinesWidget = exports.GhostTextWidget = exports.GHOST_TEXT_DESCRIPTION = void 0;
const trustedTypes_1 = require("../../../../base/browser/trustedTypes");
const event_1 = require("../../../../base/common/event");
const lifecycle_1 = require("../../../../base/common/lifecycle");
const observable_1 = require("../../../../base/common/observable");
const strings = require("../../../../base/common/strings");
require("./ghostText.css");
const domFontInfo_1 = require("../../../browser/config/domFontInfo");
const editorOptions_1 = require("../../../common/config/editorOptions");
const position_1 = require("../../../common/core/position");
const range_1 = require("../../../common/core/range");
const stringBuilder_1 = require("../../../common/core/stringBuilder");
const language_1 = require("../../../common/languages/language");
const model_1 = require("../../../common/model");
const lineTokens_1 = require("../../../common/tokens/lineTokens");
const lineDecorations_1 = require("../../../common/viewLayout/lineDecorations");
const viewLineRenderer_1 = require("../../../common/viewLayout/viewLineRenderer");
const ghostText_1 = require("./ghostText");
const utils_1 = require("./utils");
exports.GHOST_TEXT_DESCRIPTION = 'ghost-text';
let GhostTextWidget = class GhostTextWidget extends lifecycle_1.Disposable {
    constructor(editor, model, languageService) {
        super();
        this.editor = editor;
        this.model = model;
        this.languageService = languageService;
        this.isDisposed = (0, observable_1.observableValue)(this, false);
        this.currentTextModel = (0, observable_1.observableFromEvent)(this.editor.onDidChangeModel, () => /** @description editor.model */ this.editor.getModel());
        this.uiState = (0, observable_1.derived)(this, reader => {
            if (this.isDisposed.read(reader)) {
                return undefined;
            }
            const textModel = this.currentTextModel.read(reader);
            if (textModel !== this.model.targetTextModel.read(reader)) {
                return undefined;
            }
            const ghostText = this.model.ghostText.read(reader);
            if (!ghostText) {
                return undefined;
            }
            const replacedRange = ghostText instanceof ghostText_1.GhostTextReplacement ? ghostText.columnRange : undefined;
            const inlineTexts = [];
            const additionalLines = [];
            function addToAdditionalLines(lines, className) {
                if (additionalLines.length > 0) {
                    const lastLine = additionalLines[additionalLines.length - 1];
                    if (className) {
                        lastLine.decorations.push(new lineDecorations_1.LineDecoration(lastLine.content.length + 1, lastLine.content.length + 1 + lines[0].length, className, 0 /* InlineDecorationType.Regular */));
                    }
                    lastLine.content += lines[0];
                    lines = lines.slice(1);
                }
                for (const line of lines) {
                    additionalLines.push({
                        content: line,
                        decorations: className ? [new lineDecorations_1.LineDecoration(1, line.length + 1, className, 0 /* InlineDecorationType.Regular */)] : []
                    });
                }
            }
            const textBufferLine = textModel.getLineContent(ghostText.lineNumber);
            let hiddenTextStartColumn = undefined;
            let lastIdx = 0;
            for (const part of ghostText.parts) {
                let lines = part.lines;
                if (hiddenTextStartColumn === undefined) {
                    inlineTexts.push({
                        column: part.column,
                        text: lines[0],
                        preview: part.preview,
                    });
                    lines = lines.slice(1);
                }
                else {
                    addToAdditionalLines([textBufferLine.substring(lastIdx, part.column - 1)], undefined);
                }
                if (lines.length > 0) {
                    addToAdditionalLines(lines, exports.GHOST_TEXT_DESCRIPTION);
                    if (hiddenTextStartColumn === undefined && part.column <= textBufferLine.length) {
                        hiddenTextStartColumn = part.column;
                    }
                }
                lastIdx = part.column - 1;
            }
            if (hiddenTextStartColumn !== undefined) {
                addToAdditionalLines([textBufferLine.substring(lastIdx)], undefined);
            }
            const hiddenRange = hiddenTextStartColumn !== undefined ? new utils_1.ColumnRange(hiddenTextStartColumn, textBufferLine.length + 1) : undefined;
            return {
                replacedRange,
                inlineTexts,
                additionalLines,
                hiddenRange,
                lineNumber: ghostText.lineNumber,
                additionalReservedLineCount: this.model.minReservedLineCount.read(reader),
                targetTextModel: textModel,
            };
        });
        this.decorations = (0, observable_1.derived)(this, reader => {
            const uiState = this.uiState.read(reader);
            if (!uiState) {
                return [];
            }
            const decorations = [];
            if (uiState.replacedRange) {
                decorations.push({
                    range: uiState.replacedRange.toRange(uiState.lineNumber),
                    options: { inlineClassName: 'inline-completion-text-to-replace', description: 'GhostTextReplacement' }
                });
            }
            if (uiState.hiddenRange) {
                decorations.push({
                    range: uiState.hiddenRange.toRange(uiState.lineNumber),
                    options: { inlineClassName: 'ghost-text-hidden', description: 'ghost-text-hidden', }
                });
            }
            for (const p of uiState.inlineTexts) {
                decorations.push({
                    range: range_1.Range.fromPositions(new position_1.Position(uiState.lineNumber, p.column)),
                    options: {
                        description: exports.GHOST_TEXT_DESCRIPTION,
                        after: { content: p.text, inlineClassName: p.preview ? 'ghost-text-decoration-preview' : 'ghost-text-decoration', cursorStops: model_1.InjectedTextCursorStops.Left },
                        showIfCollapsed: true,
                    }
                });
            }
            return decorations;
        });
        this.additionalLinesWidget = this._register(new AdditionalLinesWidget(this.editor, this.languageService.languageIdCodec, (0, observable_1.derived)(reader => {
            /** @description lines */
            const uiState = this.uiState.read(reader);
            return uiState ? {
                lineNumber: uiState.lineNumber,
                additionalLines: uiState.additionalLines,
                minReservedLineCount: uiState.additionalReservedLineCount,
                targetTextModel: uiState.targetTextModel,
            } : undefined;
        })));
        this._register((0, lifecycle_1.toDisposable)(() => { this.isDisposed.set(true, undefined); }));
        this._register((0, utils_1.applyObservableDecorations)(this.editor, this.decorations));
    }
    ownsViewZone(viewZoneId) {
        return this.additionalLinesWidget.viewZoneId === viewZoneId;
    }
};
exports.GhostTextWidget = GhostTextWidget;
exports.GhostTextWidget = GhostTextWidget = __decorate([
    __param(2, language_1.ILanguageService)
], GhostTextWidget);
class AdditionalLinesWidget extends lifecycle_1.Disposable {
    get viewZoneId() { return this._viewZoneId; }
    constructor(editor, languageIdCodec, lines) {
        super();
        this.editor = editor;
        this.languageIdCodec = languageIdCodec;
        this.lines = lines;
        this._viewZoneId = undefined;
        this.editorOptionsChanged = (0, observable_1.observableSignalFromEvent)('editorOptionChanged', event_1.Event.filter(this.editor.onDidChangeConfiguration, e => e.hasChanged(33 /* EditorOption.disableMonospaceOptimizations */)
            || e.hasChanged(117 /* EditorOption.stopRenderingLineAfter */)
            || e.hasChanged(99 /* EditorOption.renderWhitespace */)
            || e.hasChanged(94 /* EditorOption.renderControlCharacters */)
            || e.hasChanged(51 /* EditorOption.fontLigatures */)
            || e.hasChanged(50 /* EditorOption.fontInfo */)
            || e.hasChanged(67 /* EditorOption.lineHeight */)));
        this._register((0, observable_1.autorun)(reader => {
            /** @description update view zone */
            const lines = this.lines.read(reader);
            this.editorOptionsChanged.read(reader);
            if (lines) {
                this.updateLines(lines.lineNumber, lines.additionalLines, lines.minReservedLineCount);
            }
            else {
                this.clear();
            }
        }));
    }
    dispose() {
        super.dispose();
        this.clear();
    }
    clear() {
        this.editor.changeViewZones((changeAccessor) => {
            if (this._viewZoneId) {
                changeAccessor.removeZone(this._viewZoneId);
                this._viewZoneId = undefined;
            }
        });
    }
    updateLines(lineNumber, additionalLines, minReservedLineCount) {
        const textModel = this.editor.getModel();
        if (!textModel) {
            return;
        }
        const { tabSize } = textModel.getOptions();
        this.editor.changeViewZones((changeAccessor) => {
            if (this._viewZoneId) {
                changeAccessor.removeZone(this._viewZoneId);
                this._viewZoneId = undefined;
            }
            const heightInLines = Math.max(additionalLines.length, minReservedLineCount);
            if (heightInLines > 0) {
                const domNode = document.createElement('div');
                renderLines(domNode, tabSize, additionalLines, this.editor.getOptions(), this.languageIdCodec);
                this._viewZoneId = changeAccessor.addZone({
                    afterLineNumber: lineNumber,
                    heightInLines: heightInLines,
                    domNode,
                    afterColumnAffinity: 1 /* PositionAffinity.Right */
                });
            }
        });
    }
}
exports.AdditionalLinesWidget = AdditionalLinesWidget;
function renderLines(domNode, tabSize, lines, opts, languageIdCodec) {
    const disableMonospaceOptimizations = opts.get(33 /* EditorOption.disableMonospaceOptimizations */);
    const stopRenderingLineAfter = opts.get(117 /* EditorOption.stopRenderingLineAfter */);
    // To avoid visual confusion, we don't want to render visible whitespace
    const renderWhitespace = 'none';
    const renderControlCharacters = opts.get(94 /* EditorOption.renderControlCharacters */);
    const fontLigatures = opts.get(51 /* EditorOption.fontLigatures */);
    const fontInfo = opts.get(50 /* EditorOption.fontInfo */);
    const lineHeight = opts.get(67 /* EditorOption.lineHeight */);
    const sb = new stringBuilder_1.StringBuilder(10000);
    sb.appendString('<div class="suggest-preview-text">');
    for (let i = 0, len = lines.length; i < len; i++) {
        const lineData = lines[i];
        const line = lineData.content;
        sb.appendString('<div class="view-line');
        sb.appendString('" style="top:');
        sb.appendString(String(i * lineHeight));
        sb.appendString('px;width:1000000px;">');
        const isBasicASCII = strings.isBasicASCII(line);
        const containsRTL = strings.containsRTL(line);
        const lineTokens = lineTokens_1.LineTokens.createEmpty(line, languageIdCodec);
        (0, viewLineRenderer_1.renderViewLine)(new viewLineRenderer_1.RenderLineInput((fontInfo.isMonospace && !disableMonospaceOptimizations), fontInfo.canUseHalfwidthRightwardsArrow, line, false, isBasicASCII, containsRTL, 0, lineTokens, lineData.decorations, tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures !== editorOptions_1.EditorFontLigatures.OFF, null), sb);
        sb.appendString('</div>');
    }
    sb.appendString('</div>');
    (0, domFontInfo_1.applyFontInfo)(domNode, fontInfo);
    const html = sb.build();
    const trustedhtml = exports.ttPolicy ? exports.ttPolicy.createHTML(html) : html;
    domNode.innerHTML = trustedhtml;
}
exports.ttPolicy = (0, trustedTypes_1.createTrustedTypesPolicy)('editorGhostText', { createHTML: value => value });
//# sourceMappingURL=ghostTextWidget.js.map