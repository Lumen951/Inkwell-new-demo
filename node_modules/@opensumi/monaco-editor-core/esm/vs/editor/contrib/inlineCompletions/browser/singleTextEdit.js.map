{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/editor/contrib/inlineCompletions/browser/singleTextEdit.ts","vs/editor/contrib/inlineCompletions/browser/singleTextEdit.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;;AAEhG,4DAAyE;AACzE,6DAA2F;AAE3F,sDAAmD;AAEnD,2CAAuD;AACvD,mCAAqD;AAErD,MAAa,cAAc;IAC1B,YACiB,KAAY,EACZ,IAAY;QADZ,UAAK,GAAL,KAAK,CAAO;QACZ,SAAI,GAAJ,IAAI,CAAQ;IAE7B,CAAC;IAED,MAAM,CAAC,MAAM,CAAC,KAAqB,EAAE,MAAsB;QAC1D,OAAO,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,IAAI,KAAK,MAAM,CAAC,IAAI,CAAC;IAE5E,CAAC;IAED,kBAAkB,CAAC,KAAiB,EAAE,eAAuB;QAC5D,MAAM,UAAU,GAAG,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;QAC9F,IAAI,CAAC,UAAU,EAAE,CAAC;YACjB,OAAO,IAAI,CAAC;QACb,CAAC;QACD,MAAM,cAAc,GAAG,KAAK,CAAC,eAAe,CAAC,UAAU,iCAAyB,CAAC;QACjF,MAAM,eAAe,GAAG,IAAA,4BAAkB,EAAC,cAAc,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;QACtE,MAAM,KAAK,GAAG,IAAA,oBAAY,EAAC,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE,EAAE,IAAA,oBAAY,EAAC,cAAc,CAAC,SAAS,CAAC,CAAC,EAAE,eAAe,CAAC,CAAC,CAAC,CAAC;QACtH,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC;QAClD,MAAM,KAAK,GAAG,aAAK,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC,CAAC;QACtE,OAAO,IAAI,cAAc,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;IACxC,CAAC;IAED,QAAQ,CAAC,IAAoB;QAC5B,kFAAkF;QAClF,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,YAAY,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;IAChF,CAAC;IAED;;;MAGE;IACF,gBAAgB,CACf,KAAiB,EACjB,IAA2C,EAC3C,cAAyB,EACzB,mBAAmB,GAAG,CAAC;QAEvB,IAAI,IAAI,GAAG,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;QAE1C,IAAI,IAAI,CAAC,KAAK,CAAC,aAAa,KAAK,IAAI,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC;YAC7D,oFAAoF;YACpF,OAAO,SAAS,CAAC;QAClB,CAAC;QAED,MAAM,UAAU,GAAG,KAAK,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;QACpE,MAAM,uBAAuB,GAAG,IAAA,8BAAoB,EAAC,UAAU,CAAC,CAAC,MAAM,CAAC;QAExE,MAAM,4BAA4B,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,CAAC,IAAI,uBAAuB,CAAC;QAC3F,IAAI,4BAA4B,EAAE,CAAC;YAClC,qCAAqC;YACrC,2DAA2D;YAC3D,yDAAyD;YACzD,4DAA4D;YAC5D,uEAAuE;YAEvE,iCAAiC;YACjC,8DAA8D;YAE9D,MAAM,gCAAgC,GAAG,IAAA,8BAAoB,EAAC,IAAI,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC;YAEhF,MAAM,mBAAmB,GAAG,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,CAAC,EAAE,uBAAuB,CAAC,CAAC;YAEtG,MAAM,CAAC,aAAa,EAAE,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE,EAAE,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC,CAAC;YAClG,MAAM,gBAAgB,GACrB,aAAa,CAAC,MAAM,GAAG,mBAAmB,CAAC,MAAM,IAAI,WAAW,CAAC,MAAM;gBACtE,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,EAAE,mBAAmB,CAAC,MAAM,CAAC;gBACpD,CAAC,CAAC,WAAW,CAAC;YAChB,MAAM,kCAAkC,GAAG,aAAK,CAAC,aAAa,CAAC,gBAAgB,EAAE,WAAW,CAAC,CAAC;YAE9F,MAAM,kCAAkC,GACvC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,mBAAmB,CAAC;gBACxC,8FAA8F;gBAC9F,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,mBAAmB,CAAC,MAAM,CAAC;gBACjD,6FAA6F;gBAC7F,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,gCAAgC,CAAC,CAAC;YAE1D,IAAI,GAAG,IAAI,cAAc,CAAC,kCAAkC,EAAE,kCAAkC,CAAC,CAAC;QACnG,CAAC;QAED,+BAA+B;QAC/B,MAAM,iBAAiB,GAAG,KAAK,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAE5D,MAAM,OAAO,GAAG,WAAW,CAAC,iBAAiB,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;QAE1D,IAAI,CAAC,OAAO,EAAE,CAAC;YACd,8DAA8D;YAC9D,OAAO,SAAS,CAAC;QAClB,CAAC;QAED,MAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC;QAE9C,MAAM,KAAK,GAAG,IAAI,KAAK,EAAiB,CAAC;QAEzC,IAAI,IAAI,KAAK,QAAQ,EAAE,CAAC;YACvB,MAAM,eAAe,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,cAAc,KAAK,CAAC,CAAC,CAAC;YACpE,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,IAAI,eAAe,CAAC,CAAC,CAAC,CAAC,aAAa,KAAK,iBAAiB,CAAC,MAAM,EAAE,CAAC;gBACjI,sCAAsC;gBACtC,OAAO,SAAS,CAAC;YAClB,CAAC;QACF,CAAC;QAED,MAAM,4BAA4B,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,mBAAmB,CAAC;QAE5E,KAAK,MAAM,CAAC,IAAI,OAAO,EAAE,CAAC;YACzB,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,CAAC,CAAC,aAAa,GAAG,CAAC,CAAC,cAAc,CAAC;YAEjF,IAAI,IAAI,KAAK,cAAc,IAAI,cAAc,IAAI,cAAc,CAAC,UAAU,KAAK,IAAI,CAAC,KAAK,CAAC,eAAe,IAAI,YAAY,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC;gBACnJ,8BAA8B;gBAC9B,OAAO,SAAS,CAAC;YAClB,CAAC;YAED,IAAI,CAAC,CAAC,cAAc,GAAG,CAAC,EAAE,CAAC;gBAC1B,OAAO,SAAS,CAAC;YAClB,CAAC;YAED,IAAI,CAAC,CAAC,cAAc,KAAK,CAAC,EAAE,CAAC;gBAC5B,SAAS;YACV,CAAC;YAED,MAAM,WAAW,GAAG,CAAC,CAAC,aAAa,GAAG,CAAC,CAAC,cAAc,CAAC;YACvD,MAAM,iBAAiB,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,aAAa,EAAE,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,4BAA4B,CAAC,CAAC,CAAC;YACzG,MAAM,cAAc,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,aAAa,EAAE,iBAAiB,CAAC,CAAC;YAC/E,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,iBAAiB,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC,CAAC;YAElG,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC/B,KAAK,CAAC,IAAI,CAAC,IAAI,yBAAa,CAAC,YAAY,EAAE,cAAc,EAAE,KAAK,CAAC,CAAC,CAAC;YACpE,CAAC;YACD,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC3B,KAAK,CAAC,IAAI,CAAC,IAAI,yBAAa,CAAC,YAAY,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC,CAAC;YAC/D,CAAC;QACF,CAAC;QAED,OAAO,IAAI,qBAAS,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;IACzC,CAAC;CACD;AAzID,wCAyIC;AAED,SAAS,YAAY,CAAC,cAAqB,EAAE,aAAoB;IAChE,OAAO,aAAa,CAAC,gBAAgB,EAAE,CAAC,MAAM,CAAC,cAAc,CAAC,gBAAgB,EAAE,CAAC;WAC7E,aAAa,CAAC,cAAc,EAAE,CAAC,eAAe,CAAC,cAAc,CAAC,cAAc,EAAE,CAAC,CAAC;AACrF,CAAC;AAED,IAAI,WAAW,GAAyG,SAAS,CAAC;AAClI,SAAS,WAAW,CAAC,aAAqB,EAAE,QAAgB;IAC3D,IAAI,CAAA,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,aAAa,MAAK,aAAa,IAAI,CAAA,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,QAAQ,MAAK,QAAQ,EAAE,CAAC;QACxF,OAAO,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,OAAO,CAAC;IAC7B,CAAC;SAAM,CAAC;QACP,IAAI,OAAO,GAAG,SAAS,CAAC,aAAa,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC;QACvD,IAAI,OAAO,EAAE,CAAC;YACb,MAAM,YAAY,GAAG,iBAAiB,CAAC,OAAO,CAAC,CAAC;YAChD,IAAI,YAAY,GAAG,CAAC,EAAE,CAAC;gBACtB,6EAA6E;gBAC7E,MAAM,UAAU,GAAG,SAAS,CAAC,aAAa,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;gBAC7D,IAAI,UAAU,IAAI,iBAAiB,CAAC,UAAU,CAAC,GAAG,YAAY,EAAE,CAAC;oBAChE,8CAA8C;oBAC9C,OAAO,GAAG,UAAU,CAAC;gBACtB,CAAC;YACF,CAAC;QACF,CAAC;QACD,WAAW,GAAG;YACb,aAAa;YACb,QAAQ;YACR,OAAO;SACP,CAAC;QACF,OAAO,OAAO,CAAC;IAChB,CAAC;AACF,CAAC;AAED,SAAS,iBAAiB,CAAC,OAA+B;IACzD,IAAI,GAAG,GAAG,CAAC,CAAC;IACZ,KAAK,MAAM,CAAC,IAAI,OAAO,EAAE,CAAC;QACzB,GAAG,IAAI,CAAC,CAAC,cAAc,CAAC;IACzB,CAAC;IACD,OAAO,GAAG,CAAC;AACZ,CAAC;AAED;;;;;;;GAOG;AACH,SAAS,SAAS,CAAC,aAAqB,EAAE,QAAgB,EAAE,oBAA6B;IACxF,IAAI,aAAa,CAAC,MAAM,GAAG,IAAI,IAAI,QAAQ,CAAC,MAAM,GAAG,IAAI,EAAE,CAAC;QAC3D,oDAAoD;QACpD,OAAO,SAAS,CAAC;IAClB,CAAC;IAED,SAAS,cAAc,CAAC,GAAW;QAClC,IAAI,WAAW,GAAG,CAAC,CAAC;QACpB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC;YAChD,MAAM,QAAQ,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YACnC,IAAI,QAAQ,GAAG,WAAW,EAAE,CAAC;gBAC5B,WAAW,GAAG,QAAQ,CAAC;YACxB,CAAC;QACF,CAAC;QACD,OAAO,WAAW,CAAC;IACpB,CAAC;IAED,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,aAAa,CAAC,EAAE,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC;IACtF,SAAS,iBAAiB,CAAC,EAAU;QACpC,IAAI,EAAE,GAAG,CAAC,EAAE,CAAC;YACZ,MAAM,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;QAC/B,CAAC;QACD,OAAO,WAAW,GAAG,EAAE,GAAG,CAAC,CAAC;IAC7B,CAAC;IAED,SAAS,WAAW,CAAC,MAAc;QAClC,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,MAAM,UAAU,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QACjD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC;YACnD,6BAA6B;YAC7B,IAAI,oBAAoB,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC;gBAC/C,MAAM,EAAE,GAAG,KAAK,GAAG,GAAG,GAAG,KAAK,CAAC;gBAC/B,UAAU,CAAC,CAAC,CAAC,GAAG,iBAAiB,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;gBAC1C,KAAK,EAAE,CAAC;YACT,CAAC;iBAAM,IAAI,oBAAoB,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC;gBACtD,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;gBAC/B,MAAM,EAAE,GAAG,KAAK,GAAG,GAAG,GAAG,KAAK,CAAC;gBAC/B,UAAU,CAAC,CAAC,CAAC,GAAG,iBAAiB,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;gBAC9C,IAAI,KAAK,KAAK,CAAC,EAAE,CAAC;oBACjB,KAAK,EAAE,CAAC;gBACT,CAAC;YACF,CAAC;iBAAM,CAAC;gBACP,UAAU,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YACtC,CAAC;QACF,CAAC;QACD,OAAO,UAAU,CAAC;IACnB,CAAC;IAED,MAAM,SAAS,GAAG,WAAW,CAAC,aAAa,CAAC,CAAC;IAC7C,MAAM,SAAS,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC;IAExC,OAAO,IAAI,cAAO,CAAC,EAAE,WAAW,EAAE,GAAG,EAAE,CAAC,SAAS,EAAE,EAAE,EAAE,WAAW,EAAE,GAAG,EAAE,CAAC,SAAS,EAAE,CAAC,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC;AACnH,CAAC","file":"singleTextEdit.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDiffChange, LcsDiff } from '../../../../base/common/diff/diff';\nimport { commonPrefixLength, getLeadingWhitespace } from '../../../../base/common/strings';\nimport { Position } from '../../../common/core/position';\nimport { Range } from '../../../common/core/range';\nimport { EndOfLinePreference, ITextModel } from '../../../common/model';\nimport { GhostText, GhostTextPart } from './ghostText';\nimport { addPositions, lengthOfText } from './utils';\n\nexport class SingleTextEdit {\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly text: string\n\t) {\n\t}\n\n\tstatic equals(first: SingleTextEdit, second: SingleTextEdit) {\n\t\treturn first.range.equalsRange(second.range) && first.text === second.text;\n\n\t}\n\n\tremoveCommonPrefix(model: ITextModel, validModelRange?: Range): SingleTextEdit {\n\t\tconst modelRange = validModelRange ? this.range.intersectRanges(validModelRange) : this.range;\n\t\tif (!modelRange) {\n\t\t\treturn this;\n\t\t}\n\t\tconst valueToReplace = model.getValueInRange(modelRange, EndOfLinePreference.LF);\n\t\tconst commonPrefixLen = commonPrefixLength(valueToReplace, this.text);\n\t\tconst start = addPositions(this.range.getStartPosition(), lengthOfText(valueToReplace.substring(0, commonPrefixLen)));\n\t\tconst text = this.text.substring(commonPrefixLen);\n\t\tconst range = Range.fromPositions(start, this.range.getEndPosition());\n\t\treturn new SingleTextEdit(range, text);\n\t}\n\n\taugments(base: SingleTextEdit): boolean {\n\t\t// The augmented completion must replace the base range, but can replace even more\n\t\treturn this.text.startsWith(base.text) && rangeExtends(this.range, base.range);\n\t}\n\n\t/**\n\t * @param previewSuffixLength Sets where to split `inlineCompletion.text`.\n\t * \tIf the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.\n\t*/\n\tcomputeGhostText(\n\t\tmodel: ITextModel,\n\t\tmode: 'prefix' | 'subword' | 'subwordSmart',\n\t\tcursorPosition?: Position,\n\t\tpreviewSuffixLength = 0\n\t): GhostText | undefined {\n\t\tlet edit = this.removeCommonPrefix(model);\n\n\t\tif (edit.range.endLineNumber !== edit.range.startLineNumber) {\n\t\t\t// This edit might span multiple lines, but the first lines must be a common prefix.\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst sourceLine = model.getLineContent(edit.range.startLineNumber);\n\t\tconst sourceIndentationLength = getLeadingWhitespace(sourceLine).length;\n\n\t\tconst suggestionTouchesIndentation = edit.range.startColumn - 1 <= sourceIndentationLength;\n\t\tif (suggestionTouchesIndentation) {\n\t\t\t// source:      ··········[······abc]\n\t\t\t//                         ^^^^^^^^^ inlineCompletion.range\n\t\t\t//              ^^^^^^^^^^ ^^^^^^ sourceIndentationLength\n\t\t\t//                         ^^^^^^ replacedIndentation.length\n\t\t\t//                               ^^^ rangeThatDoesNotReplaceIndentation\n\n\t\t\t// inlineCompletion.text: '··foo'\n\t\t\t//                         ^^ suggestionAddedIndentationLength\n\n\t\t\tconst suggestionAddedIndentationLength = getLeadingWhitespace(edit.text).length;\n\n\t\t\tconst replacedIndentation = sourceLine.substring(edit.range.startColumn - 1, sourceIndentationLength);\n\n\t\t\tconst [startPosition, endPosition] = [edit.range.getStartPosition(), edit.range.getEndPosition()];\n\t\t\tconst newStartPosition =\n\t\t\t\tstartPosition.column + replacedIndentation.length <= endPosition.column\n\t\t\t\t\t? startPosition.delta(0, replacedIndentation.length)\n\t\t\t\t\t: endPosition;\n\t\t\tconst rangeThatDoesNotReplaceIndentation = Range.fromPositions(newStartPosition, endPosition);\n\n\t\t\tconst suggestionWithoutIndentationChange =\n\t\t\t\tedit.text.startsWith(replacedIndentation)\n\t\t\t\t\t// Adds more indentation without changing existing indentation: We can add ghost text for this\n\t\t\t\t\t? edit.text.substring(replacedIndentation.length)\n\t\t\t\t\t// Changes or removes existing indentation. Only add ghost text for the non-indentation part.\n\t\t\t\t\t: edit.text.substring(suggestionAddedIndentationLength);\n\n\t\t\tedit = new SingleTextEdit(rangeThatDoesNotReplaceIndentation, suggestionWithoutIndentationChange);\n\t\t}\n\n\t\t// This is a single line string\n\t\tconst valueToBeReplaced = model.getValueInRange(edit.range);\n\n\t\tconst changes = cachingDiff(valueToBeReplaced, edit.text);\n\n\t\tif (!changes) {\n\t\t\t// No ghost text in case the diff would be too slow to compute\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst lineNumber = edit.range.startLineNumber;\n\n\t\tconst parts = new Array<GhostTextPart>();\n\n\t\tif (mode === 'prefix') {\n\t\t\tconst filteredChanges = changes.filter(c => c.originalLength === 0);\n\t\t\tif (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {\n\t\t\t\t// Prefixes only have a single change.\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\tconst previewStartInCompletionText = edit.text.length - previewSuffixLength;\n\n\t\tfor (const c of changes) {\n\t\t\tconst insertColumn = edit.range.startColumn + c.originalStart + c.originalLength;\n\n\t\t\tif (mode === 'subwordSmart' && cursorPosition && cursorPosition.lineNumber === edit.range.startLineNumber && insertColumn < cursorPosition.column) {\n\t\t\t\t// No ghost text before cursor\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (c.originalLength > 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (c.modifiedLength === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst modifiedEnd = c.modifiedStart + c.modifiedLength;\n\t\t\tconst nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));\n\t\t\tconst nonPreviewText = edit.text.substring(c.modifiedStart, nonPreviewTextEnd);\n\t\t\tconst italicText = edit.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));\n\n\t\t\tif (nonPreviewText.length > 0) {\n\t\t\t\tparts.push(new GhostTextPart(insertColumn, nonPreviewText, false));\n\t\t\t}\n\t\t\tif (italicText.length > 0) {\n\t\t\t\tparts.push(new GhostTextPart(insertColumn, italicText, true));\n\t\t\t}\n\t\t}\n\n\t\treturn new GhostText(lineNumber, parts);\n\t}\n}\n\nfunction rangeExtends(extendingRange: Range, rangeToExtend: Range): boolean {\n\treturn rangeToExtend.getStartPosition().equals(extendingRange.getStartPosition())\n\t\t&& rangeToExtend.getEndPosition().isBeforeOrEqual(extendingRange.getEndPosition());\n}\n\nlet lastRequest: { originalValue: string; newValue: string; changes: readonly IDiffChange[] | undefined } | undefined = undefined;\nfunction cachingDiff(originalValue: string, newValue: string): readonly IDiffChange[] | undefined {\n\tif (lastRequest?.originalValue === originalValue && lastRequest?.newValue === newValue) {\n\t\treturn lastRequest?.changes;\n\t} else {\n\t\tlet changes = smartDiff(originalValue, newValue, true);\n\t\tif (changes) {\n\t\t\tconst deletedChars = deletedCharacters(changes);\n\t\t\tif (deletedChars > 0) {\n\t\t\t\t// For performance reasons, don't compute diff if there is nothing to improve\n\t\t\t\tconst newChanges = smartDiff(originalValue, newValue, false);\n\t\t\t\tif (newChanges && deletedCharacters(newChanges) < deletedChars) {\n\t\t\t\t\t// Disabling smartness seems to be better here\n\t\t\t\t\tchanges = newChanges;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlastRequest = {\n\t\t\toriginalValue,\n\t\t\tnewValue,\n\t\t\tchanges\n\t\t};\n\t\treturn changes;\n\t}\n}\n\nfunction deletedCharacters(changes: readonly IDiffChange[]): number {\n\tlet sum = 0;\n\tfor (const c of changes) {\n\t\tsum += c.originalLength;\n\t}\n\treturn sum;\n}\n\n/**\n * When matching `if ()` with `if (f() = 1) { g(); }`,\n * align it like this:        `if (       )`\n * Not like this:\t\t\t  `if (  )`\n * Also not like this:\t\t  `if (             )`.\n *\n * The parenthesis are preprocessed to ensure that they match correctly.\n */\nfunction smartDiff(originalValue: string, newValue: string, smartBracketMatching: boolean): (readonly IDiffChange[]) | undefined {\n\tif (originalValue.length > 5000 || newValue.length > 5000) {\n\t\t// We don't want to work on strings that are too big\n\t\treturn undefined;\n\t}\n\n\tfunction getMaxCharCode(val: string): number {\n\t\tlet maxCharCode = 0;\n\t\tfor (let i = 0, len = val.length; i < len; i++) {\n\t\t\tconst charCode = val.charCodeAt(i);\n\t\t\tif (charCode > maxCharCode) {\n\t\t\t\tmaxCharCode = charCode;\n\t\t\t}\n\t\t}\n\t\treturn maxCharCode;\n\t}\n\n\tconst maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));\n\tfunction getUniqueCharCode(id: number): number {\n\t\tif (id < 0) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\treturn maxCharCode + id + 1;\n\t}\n\n\tfunction getElements(source: string): Int32Array {\n\t\tlet level = 0;\n\t\tlet group = 0;\n\t\tconst characters = new Int32Array(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\t// TODO support more brackets\n\t\t\tif (smartBracketMatching && source[i] === '(') {\n\t\t\t\tconst id = group * 100 + level;\n\t\t\t\tcharacters[i] = getUniqueCharCode(2 * id);\n\t\t\t\tlevel++;\n\t\t\t} else if (smartBracketMatching && source[i] === ')') {\n\t\t\t\tlevel = Math.max(level - 1, 0);\n\t\t\t\tconst id = group * 100 + level;\n\t\t\t\tcharacters[i] = getUniqueCharCode(2 * id + 1);\n\t\t\t\tif (level === 0) {\n\t\t\t\t\tgroup++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharacters[i] = source.charCodeAt(i);\n\t\t\t}\n\t\t}\n\t\treturn characters;\n\t}\n\n\tconst elements1 = getElements(originalValue);\n\tconst elements2 = getElements(newValue);\n\n\treturn new LcsDiff({ getElements: () => elements1 }, { getElements: () => elements2 }).ComputeDiff(false).changes;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDiffChange, LcsDiff } from '../../../../base/common/diff/diff';\nimport { commonPrefixLength, getLeadingWhitespace } from '../../../../base/common/strings';\nimport { Position } from '../../../common/core/position';\nimport { Range } from '../../../common/core/range';\nimport { EndOfLinePreference, ITextModel } from '../../../common/model';\nimport { GhostText, GhostTextPart } from './ghostText';\nimport { addPositions, lengthOfText } from './utils';\n\nexport class SingleTextEdit {\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly text: string\n\t) {\n\t}\n\n\tstatic equals(first: SingleTextEdit, second: SingleTextEdit) {\n\t\treturn first.range.equalsRange(second.range) && first.text === second.text;\n\n\t}\n\n\tremoveCommonPrefix(model: ITextModel, validModelRange?: Range): SingleTextEdit {\n\t\tconst modelRange = validModelRange ? this.range.intersectRanges(validModelRange) : this.range;\n\t\tif (!modelRange) {\n\t\t\treturn this;\n\t\t}\n\t\tconst valueToReplace = model.getValueInRange(modelRange, EndOfLinePreference.LF);\n\t\tconst commonPrefixLen = commonPrefixLength(valueToReplace, this.text);\n\t\tconst start = addPositions(this.range.getStartPosition(), lengthOfText(valueToReplace.substring(0, commonPrefixLen)));\n\t\tconst text = this.text.substring(commonPrefixLen);\n\t\tconst range = Range.fromPositions(start, this.range.getEndPosition());\n\t\treturn new SingleTextEdit(range, text);\n\t}\n\n\taugments(base: SingleTextEdit): boolean {\n\t\t// The augmented completion must replace the base range, but can replace even more\n\t\treturn this.text.startsWith(base.text) && rangeExtends(this.range, base.range);\n\t}\n\n\t/**\n\t * @param previewSuffixLength Sets where to split `inlineCompletion.text`.\n\t * \tIf the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.\n\t*/\n\tcomputeGhostText(\n\t\tmodel: ITextModel,\n\t\tmode: 'prefix' | 'subword' | 'subwordSmart',\n\t\tcursorPosition?: Position,\n\t\tpreviewSuffixLength = 0\n\t): GhostText | undefined {\n\t\tlet edit = this.removeCommonPrefix(model);\n\n\t\tif (edit.range.endLineNumber !== edit.range.startLineNumber) {\n\t\t\t// This edit might span multiple lines, but the first lines must be a common prefix.\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst sourceLine = model.getLineContent(edit.range.startLineNumber);\n\t\tconst sourceIndentationLength = getLeadingWhitespace(sourceLine).length;\n\n\t\tconst suggestionTouchesIndentation = edit.range.startColumn - 1 <= sourceIndentationLength;\n\t\tif (suggestionTouchesIndentation) {\n\t\t\t// source:      ··········[······abc]\n\t\t\t//                         ^^^^^^^^^ inlineCompletion.range\n\t\t\t//              ^^^^^^^^^^ ^^^^^^ sourceIndentationLength\n\t\t\t//                         ^^^^^^ replacedIndentation.length\n\t\t\t//                               ^^^ rangeThatDoesNotReplaceIndentation\n\n\t\t\t// inlineCompletion.text: '··foo'\n\t\t\t//                         ^^ suggestionAddedIndentationLength\n\n\t\t\tconst suggestionAddedIndentationLength = getLeadingWhitespace(edit.text).length;\n\n\t\t\tconst replacedIndentation = sourceLine.substring(edit.range.startColumn - 1, sourceIndentationLength);\n\n\t\t\tconst [startPosition, endPosition] = [edit.range.getStartPosition(), edit.range.getEndPosition()];\n\t\t\tconst newStartPosition =\n\t\t\t\tstartPosition.column + replacedIndentation.length <= endPosition.column\n\t\t\t\t\t? startPosition.delta(0, replacedIndentation.length)\n\t\t\t\t\t: endPosition;\n\t\t\tconst rangeThatDoesNotReplaceIndentation = Range.fromPositions(newStartPosition, endPosition);\n\n\t\t\tconst suggestionWithoutIndentationChange =\n\t\t\t\tedit.text.startsWith(replacedIndentation)\n\t\t\t\t\t// Adds more indentation without changing existing indentation: We can add ghost text for this\n\t\t\t\t\t? edit.text.substring(replacedIndentation.length)\n\t\t\t\t\t// Changes or removes existing indentation. Only add ghost text for the non-indentation part.\n\t\t\t\t\t: edit.text.substring(suggestionAddedIndentationLength);\n\n\t\t\tedit = new SingleTextEdit(rangeThatDoesNotReplaceIndentation, suggestionWithoutIndentationChange);\n\t\t}\n\n\t\t// This is a single line string\n\t\tconst valueToBeReplaced = model.getValueInRange(edit.range);\n\n\t\tconst changes = cachingDiff(valueToBeReplaced, edit.text);\n\n\t\tif (!changes) {\n\t\t\t// No ghost text in case the diff would be too slow to compute\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst lineNumber = edit.range.startLineNumber;\n\n\t\tconst parts = new Array<GhostTextPart>();\n\n\t\tif (mode === 'prefix') {\n\t\t\tconst filteredChanges = changes.filter(c => c.originalLength === 0);\n\t\t\tif (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {\n\t\t\t\t// Prefixes only have a single change.\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\tconst previewStartInCompletionText = edit.text.length - previewSuffixLength;\n\n\t\tfor (const c of changes) {\n\t\t\tconst insertColumn = edit.range.startColumn + c.originalStart + c.originalLength;\n\n\t\t\tif (mode === 'subwordSmart' && cursorPosition && cursorPosition.lineNumber === edit.range.startLineNumber && insertColumn < cursorPosition.column) {\n\t\t\t\t// No ghost text before cursor\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (c.originalLength > 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (c.modifiedLength === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst modifiedEnd = c.modifiedStart + c.modifiedLength;\n\t\t\tconst nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));\n\t\t\tconst nonPreviewText = edit.text.substring(c.modifiedStart, nonPreviewTextEnd);\n\t\t\tconst italicText = edit.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));\n\n\t\t\tif (nonPreviewText.length > 0) {\n\t\t\t\tparts.push(new GhostTextPart(insertColumn, nonPreviewText, false));\n\t\t\t}\n\t\t\tif (italicText.length > 0) {\n\t\t\t\tparts.push(new GhostTextPart(insertColumn, italicText, true));\n\t\t\t}\n\t\t}\n\n\t\treturn new GhostText(lineNumber, parts);\n\t}\n}\n\nfunction rangeExtends(extendingRange: Range, rangeToExtend: Range): boolean {\n\treturn rangeToExtend.getStartPosition().equals(extendingRange.getStartPosition())\n\t\t&& rangeToExtend.getEndPosition().isBeforeOrEqual(extendingRange.getEndPosition());\n}\n\nlet lastRequest: { originalValue: string; newValue: string; changes: readonly IDiffChange[] | undefined } | undefined = undefined;\nfunction cachingDiff(originalValue: string, newValue: string): readonly IDiffChange[] | undefined {\n\tif (lastRequest?.originalValue === originalValue && lastRequest?.newValue === newValue) {\n\t\treturn lastRequest?.changes;\n\t} else {\n\t\tlet changes = smartDiff(originalValue, newValue, true);\n\t\tif (changes) {\n\t\t\tconst deletedChars = deletedCharacters(changes);\n\t\t\tif (deletedChars > 0) {\n\t\t\t\t// For performance reasons, don't compute diff if there is nothing to improve\n\t\t\t\tconst newChanges = smartDiff(originalValue, newValue, false);\n\t\t\t\tif (newChanges && deletedCharacters(newChanges) < deletedChars) {\n\t\t\t\t\t// Disabling smartness seems to be better here\n\t\t\t\t\tchanges = newChanges;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlastRequest = {\n\t\t\toriginalValue,\n\t\t\tnewValue,\n\t\t\tchanges\n\t\t};\n\t\treturn changes;\n\t}\n}\n\nfunction deletedCharacters(changes: readonly IDiffChange[]): number {\n\tlet sum = 0;\n\tfor (const c of changes) {\n\t\tsum += c.originalLength;\n\t}\n\treturn sum;\n}\n\n/**\n * When matching `if ()` with `if (f() = 1) { g(); }`,\n * align it like this:        `if (       )`\n * Not like this:\t\t\t  `if (  )`\n * Also not like this:\t\t  `if (             )`.\n *\n * The parenthesis are preprocessed to ensure that they match correctly.\n */\nfunction smartDiff(originalValue: string, newValue: string, smartBracketMatching: boolean): (readonly IDiffChange[]) | undefined {\n\tif (originalValue.length > 5000 || newValue.length > 5000) {\n\t\t// We don't want to work on strings that are too big\n\t\treturn undefined;\n\t}\n\n\tfunction getMaxCharCode(val: string): number {\n\t\tlet maxCharCode = 0;\n\t\tfor (let i = 0, len = val.length; i < len; i++) {\n\t\t\tconst charCode = val.charCodeAt(i);\n\t\t\tif (charCode > maxCharCode) {\n\t\t\t\tmaxCharCode = charCode;\n\t\t\t}\n\t\t}\n\t\treturn maxCharCode;\n\t}\n\n\tconst maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));\n\tfunction getUniqueCharCode(id: number): number {\n\t\tif (id < 0) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\treturn maxCharCode + id + 1;\n\t}\n\n\tfunction getElements(source: string): Int32Array {\n\t\tlet level = 0;\n\t\tlet group = 0;\n\t\tconst characters = new Int32Array(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\t// TODO support more brackets\n\t\t\tif (smartBracketMatching && source[i] === '(') {\n\t\t\t\tconst id = group * 100 + level;\n\t\t\t\tcharacters[i] = getUniqueCharCode(2 * id);\n\t\t\t\tlevel++;\n\t\t\t} else if (smartBracketMatching && source[i] === ')') {\n\t\t\t\tlevel = Math.max(level - 1, 0);\n\t\t\t\tconst id = group * 100 + level;\n\t\t\t\tcharacters[i] = getUniqueCharCode(2 * id + 1);\n\t\t\t\tif (level === 0) {\n\t\t\t\t\tgroup++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharacters[i] = source.charCodeAt(i);\n\t\t\t}\n\t\t}\n\t\treturn characters;\n\t}\n\n\tconst elements1 = getElements(originalValue);\n\tconst elements2 = getElements(newValue);\n\n\treturn new LcsDiff({ getElements: () => elements1 }, { getElements: () => elements2 }).ComputeDiff(false).changes;\n}\n"]}