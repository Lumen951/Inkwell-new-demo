{"version":3,"sources":["file:///workspaces/monaco-editor-core/out-editor-esm/vs/editor/contrib/inlineCompletions/browser/provideInlineCompletions.ts","vs/editor/contrib/inlineCompletions/browser/provideInlineCompletions.ts"],"names":[],"mappings":"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","file":"provideInlineCompletions.js","sourceRoot":"file:///workspaces/monaco-editor-core/out-editor-esm","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertNever } from '../../../../base/common/assert';\nimport { DeferredPromise } from '../../../../base/common/async';\nimport { CancellationToken } from '../../../../base/common/cancellation';\nimport { SetMap } from '../../../../base/common/map';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors';\nimport { IDisposable } from '../../../../base/common/lifecycle';\nimport { ISingleEditOperation } from '../../../common/core/editOperation';\nimport { Position } from '../../../common/core/position';\nimport { Range } from '../../../common/core/range';\nimport { LanguageFeatureRegistry } from '../../../common/languageFeatureRegistry';\nimport { Command, InlineCompletion, InlineCompletionContext, InlineCompletionProviderGroupId, InlineCompletions, InlineCompletionsProvider } from '../../../common/languages';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry';\nimport { ITextModel } from '../../../common/model';\nimport { fixBracketsInLine } from '../../../common/model/bracketPairsTextModelPart/fixBrackets';\nimport { SingleTextEdit } from './singleTextEdit';\nimport { getReadonlyEmptyArray } from './utils';\nimport { SnippetParser, Text } from '../../snippet/browser/snippetParser';\n\nexport async function provideInlineCompletions(\n\tregistry: LanguageFeatureRegistry<InlineCompletionsProvider>,\n\tposition: Position,\n\tmodel: ITextModel,\n\tcontext: InlineCompletionContext,\n\ttoken: CancellationToken = CancellationToken.None,\n\tlanguageConfigurationService?: ILanguageConfigurationService,\n): Promise<InlineCompletionProviderResult> {\n\t// Important: Don't use position after the await calls, as the model could have been changed in the meantime!\n\tconst defaultReplaceRange = getDefaultRange(position, model);\n\tconst providers = registry.all(model);\n\n\tconst multiMap = new SetMap<InlineCompletionProviderGroupId, InlineCompletionsProvider<any>>();\n\tfor (const provider of providers) {\n\t\tif (provider.groupId) {\n\t\t\tmultiMap.add(provider.groupId, provider);\n\t\t}\n\t}\n\n\tfunction getPreferredProviders(provider: InlineCompletionsProvider<any>): InlineCompletionsProvider<any>[] {\n\t\tif (!provider.yieldsToGroupIds) { return []; }\n\t\tconst result: InlineCompletionsProvider<any>[] = [];\n\t\tfor (const groupId of provider.yieldsToGroupIds || []) {\n\t\t\tconst providers = multiMap.get(groupId);\n\t\t\tfor (const p of providers) {\n\t\t\t\tresult.push(p);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\ttype Result = Promise<InlineCompletions<InlineCompletion> | null | undefined>;\n\tconst states = new Map<InlineCompletionsProvider<InlineCompletions<InlineCompletion>>, Result>();\n\n\tconst seen = new Set<InlineCompletionsProvider<InlineCompletions<InlineCompletion>>>();\n\tfunction findPreferredProviderCircle(provider: InlineCompletionsProvider<any>, stack: InlineCompletionsProvider[]): InlineCompletionsProvider[] | undefined {\n\t\tstack = [...stack, provider];\n\t\tif (seen.has(provider)) { return stack; }\n\n\t\tseen.add(provider);\n\t\ttry {\n\t\t\tconst preferred = getPreferredProviders(provider);\n\t\t\tfor (const p of preferred) {\n\t\t\t\tconst c = findPreferredProviderCircle(p, stack);\n\t\t\t\tif (c) { return c; }\n\t\t\t}\n\t\t} finally {\n\t\t\tseen.delete(provider);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tfunction processProvider(provider: InlineCompletionsProvider<any>): Result {\n\t\tconst state = states.get(provider);\n\t\tif (state) {\n\t\t\treturn state;\n\t\t}\n\n\t\tconst circle = findPreferredProviderCircle(provider, []);\n\t\tif (circle) {\n\t\t\tonUnexpectedExternalError(new Error(`Inline completions: cyclic yield-to dependency detected. Path: ${circle.map(s => s.toString ? s.toString() : ('' + s)).join(' -> ')}`));\n\t\t}\n\n\t\tconst deferredPromise = new DeferredPromise<InlineCompletions<InlineCompletion> | null | undefined>();\n\t\tstates.set(provider, deferredPromise.p);\n\n\t\t(async () => {\n\t\t\tif (!circle) {\n\t\t\t\tconst preferred = getPreferredProviders(provider);\n\t\t\t\tfor (const p of preferred) {\n\t\t\t\t\tconst result = await processProvider(p);\n\t\t\t\t\tif (result && result.items.length > 0) {\n\t\t\t\t\t\t// Skip provider\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst completions = await provider.provideInlineCompletions(model, position, context, token);\n\t\t\t\treturn completions;\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedExternalError(e);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t})().then(c => deferredPromise.complete(c), e => deferredPromise.error(e));\n\n\t\treturn deferredPromise.p;\n\t}\n\n\tconst providerResults = await Promise.all(providers.map(async provider => ({ provider, completions: await processProvider(provider) })));\n\n\tconst itemsByHash = new Map<string, InlineCompletionItem>();\n\tconst lists: InlineCompletionList[] = [];\n\tfor (const result of providerResults) {\n\t\tconst completions = result.completions;\n\t\tif (!completions) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst list = new InlineCompletionList(completions, result.provider);\n\t\tlists.push(list);\n\n\t\tfor (const item of completions.items) {\n\t\t\tconst inlineCompletionItem = InlineCompletionItem.from(\n\t\t\t\titem,\n\t\t\t\tlist,\n\t\t\t\tdefaultReplaceRange,\n\t\t\t\tmodel,\n\t\t\t\tlanguageConfigurationService\n\t\t\t);\n\t\t\titemsByHash.set(inlineCompletionItem.hash(), inlineCompletionItem);\n\t\t}\n\t}\n\n\treturn new InlineCompletionProviderResult(Array.from(itemsByHash.values()), new Set(itemsByHash.keys()), lists);\n}\n\nexport class InlineCompletionProviderResult implements IDisposable {\n\n\tconstructor(\n\t\t/**\n\t\t * Free of duplicates.\n\t\t */\n\t\tpublic readonly completions: readonly InlineCompletionItem[],\n\t\tprivate readonly hashs: Set<string>,\n\t\tprivate readonly providerResults: readonly InlineCompletionList[],\n\t) { }\n\n\tpublic has(item: InlineCompletionItem): boolean {\n\t\treturn this.hashs.has(item.hash());\n\t}\n\n\tdispose(): void {\n\t\tfor (const result of this.providerResults) {\n\t\t\tresult.removeRef();\n\t\t}\n\t}\n}\n\n/**\n * A ref counted pointer to the computed `InlineCompletions` and the `InlineCompletionsProvider` that\n * computed them.\n */\nexport class InlineCompletionList {\n\tprivate refCount = 1;\n\tconstructor(\n\t\tpublic readonly inlineCompletions: InlineCompletions,\n\t\tpublic readonly provider: InlineCompletionsProvider,\n\t) { }\n\n\taddRef(): void {\n\t\tthis.refCount++;\n\t}\n\n\tremoveRef(): void {\n\t\tthis.refCount--;\n\t\tif (this.refCount === 0) {\n\t\t\tthis.provider.freeInlineCompletions(this.inlineCompletions);\n\t\t}\n\t}\n}\n\nexport class InlineCompletionItem {\n\tpublic static from(\n\t\tinlineCompletion: InlineCompletion,\n\t\tsource: InlineCompletionList,\n\t\tdefaultReplaceRange: Range,\n\t\ttextModel: ITextModel,\n\t\tlanguageConfigurationService: ILanguageConfigurationService | undefined,\n\t) {\n\t\tlet insertText: string;\n\t\tlet snippetInfo: SnippetInfo | undefined;\n\t\tlet range = inlineCompletion.range ? Range.lift(inlineCompletion.range) : defaultReplaceRange;\n\n\t\tif (typeof inlineCompletion.insertText === 'string') {\n\t\t\tinsertText = inlineCompletion.insertText;\n\n\t\t\tif (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n\t\t\t\tinsertText = closeBrackets(\n\t\t\t\t\tinsertText,\n\t\t\t\t\trange.getStartPosition(),\n\t\t\t\t\ttextModel,\n\t\t\t\t\tlanguageConfigurationService\n\t\t\t\t);\n\n\t\t\t\t// Modify range depending on if brackets are added or removed\n\t\t\t\tconst diff = insertText.length - inlineCompletion.insertText.length;\n\t\t\t\tif (diff !== 0) {\n\t\t\t\t\trange = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsnippetInfo = undefined;\n\t\t} else if ('snippet' in inlineCompletion.insertText) {\n\t\t\tconst preBracketCompletionLength = inlineCompletion.insertText.snippet.length;\n\n\t\t\tif (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n\t\t\t\tinlineCompletion.insertText.snippet = closeBrackets(\n\t\t\t\t\tinlineCompletion.insertText.snippet,\n\t\t\t\t\trange.getStartPosition(),\n\t\t\t\t\ttextModel,\n\t\t\t\t\tlanguageConfigurationService\n\t\t\t\t);\n\n\t\t\t\t// Modify range depending on if brackets are added or removed\n\t\t\t\tconst diff = inlineCompletion.insertText.snippet.length - preBracketCompletionLength;\n\t\t\t\tif (diff !== 0) {\n\t\t\t\t\trange = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst snippet = new SnippetParser().parse(inlineCompletion.insertText.snippet);\n\n\t\t\tif (snippet.children.length === 1 && snippet.children[0] instanceof Text) {\n\t\t\t\tinsertText = snippet.children[0].value;\n\t\t\t\tsnippetInfo = undefined;\n\t\t\t} else {\n\t\t\t\tinsertText = snippet.toString();\n\t\t\t\tsnippetInfo = {\n\t\t\t\t\tsnippet: inlineCompletion.insertText.snippet,\n\t\t\t\t\trange: range\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tassertNever(inlineCompletion.insertText);\n\t\t}\n\n\t\treturn new InlineCompletionItem(\n\t\t\tinsertText,\n\t\t\tinlineCompletion.command,\n\t\t\trange,\n\t\t\tinsertText,\n\t\t\tsnippetInfo,\n\t\t\tinlineCompletion.additionalTextEdits || getReadonlyEmptyArray(),\n\t\t\tinlineCompletion,\n\t\t\tsource,\n\t\t);\n\t}\n\n\tconstructor(\n\t\treadonly filterText: string,\n\t\treadonly command: Command | undefined,\n\t\treadonly range: Range,\n\t\treadonly insertText: string,\n\t\treadonly snippetInfo: SnippetInfo | undefined,\n\n\t\treadonly additionalTextEdits: readonly ISingleEditOperation[],\n\n\n\t\t/**\n\t\t * A reference to the original inline completion this inline completion has been constructed from.\n\t\t * Used for event data to ensure referential equality.\n\t\t*/\n\t\treadonly sourceInlineCompletion: InlineCompletion,\n\n\t\t/**\n\t\t * A reference to the original inline completion list this inline completion has been constructed from.\n\t\t * Used for event data to ensure referential equality.\n\t\t*/\n\t\treadonly source: InlineCompletionList,\n\t) {\n\t\tfilterText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n\t\tinsertText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n\t}\n\n\tpublic withRange(updatedRange: Range): InlineCompletionItem {\n\t\treturn new InlineCompletionItem(\n\t\t\tthis.filterText,\n\t\t\tthis.command,\n\t\t\tupdatedRange,\n\t\t\tthis.insertText,\n\t\t\tthis.snippetInfo,\n\t\t\tthis.additionalTextEdits,\n\t\t\tthis.sourceInlineCompletion,\n\t\t\tthis.source,\n\t\t);\n\t}\n\n\tpublic hash(): string {\n\t\treturn JSON.stringify({ insertText: this.insertText, range: this.range.toString() });\n\t}\n\n\tpublic toSingleTextEdit(): SingleTextEdit {\n\t\treturn new SingleTextEdit(this.range, this.insertText);\n\t}\n}\n\nexport interface SnippetInfo {\n\tsnippet: string;\n\t/* Could be different than the main range */\n\trange: Range;\n}\n\nfunction getDefaultRange(position: Position, model: ITextModel): Range {\n\tconst word = model.getWordAtPosition(position);\n\tconst maxColumn = model.getLineMaxColumn(position.lineNumber);\n\t// By default, always replace up until the end of the current line.\n\t// This default might be subject to change!\n\treturn word\n\t\t? new Range(position.lineNumber, word.startColumn, position.lineNumber, maxColumn)\n\t\t: Range.fromPositions(position, position.with(undefined, maxColumn));\n}\n\nfunction closeBrackets(text: string, position: Position, model: ITextModel, languageConfigurationService: ILanguageConfigurationService): string {\n\tconst lineStart = model.getLineContent(position.lineNumber).substring(0, position.column - 1);\n\tconst newLine = lineStart + text;\n\n\tconst newTokens = model.tokenization.tokenizeLineWithEdit(position, newLine.length - (position.column - 1), text);\n\tconst slicedTokens = newTokens?.sliceAndInflate(position.column - 1, newLine.length, 0);\n\tif (!slicedTokens) {\n\t\treturn text;\n\t}\n\n\tconst newText = fixBracketsInLine(slicedTokens, languageConfigurationService);\n\n\treturn newText;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertNever } from '../../../../base/common/assert';\nimport { DeferredPromise } from '../../../../base/common/async';\nimport { CancellationToken } from '../../../../base/common/cancellation';\nimport { SetMap } from '../../../../base/common/map';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors';\nimport { IDisposable } from '../../../../base/common/lifecycle';\nimport { ISingleEditOperation } from '../../../common/core/editOperation';\nimport { Position } from '../../../common/core/position';\nimport { Range } from '../../../common/core/range';\nimport { LanguageFeatureRegistry } from '../../../common/languageFeatureRegistry';\nimport { Command, InlineCompletion, InlineCompletionContext, InlineCompletionProviderGroupId, InlineCompletions, InlineCompletionsProvider } from '../../../common/languages';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry';\nimport { ITextModel } from '../../../common/model';\nimport { fixBracketsInLine } from '../../../common/model/bracketPairsTextModelPart/fixBrackets';\nimport { SingleTextEdit } from './singleTextEdit';\nimport { getReadonlyEmptyArray } from './utils';\nimport { SnippetParser, Text } from '../../snippet/browser/snippetParser';\n\nexport async function provideInlineCompletions(\n\tregistry: LanguageFeatureRegistry<InlineCompletionsProvider>,\n\tposition: Position,\n\tmodel: ITextModel,\n\tcontext: InlineCompletionContext,\n\ttoken: CancellationToken = CancellationToken.None,\n\tlanguageConfigurationService?: ILanguageConfigurationService,\n): Promise<InlineCompletionProviderResult> {\n\t// Important: Don't use position after the await calls, as the model could have been changed in the meantime!\n\tconst defaultReplaceRange = getDefaultRange(position, model);\n\tconst providers = registry.all(model);\n\n\tconst multiMap = new SetMap<InlineCompletionProviderGroupId, InlineCompletionsProvider<any>>();\n\tfor (const provider of providers) {\n\t\tif (provider.groupId) {\n\t\t\tmultiMap.add(provider.groupId, provider);\n\t\t}\n\t}\n\n\tfunction getPreferredProviders(provider: InlineCompletionsProvider<any>): InlineCompletionsProvider<any>[] {\n\t\tif (!provider.yieldsToGroupIds) { return []; }\n\t\tconst result: InlineCompletionsProvider<any>[] = [];\n\t\tfor (const groupId of provider.yieldsToGroupIds || []) {\n\t\t\tconst providers = multiMap.get(groupId);\n\t\t\tfor (const p of providers) {\n\t\t\t\tresult.push(p);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\ttype Result = Promise<InlineCompletions<InlineCompletion> | null | undefined>;\n\tconst states = new Map<InlineCompletionsProvider<InlineCompletions<InlineCompletion>>, Result>();\n\n\tconst seen = new Set<InlineCompletionsProvider<InlineCompletions<InlineCompletion>>>();\n\tfunction findPreferredProviderCircle(provider: InlineCompletionsProvider<any>, stack: InlineCompletionsProvider[]): InlineCompletionsProvider[] | undefined {\n\t\tstack = [...stack, provider];\n\t\tif (seen.has(provider)) { return stack; }\n\n\t\tseen.add(provider);\n\t\ttry {\n\t\t\tconst preferred = getPreferredProviders(provider);\n\t\t\tfor (const p of preferred) {\n\t\t\t\tconst c = findPreferredProviderCircle(p, stack);\n\t\t\t\tif (c) { return c; }\n\t\t\t}\n\t\t} finally {\n\t\t\tseen.delete(provider);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tfunction processProvider(provider: InlineCompletionsProvider<any>): Result {\n\t\tconst state = states.get(provider);\n\t\tif (state) {\n\t\t\treturn state;\n\t\t}\n\n\t\tconst circle = findPreferredProviderCircle(provider, []);\n\t\tif (circle) {\n\t\t\tonUnexpectedExternalError(new Error(`Inline completions: cyclic yield-to dependency detected. Path: ${circle.map(s => s.toString ? s.toString() : ('' + s)).join(' -> ')}`));\n\t\t}\n\n\t\tconst deferredPromise = new DeferredPromise<InlineCompletions<InlineCompletion> | null | undefined>();\n\t\tstates.set(provider, deferredPromise.p);\n\n\t\t(async () => {\n\t\t\tif (!circle) {\n\t\t\t\tconst preferred = getPreferredProviders(provider);\n\t\t\t\tfor (const p of preferred) {\n\t\t\t\t\tconst result = await processProvider(p);\n\t\t\t\t\tif (result && result.items.length > 0) {\n\t\t\t\t\t\t// Skip provider\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst completions = await provider.provideInlineCompletions(model, position, context, token);\n\t\t\t\treturn completions;\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedExternalError(e);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t})().then(c => deferredPromise.complete(c), e => deferredPromise.error(e));\n\n\t\treturn deferredPromise.p;\n\t}\n\n\tconst providerResults = await Promise.all(providers.map(async provider => ({ provider, completions: await processProvider(provider) })));\n\n\tconst itemsByHash = new Map<string, InlineCompletionItem>();\n\tconst lists: InlineCompletionList[] = [];\n\tfor (const result of providerResults) {\n\t\tconst completions = result.completions;\n\t\tif (!completions) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst list = new InlineCompletionList(completions, result.provider);\n\t\tlists.push(list);\n\n\t\tfor (const item of completions.items) {\n\t\t\tconst inlineCompletionItem = InlineCompletionItem.from(\n\t\t\t\titem,\n\t\t\t\tlist,\n\t\t\t\tdefaultReplaceRange,\n\t\t\t\tmodel,\n\t\t\t\tlanguageConfigurationService\n\t\t\t);\n\t\t\titemsByHash.set(inlineCompletionItem.hash(), inlineCompletionItem);\n\t\t}\n\t}\n\n\treturn new InlineCompletionProviderResult(Array.from(itemsByHash.values()), new Set(itemsByHash.keys()), lists);\n}\n\nexport class InlineCompletionProviderResult implements IDisposable {\n\n\tconstructor(\n\t\t/**\n\t\t * Free of duplicates.\n\t\t */\n\t\tpublic readonly completions: readonly InlineCompletionItem[],\n\t\tprivate readonly hashs: Set<string>,\n\t\tprivate readonly providerResults: readonly InlineCompletionList[],\n\t) { }\n\n\tpublic has(item: InlineCompletionItem): boolean {\n\t\treturn this.hashs.has(item.hash());\n\t}\n\n\tdispose(): void {\n\t\tfor (const result of this.providerResults) {\n\t\t\tresult.removeRef();\n\t\t}\n\t}\n}\n\n/**\n * A ref counted pointer to the computed `InlineCompletions` and the `InlineCompletionsProvider` that\n * computed them.\n */\nexport class InlineCompletionList {\n\tprivate refCount = 1;\n\tconstructor(\n\t\tpublic readonly inlineCompletions: InlineCompletions,\n\t\tpublic readonly provider: InlineCompletionsProvider,\n\t) { }\n\n\taddRef(): void {\n\t\tthis.refCount++;\n\t}\n\n\tremoveRef(): void {\n\t\tthis.refCount--;\n\t\tif (this.refCount === 0) {\n\t\t\tthis.provider.freeInlineCompletions(this.inlineCompletions);\n\t\t}\n\t}\n}\n\nexport class InlineCompletionItem {\n\tpublic static from(\n\t\tinlineCompletion: InlineCompletion,\n\t\tsource: InlineCompletionList,\n\t\tdefaultReplaceRange: Range,\n\t\ttextModel: ITextModel,\n\t\tlanguageConfigurationService: ILanguageConfigurationService | undefined,\n\t) {\n\t\tlet insertText: string;\n\t\tlet snippetInfo: SnippetInfo | undefined;\n\t\tlet range = inlineCompletion.range ? Range.lift(inlineCompletion.range) : defaultReplaceRange;\n\n\t\tif (typeof inlineCompletion.insertText === 'string') {\n\t\t\tinsertText = inlineCompletion.insertText;\n\n\t\t\tif (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n\t\t\t\tinsertText = closeBrackets(\n\t\t\t\t\tinsertText,\n\t\t\t\t\trange.getStartPosition(),\n\t\t\t\t\ttextModel,\n\t\t\t\t\tlanguageConfigurationService\n\t\t\t\t);\n\n\t\t\t\t// Modify range depending on if brackets are added or removed\n\t\t\t\tconst diff = insertText.length - inlineCompletion.insertText.length;\n\t\t\t\tif (diff !== 0) {\n\t\t\t\t\trange = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsnippetInfo = undefined;\n\t\t} else if ('snippet' in inlineCompletion.insertText) {\n\t\t\tconst preBracketCompletionLength = inlineCompletion.insertText.snippet.length;\n\n\t\t\tif (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n\t\t\t\tinlineCompletion.insertText.snippet = closeBrackets(\n\t\t\t\t\tinlineCompletion.insertText.snippet,\n\t\t\t\t\trange.getStartPosition(),\n\t\t\t\t\ttextModel,\n\t\t\t\t\tlanguageConfigurationService\n\t\t\t\t);\n\n\t\t\t\t// Modify range depending on if brackets are added or removed\n\t\t\t\tconst diff = inlineCompletion.insertText.snippet.length - preBracketCompletionLength;\n\t\t\t\tif (diff !== 0) {\n\t\t\t\t\trange = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst snippet = new SnippetParser().parse(inlineCompletion.insertText.snippet);\n\n\t\t\tif (snippet.children.length === 1 && snippet.children[0] instanceof Text) {\n\t\t\t\tinsertText = snippet.children[0].value;\n\t\t\t\tsnippetInfo = undefined;\n\t\t\t} else {\n\t\t\t\tinsertText = snippet.toString();\n\t\t\t\tsnippetInfo = {\n\t\t\t\t\tsnippet: inlineCompletion.insertText.snippet,\n\t\t\t\t\trange: range\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tassertNever(inlineCompletion.insertText);\n\t\t}\n\n\t\treturn new InlineCompletionItem(\n\t\t\tinsertText,\n\t\t\tinlineCompletion.command,\n\t\t\trange,\n\t\t\tinsertText,\n\t\t\tsnippetInfo,\n\t\t\tinlineCompletion.additionalTextEdits || getReadonlyEmptyArray(),\n\t\t\tinlineCompletion,\n\t\t\tsource,\n\t\t);\n\t}\n\n\tconstructor(\n\t\treadonly filterText: string,\n\t\treadonly command: Command | undefined,\n\t\treadonly range: Range,\n\t\treadonly insertText: string,\n\t\treadonly snippetInfo: SnippetInfo | undefined,\n\n\t\treadonly additionalTextEdits: readonly ISingleEditOperation[],\n\n\n\t\t/**\n\t\t * A reference to the original inline completion this inline completion has been constructed from.\n\t\t * Used for event data to ensure referential equality.\n\t\t*/\n\t\treadonly sourceInlineCompletion: InlineCompletion,\n\n\t\t/**\n\t\t * A reference to the original inline completion list this inline completion has been constructed from.\n\t\t * Used for event data to ensure referential equality.\n\t\t*/\n\t\treadonly source: InlineCompletionList,\n\t) {\n\t\tfilterText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n\t\tinsertText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n\t}\n\n\tpublic withRange(updatedRange: Range): InlineCompletionItem {\n\t\treturn new InlineCompletionItem(\n\t\t\tthis.filterText,\n\t\t\tthis.command,\n\t\t\tupdatedRange,\n\t\t\tthis.insertText,\n\t\t\tthis.snippetInfo,\n\t\t\tthis.additionalTextEdits,\n\t\t\tthis.sourceInlineCompletion,\n\t\t\tthis.source,\n\t\t);\n\t}\n\n\tpublic hash(): string {\n\t\treturn JSON.stringify({ insertText: this.insertText, range: this.range.toString() });\n\t}\n\n\tpublic toSingleTextEdit(): SingleTextEdit {\n\t\treturn new SingleTextEdit(this.range, this.insertText);\n\t}\n}\n\nexport interface SnippetInfo {\n\tsnippet: string;\n\t/* Could be different than the main range */\n\trange: Range;\n}\n\nfunction getDefaultRange(position: Position, model: ITextModel): Range {\n\tconst word = model.getWordAtPosition(position);\n\tconst maxColumn = model.getLineMaxColumn(position.lineNumber);\n\t// By default, always replace up until the end of the current line.\n\t// This default might be subject to change!\n\treturn word\n\t\t? new Range(position.lineNumber, word.startColumn, position.lineNumber, maxColumn)\n\t\t: Range.fromPositions(position, position.with(undefined, maxColumn));\n}\n\nfunction closeBrackets(text: string, position: Position, model: ITextModel, languageConfigurationService: ILanguageConfigurationService): string {\n\tconst lineStart = model.getLineContent(position.lineNumber).substring(0, position.column - 1);\n\tconst newLine = lineStart + text;\n\n\tconst newTokens = model.tokenization.tokenizeLineWithEdit(position, newLine.length - (position.column - 1), text);\n\tconst slicedTokens = newTokens?.sliceAndInflate(position.column - 1, newLine.length, 0);\n\tif (!slicedTokens) {\n\t\treturn text;\n\t}\n\n\tconst newText = fixBracketsInLine(slicedTokens, languageConfigurationService);\n\n\treturn newText;\n}\n"]}