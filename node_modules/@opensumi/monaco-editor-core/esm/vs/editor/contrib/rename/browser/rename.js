"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var RenameController_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.RenameAction = exports.rename = void 0;
const aria_1 = require("../../../../base/browser/ui/aria/aria");
const async_1 = require("../../../../base/common/async");
const cancellation_1 = require("../../../../base/common/cancellation");
const errors_1 = require("../../../../base/common/errors");
const lifecycle_1 = require("../../../../base/common/lifecycle");
const types_1 = require("../../../../base/common/types");
const uri_1 = require("../../../../base/common/uri");
const editorExtensions_1 = require("../../../browser/editorExtensions");
const bulkEditService_1 = require("../../../browser/services/bulkEditService");
const codeEditorService_1 = require("../../../browser/services/codeEditorService");
const position_1 = require("../../../common/core/position");
const range_1 = require("../../../common/core/range");
const editorContextKeys_1 = require("../../../common/editorContextKeys");
const languageFeatures_1 = require("../../../common/services/languageFeatures");
const textResourceConfiguration_1 = require("../../../common/services/textResourceConfiguration");
const editorState_1 = require("../../editorState/browser/editorState");
const messageController_1 = require("../../message/browser/messageController");
const nls = require("../../../../nls");
const actions_1 = require("../../../../platform/actions/common/actions");
const configurationRegistry_1 = require("../../../../platform/configuration/common/configurationRegistry");
const contextkey_1 = require("../../../../platform/contextkey/common/contextkey");
const instantiation_1 = require("../../../../platform/instantiation/common/instantiation");
const log_1 = require("../../../../platform/log/common/log");
const notification_1 = require("../../../../platform/notification/common/notification");
const progress_1 = require("../../../../platform/progress/common/progress");
const platform_1 = require("../../../../platform/registry/common/platform");
const telemetry_1 = require("../../../../platform/telemetry/common/telemetry");
const renameInputField_1 = require("./renameInputField");
class RenameSkeleton {
    constructor(model, position, registry) {
        this.model = model;
        this.position = position;
        this._providerRenameIdx = 0;
        this._providers = registry.ordered(model);
    }
    hasProvider() {
        return this._providers.length > 0;
    }
    async resolveRenameLocation(token) {
        const rejects = [];
        for (this._providerRenameIdx = 0; this._providerRenameIdx < this._providers.length; this._providerRenameIdx++) {
            const provider = this._providers[this._providerRenameIdx];
            if (!provider.resolveRenameLocation) {
                break;
            }
            const res = await provider.resolveRenameLocation(this.model, this.position, token);
            if (!res) {
                continue;
            }
            if (res.rejectReason) {
                rejects.push(res.rejectReason);
                continue;
            }
            return res;
        }
        // we are here when no provider prepared a location which means we can
        // just rely on the word under cursor and start with the first provider
        this._providerRenameIdx = 0;
        const word = this.model.getWordAtPosition(this.position);
        if (!word) {
            return {
                range: range_1.Range.fromPositions(this.position),
                text: '',
                rejectReason: rejects.length > 0 ? rejects.join('\n') : undefined
            };
        }
        return {
            range: new range_1.Range(this.position.lineNumber, word.startColumn, this.position.lineNumber, word.endColumn),
            text: word.word,
            rejectReason: rejects.length > 0 ? rejects.join('\n') : undefined
        };
    }
    async provideRenameEdits(newName, token) {
        return this._provideRenameEdits(newName, this._providerRenameIdx, [], token);
    }
    async _provideRenameEdits(newName, i, rejects, token) {
        const provider = this._providers[i];
        if (!provider) {
            return {
                edits: [],
                rejectReason: rejects.join('\n')
            };
        }
        const result = await provider.provideRenameEdits(this.model, this.position, newName, token);
        if (!result) {
            return this._provideRenameEdits(newName, i + 1, rejects.concat(nls.localize("vs/editor/contrib/rename/browser/rename",0, "No result.")), token);
        }
        else if (result.rejectReason) {
            return this._provideRenameEdits(newName, i + 1, rejects.concat(result.rejectReason), token);
        }
        return result;
    }
}
async function rename(registry, model, position, newName) {
    const skeleton = new RenameSkeleton(model, position, registry);
    const loc = await skeleton.resolveRenameLocation(cancellation_1.CancellationToken.None);
    if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) {
        return { edits: [], rejectReason: loc.rejectReason };
    }
    return skeleton.provideRenameEdits(newName, cancellation_1.CancellationToken.None);
}
exports.rename = rename;
// ---  register actions and commands
let RenameController = RenameController_1 = class RenameController {
    static get(editor) {
        return editor.getContribution(RenameController_1.ID);
    }
    constructor(editor, _instaService, _notificationService, _bulkEditService, _progressService, _logService, _configService, _languageFeaturesService, _telemetryService) {
        this.editor = editor;
        this._instaService = _instaService;
        this._notificationService = _notificationService;
        this._bulkEditService = _bulkEditService;
        this._progressService = _progressService;
        this._logService = _logService;
        this._configService = _configService;
        this._languageFeaturesService = _languageFeaturesService;
        this._telemetryService = _telemetryService;
        this._disposableStore = new lifecycle_1.DisposableStore();
        this._cts = new cancellation_1.CancellationTokenSource();
        this._renameInputField = this._disposableStore.add(this._instaService.createInstance(renameInputField_1.RenameInputField, this.editor, ['acceptRenameInput', 'acceptRenameInputWithPreview']));
    }
    dispose() {
        this._disposableStore.dispose();
        this._cts.dispose(true);
    }
    async run() {
        var _a, _b;
        const trace = this._logService.trace.bind(this._logService, '[rename]');
        // set up cancellation token to prevent reentrant rename, this
        // is the parent to the resolve- and rename-tokens
        this._cts.dispose(true);
        this._cts = new cancellation_1.CancellationTokenSource();
        if (!this.editor.hasModel()) {
            trace('editor has no model');
            return undefined;
        }
        const position = this.editor.getPosition();
        const skeleton = new RenameSkeleton(this.editor.getModel(), position, this._languageFeaturesService.renameProvider);
        if (!skeleton.hasProvider()) {
            trace('skeleton has no provider');
            return undefined;
        }
        // part 1 - resolve rename location
        const cts1 = new editorState_1.EditorStateCancellationTokenSource(this.editor, 4 /* CodeEditorStateFlag.Position */ | 1 /* CodeEditorStateFlag.Value */, undefined, this._cts.token);
        let loc;
        try {
            trace('resolving rename location');
            const resolveLocationOperation = skeleton.resolveRenameLocation(cts1.token);
            this._progressService.showWhile(resolveLocationOperation, 250);
            loc = await resolveLocationOperation;
            trace('resolved rename location');
        }
        catch (e) {
            trace('resolve rename location failed', JSON.stringify(e, null, '\t'));
            (_a = messageController_1.MessageController.get(this.editor)) === null || _a === void 0 ? void 0 : _a.showMessage(e || nls.localize("vs/editor/contrib/rename/browser/rename",1, "An unknown error occurred while resolving rename location"), position);
            return undefined;
        }
        finally {
            cts1.dispose();
        }
        if (!loc) {
            trace('returning early - no loc');
            return undefined;
        }
        if (loc.rejectReason) {
            trace(`returning early - rejected with reason: ${loc.rejectReason}`, loc.rejectReason);
            (_b = messageController_1.MessageController.get(this.editor)) === null || _b === void 0 ? void 0 : _b.showMessage(loc.rejectReason, position);
            return undefined;
        }
        if (cts1.token.isCancellationRequested) {
            trace('returning early - cts1 cancelled');
            return undefined;
        }
        // part 2 - do rename at location
        const cts2 = new editorState_1.EditorStateCancellationTokenSource(this.editor, 4 /* CodeEditorStateFlag.Position */ | 1 /* CodeEditorStateFlag.Value */, loc.range, this._cts.token);
        const model = this.editor.getModel(); // @ulugbekna: assumes editor still has a model, otherwise, cts1 should've been cancelled
        const renameCandidatesCts = new cancellation_1.CancellationTokenSource(cts2.token);
        const newSymbolNamesProviders = this._languageFeaturesService.newSymbolNamesProvider.all(model);
        // TODO@ulugbekna: providers should get timeout token (use createTimeoutCancellation(x))
        const newSymbolNameProvidersResults = newSymbolNamesProviders.map(p => p.provideNewSymbolNames(model, loc.range, renameCandidatesCts.token));
        trace(`requested new symbol names from ${newSymbolNamesProviders.length} providers`);
        const selection = this.editor.getSelection();
        let selectionStart = 0;
        let selectionEnd = loc.text.length;
        if (!range_1.Range.isEmpty(selection) && !range_1.Range.spansMultipleLines(selection) && range_1.Range.containsRange(loc.range, selection)) {
            selectionStart = Math.max(0, selection.startColumn - loc.range.startColumn);
            selectionEnd = Math.min(loc.range.endColumn, selection.endColumn) - loc.range.startColumn;
        }
        trace('creating rename input field and awaiting its result');
        const supportPreview = this._bulkEditService.hasPreviewHandler() && this._configService.getValue(this.editor.getModel().uri, 'editor.rename.enablePreview');
        const inputFieldResult = await this._renameInputField.getInput(loc.range, loc.text, selectionStart, selectionEnd, supportPreview, newSymbolNameProvidersResults, renameCandidatesCts);
        trace('received response from rename input field');
        if (newSymbolNamesProviders.length > 0) { // @ulugbekna: we're interested only in telemetry for rename suggestions currently
            this._reportTelemetry(newSymbolNamesProviders.length, model.getLanguageId(), inputFieldResult);
        }
        // no result, only hint to focus the editor or not
        if (typeof inputFieldResult === 'boolean') {
            trace(`returning early - rename input field response - ${inputFieldResult}`);
            if (inputFieldResult) {
                this.editor.focus();
            }
            cts2.dispose();
            return undefined;
        }
        this.editor.focus();
        trace('requesting rename edits');
        const renameOperation = (0, async_1.raceCancellation)(skeleton.provideRenameEdits(inputFieldResult.newName, cts2.token), cts2.token).then(async (renameResult) => {
            if (!renameResult) {
                trace('returning early - no rename edits result');
                return;
            }
            if (!this.editor.hasModel()) {
                trace('returning early - no model after rename edits are provided');
                return;
            }
            if (renameResult.rejectReason) {
                trace(`returning early - rejected with reason: ${renameResult.rejectReason}`);
                this._notificationService.info(renameResult.rejectReason);
                return;
            }
            // collapse selection to active end
            this.editor.setSelection(range_1.Range.fromPositions(this.editor.getSelection().getPosition()));
            trace('applying edits');
            this._bulkEditService.apply(renameResult, {
                editor: this.editor,
                showPreview: inputFieldResult.wantsPreview,
                label: nls.localize("vs/editor/contrib/rename/browser/rename",2, "Renaming '{0}' to '{1}'", loc === null || loc === void 0 ? void 0 : loc.text, inputFieldResult.newName),
                code: 'undoredo.rename',
                quotableLabel: nls.localize("vs/editor/contrib/rename/browser/rename",3, "Renaming {0} to {1}", loc === null || loc === void 0 ? void 0 : loc.text, inputFieldResult.newName),
                respectAutoSaveConfig: true
            }).then(result => {
                trace('edits applied');
                if (result.ariaSummary) {
                    (0, aria_1.alert)(nls.localize("vs/editor/contrib/rename/browser/rename",4, "Successfully renamed '{0}' to '{1}'. Summary: {2}", loc.text, inputFieldResult.newName, result.ariaSummary));
                }
            }).catch(err => {
                trace(`error when applying edits ${JSON.stringify(err, null, '\t')}`);
                this._notificationService.error(nls.localize("vs/editor/contrib/rename/browser/rename",5, "Rename failed to apply edits"));
                this._logService.error(err);
            });
        }, err => {
            trace('error when providing rename edits', JSON.stringify(err, null, '\t'));
            this._notificationService.error(nls.localize("vs/editor/contrib/rename/browser/rename",6, "Rename failed to compute edits"));
            this._logService.error(err);
        }).finally(() => {
            cts2.dispose();
        });
        trace('returning rename operation');
        this._progressService.showWhile(renameOperation, 250);
        return renameOperation;
    }
    acceptRenameInput(wantsPreview) {
        this._renameInputField.acceptInput(wantsPreview);
    }
    cancelRenameInput() {
        this._renameInputField.cancelInput(true, 'cancelRenameInput command');
    }
    focusNextRenameSuggestion() {
        this._renameInputField.focusNextRenameSuggestion();
    }
    focusPreviousRenameSuggestion() {
        this._renameInputField.focusPreviousRenameSuggestion();
    }
    _reportTelemetry(nRenameSuggestionProviders, languageId, inputFieldResult) {
        const value = typeof inputFieldResult === 'boolean'
            ? {
                kind: 'cancelled',
                languageId,
                nRenameSuggestionProviders,
            }
            : {
                kind: 'accepted',
                languageId,
                nRenameSuggestionProviders,
                source: inputFieldResult.source,
                nRenameSuggestions: inputFieldResult.nRenameSuggestions,
                wantsPreview: inputFieldResult.wantsPreview,
            };
        this._telemetryService.publicLog2('renameInvokedEvent', value);
    }
};
RenameController.ID = 'editor.contrib.renameController';
RenameController = RenameController_1 = __decorate([
    __param(1, instantiation_1.IInstantiationService),
    __param(2, notification_1.INotificationService),
    __param(3, bulkEditService_1.IBulkEditService),
    __param(4, progress_1.IEditorProgressService),
    __param(5, log_1.ILogService),
    __param(6, textResourceConfiguration_1.ITextResourceConfigurationService),
    __param(7, languageFeatures_1.ILanguageFeaturesService),
    __param(8, telemetry_1.ITelemetryService)
], RenameController);
// ---- action implementation
class RenameAction extends editorExtensions_1.EditorAction {
    constructor() {
        super({
            id: 'editor.action.rename',
            label: nls.localize("vs/editor/contrib/rename/browser/rename",7, "Rename Symbol"),
            alias: 'Rename Symbol',
            precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, editorContextKeys_1.EditorContextKeys.hasRenameProvider),
            kbOpts: {
                kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,
                primary: 60 /* KeyCode.F2 */,
                weight: 100 /* KeybindingWeight.EditorContrib */
            },
            contextMenuOpts: {
                group: '1_modification',
                order: 1.1
            }
        });
    }
    runCommand(accessor, args) {
        const editorService = accessor.get(codeEditorService_1.ICodeEditorService);
        const [uri, pos] = Array.isArray(args) && args || [undefined, undefined];
        if (uri_1.URI.isUri(uri) && position_1.Position.isIPosition(pos)) {
            return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then(editor => {
                if (!editor) {
                    return;
                }
                editor.setPosition(pos);
                editor.invokeWithinContext(accessor => {
                    this.reportTelemetry(accessor, editor);
                    return this.run(accessor, editor);
                });
            }, errors_1.onUnexpectedError);
        }
        return super.runCommand(accessor, args);
    }
    run(accessor, editor) {
        const logService = accessor.get(log_1.ILogService);
        const controller = RenameController.get(editor);
        if (controller) {
            logService.trace('[RenameAction] got controller, running...');
            return controller.run();
        }
        logService.trace('[RenameAction] returning early - controller missing');
        return Promise.resolve();
    }
}
exports.RenameAction = RenameAction;
(0, editorExtensions_1.registerEditorContribution)(RenameController.ID, RenameController, 4 /* EditorContributionInstantiation.Lazy */);
(0, editorExtensions_1.registerEditorAction)(RenameAction);
const RenameCommand = editorExtensions_1.EditorCommand.bindToContribution(RenameController.get);
(0, editorExtensions_1.registerEditorCommand)(new RenameCommand({
    id: 'acceptRenameInput',
    precondition: renameInputField_1.CONTEXT_RENAME_INPUT_VISIBLE,
    handler: x => x.acceptRenameInput(false),
    kbOpts: {
        weight: 100 /* KeybindingWeight.EditorContrib */ + 99,
        kbExpr: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.focus, contextkey_1.ContextKeyExpr.not('isComposing')),
        primary: 3 /* KeyCode.Enter */
    }
}));
(0, editorExtensions_1.registerEditorCommand)(new RenameCommand({
    id: 'acceptRenameInputWithPreview',
    precondition: contextkey_1.ContextKeyExpr.and(renameInputField_1.CONTEXT_RENAME_INPUT_VISIBLE, contextkey_1.ContextKeyExpr.has('config.editor.rename.enablePreview')),
    handler: x => x.acceptRenameInput(true),
    kbOpts: {
        weight: 100 /* KeybindingWeight.EditorContrib */ + 99,
        kbExpr: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.focus, contextkey_1.ContextKeyExpr.not('isComposing')),
        primary: 1024 /* KeyMod.Shift */ + 3 /* KeyCode.Enter */
    }
}));
(0, editorExtensions_1.registerEditorCommand)(new RenameCommand({
    id: 'cancelRenameInput',
    precondition: renameInputField_1.CONTEXT_RENAME_INPUT_VISIBLE,
    handler: x => x.cancelRenameInput(),
    kbOpts: {
        weight: 100 /* KeybindingWeight.EditorContrib */ + 99,
        kbExpr: editorContextKeys_1.EditorContextKeys.focus,
        primary: 9 /* KeyCode.Escape */,
        secondary: [1024 /* KeyMod.Shift */ | 9 /* KeyCode.Escape */]
    }
}));
(0, actions_1.registerAction2)(class FocusNextRenameSuggestion extends actions_1.Action2 {
    constructor() {
        super({
            id: 'focusNextRenameSuggestion',
            title: {
                ...nls.localize2("vs/editor/contrib/rename/browser/rename",9, "Focus Next Rename Suggestion"),
            },
            precondition: renameInputField_1.CONTEXT_RENAME_INPUT_VISIBLE,
            keybinding: [
                {
                    primary: 2 /* KeyCode.Tab */,
                    secondary: [18 /* KeyCode.DownArrow */],
                    weight: 100 /* KeybindingWeight.EditorContrib */ + 99,
                }
            ]
        });
    }
    run(accessor) {
        const currentEditor = accessor.get(codeEditorService_1.ICodeEditorService).getFocusedCodeEditor();
        if (!currentEditor) {
            return;
        }
        const controller = RenameController.get(currentEditor);
        if (!controller) {
            return;
        }
        controller.focusNextRenameSuggestion();
    }
});
(0, actions_1.registerAction2)(class FocusPreviousRenameSuggestion extends actions_1.Action2 {
    constructor() {
        super({
            id: 'focusPreviousRenameSuggestion',
            title: {
                ...nls.localize2("vs/editor/contrib/rename/browser/rename",10, "Focus Previous Rename Suggestion"),
            },
            precondition: renameInputField_1.CONTEXT_RENAME_INPUT_VISIBLE,
            keybinding: [
                {
                    when: renameInputField_1.CONTEXT_RENAME_INPUT_FOCUSED,
                    primary: 2 /* KeyCode.Tab */ | 4 /* KeyCode.Shift */,
                    weight: 100 /* KeybindingWeight.EditorContrib */ + 99,
                },
                {
                    when: renameInputField_1.CONTEXT_RENAME_INPUT_FOCUSED.toNegated(),
                    primary: 1024 /* KeyMod.Shift */ | 2 /* KeyCode.Tab */,
                    secondary: [16 /* KeyCode.UpArrow */],
                    weight: 100 /* KeybindingWeight.EditorContrib */ + 99,
                }
            ]
        });
    }
    run(accessor) {
        const currentEditor = accessor.get(codeEditorService_1.ICodeEditorService).getFocusedCodeEditor();
        if (!currentEditor) {
            return;
        }
        const controller = RenameController.get(currentEditor);
        if (!controller) {
            return;
        }
        controller.focusPreviousRenameSuggestion();
    }
});
// ---- api bridge command
(0, editorExtensions_1.registerModelAndPositionCommand)('_executeDocumentRenameProvider', function (accessor, model, position, ...args) {
    const [newName] = args;
    (0, types_1.assertType)(typeof newName === 'string');
    const { renameProvider } = accessor.get(languageFeatures_1.ILanguageFeaturesService);
    return rename(renameProvider, model, position, newName);
});
(0, editorExtensions_1.registerModelAndPositionCommand)('_executePrepareRename', async function (accessor, model, position) {
    const { renameProvider } = accessor.get(languageFeatures_1.ILanguageFeaturesService);
    const skeleton = new RenameSkeleton(model, position, renameProvider);
    const loc = await skeleton.resolveRenameLocation(cancellation_1.CancellationToken.None);
    if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) {
        throw new Error(loc.rejectReason);
    }
    return loc;
});
//todo@jrieken use editor options world
platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).registerConfiguration({
    id: 'editor',
    properties: {
        'editor.rename.enablePreview': {
            scope: 5 /* ConfigurationScope.LANGUAGE_OVERRIDABLE */,
            description: nls.localize("vs/editor/contrib/rename/browser/rename",8, "Enable/disable the ability to preview changes before renaming"),
            default: true,
            type: 'boolean'
        }
    }
});
//# sourceMappingURL=rename.js.map