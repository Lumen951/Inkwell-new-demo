"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.goToDefinitionWithLocation = exports.showGoToContextMenu = void 0;
const dom = require("../../../../base/browser/dom");
const actions_1 = require("../../../../base/common/actions");
const cancellation_1 = require("../../../../base/common/cancellation");
const uuid_1 = require("../../../../base/common/uuid");
const range_1 = require("../../../common/core/range");
const resolverService_1 = require("../../../common/services/resolverService");
const goToCommands_1 = require("../../gotoSymbol/browser/goToCommands");
const peekView_1 = require("../../peekView/browser/peekView");
const actions_2 = require("../../../../platform/actions/common/actions");
const commands_1 = require("../../../../platform/commands/common/commands");
const contextkey_1 = require("../../../../platform/contextkey/common/contextkey");
const contextView_1 = require("../../../../platform/contextview/browser/contextView");
const instantiation_1 = require("../../../../platform/instantiation/common/instantiation");
const notification_1 = require("../../../../platform/notification/common/notification");
async function showGoToContextMenu(accessor, editor, anchor, part) {
    var _a;
    const resolverService = accessor.get(resolverService_1.ITextModelService);
    const contextMenuService = accessor.get(contextView_1.IContextMenuService);
    const commandService = accessor.get(commands_1.ICommandService);
    const instaService = accessor.get(instantiation_1.IInstantiationService);
    const notificationService = accessor.get(notification_1.INotificationService);
    await part.item.resolve(cancellation_1.CancellationToken.None);
    if (!part.part.location) {
        return;
    }
    const location = part.part.location;
    const menuActions = [];
    // from all registered (not active) context menu actions select those
    // that are a symbol navigation actions
    const filter = new Set(actions_2.MenuRegistry.getMenuItems(actions_2.MenuId.EditorContext)
        .map(item => (0, actions_2.isIMenuItem)(item) ? item.command.id : (0, uuid_1.generateUuid)()));
    for (const delegate of goToCommands_1.SymbolNavigationAction.all()) {
        if (filter.has(delegate.desc.id)) {
            menuActions.push(new actions_1.Action(delegate.desc.id, actions_2.MenuItemAction.label(delegate.desc, { renderShortTitle: true }), undefined, true, async () => {
                const ref = await resolverService.createModelReference(location.uri);
                try {
                    const symbolAnchor = new goToCommands_1.SymbolNavigationAnchor(ref.object.textEditorModel, range_1.Range.getStartPosition(location.range));
                    const range = part.item.anchor.range;
                    await instaService.invokeFunction(delegate.runEditorCommand.bind(delegate), editor, symbolAnchor, range);
                }
                finally {
                    ref.dispose();
                }
            }));
        }
    }
    if (part.part.command) {
        const { command } = part.part;
        menuActions.push(new actions_1.Separator());
        menuActions.push(new actions_1.Action(command.id, command.title, undefined, true, async () => {
            var _a;
            try {
                await commandService.executeCommand(command.id, ...((_a = command.arguments) !== null && _a !== void 0 ? _a : []));
            }
            catch (err) {
                notificationService.notify({
                    severity: notification_1.Severity.Error,
                    source: part.item.provider.displayName,
                    message: err
                });
            }
        }));
    }
    // show context menu
    const useShadowDOM = editor.getOption(127 /* EditorOption.useShadowDOM */);
    contextMenuService.showContextMenu({
        domForShadowRoot: useShadowDOM ? (_a = editor.getDomNode()) !== null && _a !== void 0 ? _a : undefined : undefined,
        getAnchor: () => {
            const box = dom.getDomNodePagePosition(anchor);
            return { x: box.left, y: box.top + box.height + 8 };
        },
        getActions: () => menuActions,
        onHide: () => {
            editor.focus();
        },
        autoSelectFirstItem: true,
    });
}
exports.showGoToContextMenu = showGoToContextMenu;
async function goToDefinitionWithLocation(accessor, event, editor, location) {
    const resolverService = accessor.get(resolverService_1.ITextModelService);
    const ref = await resolverService.createModelReference(location.uri);
    await editor.invokeWithinContext(async (accessor) => {
        const openToSide = event.hasSideBySideModifier;
        const contextKeyService = accessor.get(contextkey_1.IContextKeyService);
        const isInPeek = peekView_1.PeekContext.inPeekEditor.getValue(contextKeyService);
        const canPeek = !openToSide && editor.getOption(88 /* EditorOption.definitionLinkOpensInPeek */) && !isInPeek;
        const action = new goToCommands_1.DefinitionAction({ openToSide, openInPeek: canPeek, muteMessage: true }, { title: { value: '', original: '' }, id: '', precondition: undefined });
        return action.run(accessor, new goToCommands_1.SymbolNavigationAnchor(ref.object.textEditorModel, range_1.Range.getStartPosition(location.range)), range_1.Range.lift(location.range));
    });
    ref.dispose();
}
exports.goToDefinitionWithLocation = goToDefinitionWithLocation;
//# sourceMappingURL=inlayHintsLocations.js.map